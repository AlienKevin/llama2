

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlayS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let new


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlay


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        new


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlay


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | Pause


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrent


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | Remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | Add


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let new


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlay


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
     


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
        new


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
        newPlay


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
        newPlaylist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
        newPlaylist end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
        newPlaylist end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
        newPlaylist end
in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | PlaySong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        let newPlaylist = ([songId], PausedOn(songId)) in
        newPlaylist
      else
        playlist
    | PauseCurrentSong => 
      match get_state(playlist) with
      | Playing(songId) => ([songId], PausedOn(songId))
      | NoSongSelected => playlist
      | PausedOn(_) => playlist end
    | RemoveSong(songId) => 
      let songs, _ = playlist in
      if List.contains((=), songId, songs) then
        ([], NoSongSelected)
      else
        playlist
    | AddSong(songId) => 
      let songs, state = playlist in
      let newPlaylist = (songId::songs, state) in
      if List.contains((=), songId, get_songs(playlist)) then
        playlist
      else
        newPlaylist end
in


