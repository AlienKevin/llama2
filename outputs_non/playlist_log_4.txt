

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | Add


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | Remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can'


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x:


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x !=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | Pause


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrent


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlayS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x !=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id ==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([],


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected)
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected)
    end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected)
    end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected)
    end
in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | AddSong(song_id) =>
        let songs, state = playlist in
        if List.contains((==), song_id, songs) then playlist else (songs @ [song_id], state)
    | RemoveSong(song_id) =>
        let songs, state = playlist in
        # Can't remove a song not in the playlist #
        if List.contains((==), song_id, songs) then ([], NoSongSelected) else (List.filter(((x: Id) -> x != song_id), songs), state)
    | PauseCurrentSong => 
        let songs, state = playlist in
        case state
        | NoSongSelected => playlist
        | Playing(song_id) => (songs, PausedOn(song_id))
        | PausedOn(song_id) => (songs, PausedOn(song_id))
    | PlaySong(song_id) => 
        let songs, state = playlist in
        case state
        | NoSongSelected => if List.contains((==), song_id, songs) then ([], Playing(song_id)) else (List.filter((x -> x != song_id), songs), NoSongSelected)
        | PausedOn(_) => playlist
        # If the song is already playing, ignore the request to play #
        | Playing(playing_song_id) =>  if (playing_song_id == song_id) then playlist else ([], NoSongSelected)
    end
in


