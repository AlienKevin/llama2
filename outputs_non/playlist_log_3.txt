

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
   


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | Pause


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrent


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | P


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | Paused


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | Remove


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!=


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlayS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => 


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | Add


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs =


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song ->


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $==


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x),


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => play


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            |


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ =>


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::song


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs,


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, No


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoS


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSong


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
           


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end
       


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end
        end


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end
        end



================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end
        end
in


================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end
        end
in


