# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
    fun playlist, action ->
        case action
        | PauseCurrentSong => 
            case get_state(playlist) of
            | Playing(id) => (get_songs(playlist), PausedOn(id))
            | NoSongSelected => (get_songs(playlist), NoSongSelected)
            | PausedOn(_) => (get_songs(playlist), get_state(playlist))
            end
        | RemoveSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (List.filter((fun song -> song $!= x), songs), NoSongSelected)
            | _ => (songs, get_state(playlist))
            end
        | PlaySong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) =>  (songs, Playing(x))
            | _ => (songs, NoSongSelected)
            end
        | AddSong(id) =>
            let songs = get_songs(playlist) in
            match id with
            | x when List.contains((fun song -> song $== x), songs) => playlist
            | _ => (id::songs, NoSongSelected)
            end
        end
in