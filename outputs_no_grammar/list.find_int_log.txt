
================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =



================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
 


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->



================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
   


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go:


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int],


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int)


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) ->


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =



================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
     


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->



================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
       


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs



================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
       


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        |


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | []


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] =>


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc



================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
       


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        |


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | h


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl =>


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd)


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx +


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, t


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc)


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in



================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
   


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0, xs


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0, xs,


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0, xs, -


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0, xs, -1


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0, xs, -1)


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0, xs, -1) in


================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int], Int) -> Int =
      fun idx, xs, acc ->
        case xs
        | [] => acc
        | hd::tl => if p(hd) then idx else go(idx + 1, tl, acc) end in
    go(0, xs, -1) in


