
================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
       


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go:


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String])


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) ->


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
           


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
               


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
               


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                |


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Un


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable")


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x'


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' =


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x ==


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x'


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x))


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x),


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx))


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
               


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                |


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e')


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') =>


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(L


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
               


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                |


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) =>


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    |


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) =>


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    |


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(L


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e'))


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) =>


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e',


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                   


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    |


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ =>


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application")


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
       


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(e


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(e,


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(e, [


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(e, [])


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(e, [])



================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(e, [])
in


================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

type EvalResult =
  + Exp(Exp)
  + Error(String)
in

# Evaluation can result in either an Exp or an Error #
# Evaluation by substitution #
let Exp.eval: Exp -> Result =
    fun e ->
        let rec go: (Exp, [String]) -> Result =
            fun e, ctx ->
                case e 
                | Var(x) =>
                    if List.is_empty(ctx) then Error("Unbound variable") else
                    let x' = List.hd(ctx) in
                    if x == x' then Exp(Var(x)) else go(Var(x), List.tl(ctx)) end
                | Lam(x, e') => Exp(Lam(x, e'))
                | Ap(e1, e2) => 
                    case go(e1, ctx)
                    | Error(msg) => Error(msg)
                    | Exp(Lam(x, e')) => go(e', x::ctx)
                    | _ => Error("Non-function application") end in
        go(e, [])
in


