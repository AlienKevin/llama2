
================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((Int -> Bool), [Int]) -> Int)
  LSP: Convex: Target types: (((Int -> Bool), [Int]) -> Int)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:19.5277
 :19.2337
 fun:16.9156
  :14.8604
    :13.9601
                :12.7868
   :12.2511
     :12.251
        :11.8473
 ?:11.6973
 let:11.5733
 {:11.5683
      :11.4528
            :11.4032
 #:11.3462
	:11.1554
       :11.1045
fun:11.0668
         :10.9277
 //:10.8042
          :10.7736

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((Int -> Bool), [Int]) -> Int)
  LSP: Convex: Target types: (((Int -> Bool), [Int]) -> Int)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 :21.309
   :18.2473
fun:17.8903
 fun:15.7235
  :15.3759
	:14.4387
       :14.3731
     :14.1478
let:13.8139
    :13.2222
func:13.2221

:12.5411
 let:12.4945
           :11.5648
         :11.1811
      :11.0434
function:10.99
fn:10.6363
 func:10.4868
#:10.1886
                :10.1549

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
 

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((Int -> Bool), [Int]) -> Int)
  LSP: Convex: Target types: (((Int -> Bool), [Int]) -> Int)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:22.3315
 let:16.2957
 #:12.8641
 func:12.4969
 {:12.26
 //:11.8923
 rec:11.861
 (:11.738
 lambda:11.5937
 (*:11.3733
 match:11.2121
 find:10.9467
 fol:10.6795
 ##:10.5106
 ?:10.5087
 fn:10.4457
 fix:10.3476
 /*:10.3383
 f:10.2875
 if:10.1444
 loop:10.1357

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 p:17.471
 pred:16.4129
 f:16.3758
 fn:13.7631
 predicate:13.5707
 is:12.8815
 cond:12.6282
 test:12.4988
 xs:11.5446
 func:11.1319
 x:11.1002
 check:10.9908
 g:10.8092
 pr:10.8059
 condition:10.6954
 e:10.2723
 ok:10.2422
 eq:9.98434
 q:9.78257
 el:9.77296
 c:9.68748

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:18.1323
 xs:13.7636
 ,:13.7502
 x:12.3299
?,:11.6763
f:11.3073
::10.5244
xs:10.3195
x:9.93194
 l:9.77264
_:9.74625
 ->:9.69304
fx:9.35694
 in:9.16898
 f:9.09921
fun:9.00346
 as:8.84791
 ::8.6619
?:8.37897
 =:8.32827
 _,:8.24656

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p,

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 xs:18.9071
 l:17.0419
 x:13.1571
 list:12.9956
 ls:12.4513
 lst:12.4141
xs:11.5794
 s:11.361
 y:11.0733
 a:10.7619
 h:10.6619
 arr:10.6408
 i:10.4813
 e:10.3351
 t:10.222
 :10.0757
 items:10.0603
 n:9.97614
 v:9.97032
 xx:9.90194
 ele:9.80842

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.9422
,:15.5848
->:14.7724
 :13.3675

:11.9802
0:11.682
 =>:11.4152
 |:11.1109
 =:10.8699
 in:10.8215
::10.7536
 ,:10.6195
 ~:10.3169
  :10.1023
 -:10.0467
 -->:9.7813
 ::9.65008
 as:9.57773
 //:9.45951
;:9.26246
 {:9.25593

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:

:18.8537
 :16.8238
  :14.2514
 let:13.7807
    :13.4575
 fol:13.1203
   :12.8262
 find:12.8103
 go:12.4866
                :12.2185
     :12.1001
 -:12.0765
 match:11.8785
 #:11.8758
        :11.6714
 length:11.3599
      :11.2024
 ?:11.1936
 case:10.9174
 rev:10.9169
 fail:10.9081

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
   :21.1083
     :16.3828
 :16.3755
  :15.4011
    :14.9468
       :14.86
let:13.1779
case:13.1528
	:13.0764

:12.6377
         :12.6287
      :12.4596
           :11.838
match:11.8219
#:11.3537
if:11.3502
        :11.2345
 let:10.8453
          :10.3178
               :10.2938
                :10.2409

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
   

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 let:18.2411
 case:17.527
 fol:14.7924
 go:13.4464
 match:13.2166
 #:12.205
 if:11.9795
 length:11.8452
 rev:11.8187
 find:11.4484
 var:10.961
 (:10.6237
 rec:10.4483
 for:10.3251
 len:10.1681
 map:10.0964
 f:10.0785
 (-:9.98973
 //:9.95142
 @:9.82535
 s:9.78259

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 go:14.3937
 rec:12.8699
 f:12.2062
 idx:11.6081
 find:11.5047
 index:10.634
 aux:10.1926
 length:9.98227
 i:9.7722
 helper:9.74444
 n:9.6819
 pred:9.677
 search:9.56603
 is:9.5601
 len:9.46325
 g:9.27638
 r:9.10316
 res:9.01453
 step:8.98683
 id:8.96317
 l:8.9452

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
::17.1218
 =:13.5537
 ::13.3611
 i:11.6316
 x:11.3578
_:11.0585
 (:10.928
 f:10.7336
 n:10.3988
 xs:10.097
:(:10.0654
,:9.96333
 acc:9.93038
 idx:9.92219
(:9.6324
 l:9.58085
 p:9.3855
 find:9.13031
i:9.11564
1:9.08692
 func:8.97814

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go:

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go:
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >:<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: :
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: :
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ":"
new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
 (:18.8502
 ([:17.6803
 Int:15.7283
 ((:15.5058
 (?:14.0033
 [:13.8929
 (_:12.9075
 ?:12.4396
 :12.3603
([:11.8565
 [(:11.7412

:11.5236
 ():10.7702
 (!:10.6579
 int:10.6553
 (*:10.6173
 [[:10.4466
 (@:10.4461
 ({:10.4424
 {:10.3265
 _:10.2858

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
Int:18.4346
Bool:14.5788
([:13.996
List:12.6754
int:12.345
?,:11.8067
_,:11.6536
[[:11.4184
[:10.9406
((:10.8874
n:10.8177
N:10.7273
x:10.3013
 Int:10.048
[]:9.89744
Boolean:9.87066
p:9.85227
Id:9.82147
 [:9.65874
i:9.53988
&:9.51588

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Base type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:19.4153
,[:15.8717
 ->:14.981
):13.5891
 ,:12.8195
?,:12.3672
->:12.2076
 [:11.3815
 *:10.9231
[:10.5625
 [],:10.3357
*,:10.1512
 Int:10.089
[,:9.65719
 {:9.5634
,(:9.44782
*:9.37295
 x:9.32768
([:9.11033
)->:9.02593
 |:8.78925

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int,

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 [:18.3876
 Int:16.292
 ?:15.2758
 ([:13.3869
 [(:13.1504
 (:13.0991
 List:13.0247
 Bool:12.3672
 [],:12.1935
 [[:11.4083
 xs:10.827
 :10.7641
 {:10.6371
 _:10.4781
 _,:10.2112
 (?:10.1558
 Maybe:10.0944
 *:9.98139
 []:9.91512
 ((:9.59618
 ??:9.58367

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
Int:20.4142
?:15.6588
a:14.2432
Bool:12.884
int:12.7709
]):12.235
t:12.0611
?,:12.0167
x:11.6063
In:11.2128
Maybe:11.1681
 ?:11.0007
T:10.9563
??:10.8617
_,:10.6358
m:10.5792
I:10.5695
&:10.5535
p:10.5007
A:10.4511
b:10.4229

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Base type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "]"
root ::= completions | new-tokens

Top 20 Logits:
],:23.3951
]):23.3637
]:18.9175
]->:15.5482
]);:14.6664
,:14.2799
],[:14.2083
])):14.0437
),:13.9756
]),:13.8639
]).:13.5763
];:13.4593
](:12.7639
):12.5845
?:12.2852
|:12.0774
}):12.0407
 ],:12.0134
]::12.0098
)]:11.892
]]:11.8079

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int]

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int]
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= new-tokens

Top 20 Logits:
 ->:15.2328
 ):14.7001
 ,:13.2726
 Int:12.1372
 |:11.5149
 ?:11.2751
?):10.7904

:10.1017
?,:10.0147
 &:9.98687
 Bool:9.84577
 {:9.84027
 :9.8106
)::9.78479
 =:9.69775
 ~:9.66805
 [:9.52064
<:9.48435
 int:9.47893
 @:9.40102
|:9.3668

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] ->

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ->
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ->
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 Int:15.4555
 ?:15.3801
 Bool:12.5718
 [:12.3667
 Maybe:12.1097
 (:11.4371
 (?:10.3876
 Option:10.1916
 ):10.0798
):10.0268
 _):9.84551
 !:9.62852
 |:9.61749
 Either:9.61296
 ??:9.38537
 Opt:9.37911
 :9.19909
 int:9.01241
 ([:8.99273
?:8.94592
 None:8.91973

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
):18.3383
 =:15.0583
,:12.8527
 |:12.3866
 ):12.3613
 ->:11.7472
)=:11.6948
?):11.3984

:11.249
)->:11.1918
 ?:10.7788
=:10.4923
?:10.3268
)?:10.2264
 :9.98514
|:9.88923
),:9.75496
 ||:9.34313
)):9.32958
 ==:9.28539
->:9.18599

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int)

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= new-tokens

Top 20 Logits:
 =:17.1919
 ->:15.7433

:12.9012
 :12.0799
 <-:11.202
 =>:10.9321
 ==:9.88218
 ::9.65982
 |:9.6416
 in:9.63531
 fun:9.30955
 {:9.02205
 ~:8.87785
 Int:8.58775
  :8.54697
 (:8.48776
 -:7.98339
 :::7.9425
 []:7.93011
 x:7.92661
 f:7.87422

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:

:19.0065
 :16.9684
 fun:15.9536
  :13.8086
    :12.997
                :11.8038
 \:11.6403
 {:11.6267
 #:11.5769
 (:11.5391
     :11.3623
   :11.258
 //:11.2225
        :11.1969
      :11.1642
 ?:10.8587
            :10.8581
 match:10.8335
 fix:10.8036
       :10.5559
	:10.4328

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
     :20.3126
   :17.9339
       :17.8584
    :14.3619
      :13.9768
         :13.489
           :13.0344
	:12.9913
 :12.7909
        :11.99
  :11.7696
               :11.523
                :11.1746
             :11.0666

:10.9157
          :10.4628
            :9.96615
              :9.53234
(:8.50245
fun:8.43081
//:8.36938

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
     

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
     
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 fun:20.2935
 case:14.0123
 match:13.637
 let:13.618
 if:13.2598
 |:13.173
 #:13.0574
 (:12.7537
 func:12.3178
 {:12.1997
 //:11.8791
 (*:11.7615
 p:11.4993
 f:11.4975
 find:11.4038
 go:11.3327
 fol:11.2282
 lambda:11.2168
 @:11.1461
 rec:11.062
 fn:11.0013

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case ?
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case ?
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case ?
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case ?
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:15.8609
 p:12.5496
 l:10.9755
 y:10.9163
 h:10.8866
 x:10.8354

:10.7452
 t:10.712
 :10.6867
 go:10.1802
 (:10.1368
 n:10.1114
 i:10.0394
 _:9.69426
 [:9.4083
 list:9.37147
 []:9.35412
 f:9.14131
 ?:9.03179
 _,:8.90452
 fun:8.85301

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Int]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.9498
 :16.4085
,:16.0042
 |:14.522
  :13.6418
 in:13.3434
 of:12.7933
    :12.292
::12.1164
 =>:11.9753
 ->:11.7966
 #:11.5897
 {:11.5594
 =:11.4051
 with:11.2724
 as:11.2631
 match:11.0881
 <:11.0253
 //:10.952
 ||:10.9149
.:10.896

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Int]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.905
       :19.6288
      :16.787
   :16.2166
         :16.1193
    :15.5753
	:14.9505
        :14.7596
           :14.0922

:13.6137
          :13.1361
  :13.1098
 :12.9074
                :12.8471
             :12.5099
               :12.4315
#:12.3018
|:12.2498
            :12.0702
 |:11.0372
              :10.9267

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
     

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
     
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Int]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.5811
 #:13.6887
 ||:13.5427
 when:12.7051
 fun:12.3833
 if:12.0062
 p:11.3976
 case:11.3242
 match:10.7018
 in:10.5855
 func:10.4609
 let:10.4596
 ##:10.374
 []:10.237
 end:10.1987
 (*:10.1742
 h:10.1154
 _:9.96584
 <:9.93885
 x:9.92279
 @:9.89279

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      |

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 []:18.75
 x:16.796
 h:15.7312
 [],:15.5166
 _:14.0657
 y:12.966
 _,:12.317
 [:12.2537
[]:12.0636
 (:11.9601
 l:11.6517
 i:11.4445
 idx:11.2951
 xs:11.174
 :11.0861
 z:10.9577
 a:10.8219
 head:10.5142
 e:10.3617
 p:10.2249
 [_:10.177

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | []

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ":" | "::" | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.6531
 ->:12.9819
    :12.3089
=>:12.27
 ||:11.8275
 :11.809
 :=:11.7517
      :11.5946
  :11.5645
       :11.3546
 :::11.2494
 |:11.2415
         :11.2128
        :11.0079
:::11.0061
          :10.9009
   :10.8729
                :10.7056
           :10.6857
     :10.5455
 when:10.5007

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] =>

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 -:13.8677
 fun:13.4221
 _:13.4095
 :12.4735
 (-:12.2308
 None:12.0618
 \:11.9711
 (_:11.8083
 (:11.2702
 ~:11.2144
 n:10.7913
 Some:10.6523
 acc:10.633
 lambda:10.6058
 fn:10.5779
 id:10.2253
 x:9.96288
 func:9.85973
 i:9.85549
 fail:9.85383
 {:9.80732

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Negation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Arrow ((List Int), Int))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Integer Negation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Arrow ((List Int), Int))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: -
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: -
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
1:20.0288
 :15.7627
2:13.3501

:11.8764
0:11.8207
l:11.7668
3:10.6482
p:10.6063
!:10.605
  :10.5979
9:10.5671
i:10.2585
4:9.99331
_:9.94942
 l:9.8929
~:9.85112
 (:9.63174
5:9.56188
(-:9.45673
one:9.37272
():9.18641

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: 1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= completions | new-tokens

Top 20 Logits:

:17.8553
 :14.591
 end:13.324
  :13.2183
:::13.0877
 //:12.4929
 (*:12.42
 #:12.0977
    :11.9619
;:11.678
      :11.6768
 :::11.6764
                :11.5577
 |:11.5268
        :11.0449
   :11.0163
       :10.9848
 in:10.8217
 ->:10.7776
 --:10.625
#:10.5756

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.7383
   :15.1338
      :14.9923
       :14.8792
    :14.1949
	:13.8577

:13.6363
#:13.2575
         :12.7775
        :12.7581
  :12.6699
 :12.207
end:12.1785
|:11.9997
           :11.8328
          :11.5515
in:11.3922
                :11.3596
            :10.9215
  :10.483
(*:10.1774

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
     

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
     
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:19.9488
 end:13.2806
 #:13.1936
 p:12.9247
 if:12.7556
 when:12.5484
 fun:12.5202
 case:12.4986
 ||:12.286
 ...:11.4687
 in:11.4603
 //:11.3653
 else:11.1337
 (*:11.0718
 func:11.0572
 x:10.97
 (:10.9163
 h:10.7704
 elif:10.6409
 match:10.5413
 f:10.3674

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      |

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 h:19.1976
 x:18.4358
 y:15.2019
 _:14.5202
 [:12.8867
 head:12.5007
 l:12.4059
 z:12.301
 e:12.2852
 a:12.2684
 (:12.0326
hd:11.8186
 p:11.7626
 v:11.6426
 xs:11.632
 t:11.5446
 i:11.5311
 f:11.4374
 ?:11.1524
 idx:11.0724
 el:11.0549

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | h

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | h
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <h>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {h: [Int], xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| h => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| h => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| h => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| h => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: h
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: h
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
d:21.3607
:::17.3387
 :::13.0717
dx:12.9916
x:12.0706
dr:11.5777
s:10.9256
,:10.8896
@:10.348
::10.2815
ds:10.2352
t:9.99638
h:9.92313
1:9.91198
p:9.82598
ed:9.79725
_:9.69119
l:9.52584
dd:9.48203
g:9.46619
|:9.43044

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: [Int], xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
:::21.0811
 :::15.7076
,:12.8226
::12.3943
@:11.762
 +:11.354
 &:11.1293
|:10.9974
 =>:10.7423
_:10.672
 ->:10.1385
1:10.0699
 ::10.0367

:10.0224
=>:9.74055
 |:9.71703
 as:9.62801
 @:9.48514
':9.45673
 =:9.32241
[:9.22526

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
tl:18.7784
_:16.2129
xs:15.0299
[]:13.1277
tail:12.5888
 t:11.8849
 _:10.981
ts:10.9347
rest:10.6405
t:10.1536
hd:10.0683
idx:9.8929
[_:9.82878
td:9.75567
(_:9.70445
xl:9.69117
x:9.59646
ys:9.35602
(:9.2873
tt:9.24686
hs:9.19718

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Int]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: tl
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
 =>:18.095
 when:16.054
 ->:15.4907
 if:13.5272
,:13.1375
 :12.6093

:12.6002
=>:11.9981
 :::11.6427
 as:11.4636
 =:11.0904
->:10.7104
 &&:10.6231
 |:10.5844
 :=:10.4853
 where:10.3683
 ||:10.1312
::10.0918
 ::9.98901
 ==:9.74041
 ==>:9.67012

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl =>

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 if:16.5031

:15.5312
 p:15.3489
 :15.224
 go:14.2097
 (:13.1803
 case:12.6929
 match:12.6597
 h:12.2839
 let:12.0178
  :11.9712
 find:11.8793
 ?:11.5507
 fun:11.4749
 fol:11.0573
 {:10.8782
 _:10.5801
 t:10.5327
 i:10.5324
 If:10.4864
 f:10.4746

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "hd" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 p:17.9803
 (:14.1513
(:13.803
 h:13.5991
 !:12.2591
 true:11.8644
 is:11.6501
 :11.5301
 go:11.3919
 x:11.2972
 not:11.2768
 @:11.2187
 f:11.144
 t:11.0979
p:11.0209
_:10.9067
 ?:10.6281
 pred:10.3928
 Some:10.3784
 xs:10.3622
 True:10.1637

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Int -> Bool)
  LSP: Info: Error Status: (Exp
   (Common (Inconsistent Expectation {ana = Bool; syn = (Arrow (Int, Bool))})))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  p
Nature of error: Expecting type Bool but got inconsistent type (Int -> Bool)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new-tokens ::= whitespace | "(" | "then"
root ::= completions | new-tokens

Top 20 Logits:
(:20.8434
 h:15.6552
 (:13.7019
 ==:12.8716
 x:12.6164
.:12.0093
.(:11.8425
():11.5332
,:11.4201
?(:11.3291
 then:11.211
[:11.1225
 =:11.0633
 t:11.0123
((:10.6623
!(:10.2966
=:10.2255
([:10.2174
 is:10.1096
::10.095
(@:10.0673

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor hd if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
hd:21.8769
x:15.9291
h:13.9644
head:13.6956
xs:13.6901
hs:12.7174
i:12.6928
0:12.2511
p:12.1294
acc:11.8642
idx:11.8253
a:11.7785
hl:11.699
f:11.6908
n:11.2638
 h:11.1055
td:11.0601
t:10.9461
fd:10.9254
elem:10.9207
val:10.8676

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: hd
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
):20.2524
),:15.2643
);:13.5862
)=:13.3227
)::13.1243
){:12.4894
,:12.3873
)?:12.1858
 ):11.9774
 =:11.7341
).:11.3033
 ==:11.2184
)->:11.0869
=:10.8734
 then:10.8309
 +:10.7751
.:10.4232
)):10.3796
)(:10.1663
)>:10.1304
 as:10.0557

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd)

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:17.3518
 :14.2863
 ==:14.1959

:13.8816
 =:12.7075
 go:12.3854
 {:12.1317
 t:11.8382
 >=:11.7442
 h:11.6775
 &&:11.5576
 >:11.3934
 ||:11.1968
 !=:11.1514
 p:11.1378
 ?:11.0773
 true:10.8226
 -:10.6626
 is:10.5658
 =>:10.3567
 i:10.349

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 :15.1148
 i:12.7426
 h:12.6127
 go:12.5288
 t:12.2202
 index:11.8854
 idx:11.424
 acc:11.2222
 length:10.887
 x:10.8337
 Some:10.2603
 -:10.2357
 id:10.0843
 return:10.0625
 f:10.006
 (:9.94045
 ?:9.81757
 n:9.81644

:9.62362
 len:9.56553
 _:9.55867

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
0:23.8891
1:17.8543

:16.4819
2:14.3393
 else:13.7525
 go:13.6162
 h:13.4915
9:13.0286
3:12.9159
 t:12.8856
 i:12.4785
4:12.324
 return:12.0977
 p:12.0751
5:11.9088
 length:11.6419
 index:11.471
8:11.4102
 then:11.2575
 len:11.2112
7:11.1997

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Arrow ((List Int), Int))]);
           syn = Int})))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer literal
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 0
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "else"
root ::= completions | new-tokens

Top 20 Logits:
 else:18.1017

:13.4254
 :12.693
 elif:12.2896
 end:10.9263
 +:10.9102
 @:10.475
;:9.90182
 els:9.72133
  :9.69464
 in:9.33663
 el:9.27341
,:9.25276
 :::9.17792
 otherwise:9.0701
 ||:9.03071
    :9.02466
 \:8.97387
 |:8.86816
 ?:8.73215
 Else:8.6968

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 :15.8234
 go:15.165
 find:12.7161
 (:12.6959
 succ:12.5579
 let:12.1607

:11.765
 inc:11.0156
 h:10.8058
 i:10.8049
  :10.7333
 t:10.3755
 (+:10.3629
 -:10.3142
 f:10.193
 n:10.1387
 if:10.0977
 p:10.0972
 ((:9.93685
 add:9.81215
 rec:9.72296

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
1:21.0508

:16.0549
0:15.0012
 go:14.4486
2:14.3616
 find:12.4712
 (:11.9821
9:11.8603
3:11.7971
 +:11.4939
ival:11.4792
4:11.2603
6:11.1419
5:10.9976
xt:10.7623
nd:10.6095
 @:10.5702
 search:10.4536
8:10.3462
 index:10.2382
 ++:10.2219

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Arrow ((List Int), Int))]);
           syn = Int})))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: 1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "*" | "**" | "+" | "-" | "/" | "end" | "|"
root ::= completions | new-tokens

Top 20 Logits:
 +:20.6178
+:15.6175
 in:12.8837
 end:12.4298
+(:12.3563
 -:10.9217
 :10.5953
 plus:10.5007

:10.4984
 +=:10.472
:::10.2473
(:10.2411
 @:10.2406
 *:9.9354
 go:9.87909
 =:9.61818
 ++:9.61682
 :::9.51431
 else:9.4947
 more:9.4465
.:9.29347

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 +

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 +
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >+<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Addition
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Arrow ((List Int), Int))]);
           syn = Int})))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Integer Addition
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Arrow ((List Int), Int))]);
           syn = Int})))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: +
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: +
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
Int <= (Int, ([Int] -> Int))
  LSP: Convex: Target types: Int, (Int, ([Int] -> Int))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 go:17.6111
 find:16.8316
 (:13.7544
 t:12.679
 n:12.0619
 f:11.511
 length:11.2012
 g:11.0657
 x:11.0206
 index:10.9642
 :10.8536
 h:10.6423
 fol:10.4349
 next:10.3912
 result:10.379
go:10.1616
 res:9.99842
 i:9.93072
 @:9.74812
 rec:9.73016
 r:9.67577

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int;
           syn = (Arrow ((Prod [(Arrow (Int, Bool)); (List Int)]), Int))})))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  find
Nature of error: Expecting type Int but got inconsistent type (((Int -> Bool), [Int]) -> Int)  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: find
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((Int -> Bool), [Int]) -> Int)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:16.9307
_:14.9667
():12.6269
 end:12.0528
 p:11.4725
((:11.3087
 (:11.1932
i:10.6876
p:10.6037
.:10.4552
 in:10.3693
(@:10.3566
(?:10.1591
(&:10.1366
2:10.069
Index:9.88294
 t:9.83872
(_:9.70415

:9.63939
_(:9.57039
.(:9.56302

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(?)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(?)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(?)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
  LSP: Convex: Target types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  p type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: hd min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "p" | "type "
root ::= new-tokens

Top 20 Logits:
p:18.5189
xs:14.2869
hd:13.4466
tl:13.444
x:12.255
f:12.2378
go:12.0733
td:11.4763
hs:10.9818
t:10.8545
pred:10.8533
hl:10.5758
h:10.284
fun:10.0293
1:9.80846
tail:9.69436
ht:9.13844
lambda:9.02683
ps:8.94446
 p:8.81991
fn:8.72532

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: (Int -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Arrow (Int, Bool)); (List Int)]);
           syn = (Arrow (Int, Bool))})))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  p
Nature of error: Expecting type ((Int -> Bool), [Int]) but got inconsistent type (Int -> Bool)  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Arrow (Int, Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Arrow (Int, Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
  LSP: Convex: Target types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  p type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:19.0154
)(:13.6521
 t:13.6331
 ,:13.4055
):13.0763
(:12.1312
),:11.9357
::11.5498
.:11.3977
(),:10.8194
 x:10.7984
,(:10.4161
 in:10.2891
:::10.1502
@:10.117
 xs:9.92316
,[:9.84086
)):9.7917
 ->:9.7796
[:9.67374
 >:9.62162

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p,

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, ?)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, ?)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, ?)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length tl type  xs ~INTLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
  LSP: Convex: Target types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  p type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "[" | "[]" | "abs" | "case " | "find" | "hd" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "tl" | "type " | "xs" | intlit
root ::= new-tokens

Top 20 Logits:
 t:19.6268
 xs:14.582
 h:12.8267
 x:12.7542
 tail:12.4029
tl:12.0731
xs:11.9815
 l:11.5915
 go:11.4995
 f:11.082
 acc:10.8146
 [:10.6692
 ts:10.6011
 :10.5033
 y:10.1798
t:10.0597
 list:9.89822
 rest:9.89478
 rev:9.80115
 (:9.49613
 s:9.35762

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, t

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, t
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "t"))
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, t)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  t
Nature of error: Variable t is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, t)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, t)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, t)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, t)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: t
LSP: Generating Completions for prefix: t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length tl type  xs ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "l" | "ype "
root ::= completions

Top 20 Logits:
l:22.1123
ls:11.5044
L:11.4362
):10.4344
b:10.2505
ld:10.0918
1:9.93887
sl:9.79039
t:9.58489
n:9.1331
la:8.85574
g:8.85472
s:8.64365
dl:8.63068
le:8.47013
[:8.37221
p:8.25151
c:8.19105
)):8.12334
li:8.12076
z:8.0159

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Int]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] abs case  find hd if  int_of_float int_of_string let  max_int min_int mod string_compare string_length tl type  xs ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
):18.7525
)):14.7158
);:13.8261
 end:13.549
),:12.7442
)]:12.6851
,:12.3432
 ):12.1192
).:11.9716
)::11.8296
)(:11.2346
));:10.7793
)`:10.7447
)[:10.6415
))):10.6209
)))):10.5182
)}:10.3029
()):10.1908
)),:10.0089
)":9.87186
)':9.82922

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl)

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [Int], hd: Int, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "-" | "/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:17.2693

:13.7827
 in:12.682
 :11.4024
 else:9.61835
end:9.60563
 ::9.16454
  :9.08791
 and:8.62747
 done:8.26748
 ->:8.1067
 |:8.07609
 ?:7.9914
 return:7.94882
 -:7.84502
 #:7.79583
 as:7.71962
    :7.58026
 f:7.56815
 ):7.56735
 with:7.49565

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: (Int, ([Int] -> Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int, ([Int] -> Int))
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, ([Int] -> Int))
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Prod [Int; (Arrow ((List Int), Int))])
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "in" | "|"
root ::= new-tokens

Top 20 Logits:
 in:18.0763

:15.4064
 :13.2622
 end:12.8623
;:11.8053
  :10.8391
 fun:10.5717
):10.0125
 and:9.82339
 x:9.71546
in:9.66504
.:9.44098
    :9.23652
 >:9.11829
,:9.10418
 if:9.09425
 #:9.07273
 &&:8.8515
 then:8.80568
   :8.79324
():8.77862

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:

:18.9237
 :15.4798
 go:14.4714
  :14.2377
    :13.5787
      :12.2749
        :11.699
   :11.6134
     :10.7717
                :10.7051
       :10.6725
            :10.5556
          :10.5499
	:10.0962
 //:10.0146
         :9.9296
 in:9.88492
 #:9.66424
 fun:9.49152
 (:9.29302
 g:9.1257

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
   :17.9523
go:16.125
     :15.8241
 :15.7363
       :15.4006
in:14.925
    :14.5454
  :14.2732

:14.1444
      :13.2531
         :12.7264
let:12.4789
        :12.3656
end:12.2504
           :11.9151
                :11.2912
	:11.2851
#:10.8752
fun:10.7148
 go:10.6444
          :10.5526

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
   

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 go:18.5229
 case:13.2965
 if:12.9109
 let:12.4537
 in:12.4291
 find:12.0102
 #:11.9833
 fol:11.8776
 match:11.5387
 fun:11.4807
 (:11.3946
 h:11.0071
 end:10.9641
 g:10.7144
 return:10.7143
 f:10.6467
 acc:10.629
 Some:10.5274
 -:10.5228
 p:10.2993
 n:10.2151

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case ?
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case ?
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case ?
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case ?
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 go:15.0104
 xs:14.7901
 h:12.318
 t:12.2615
 p:11.7612
 find:11.5485
 x:10.9218
 (:10.46
 acc:10.4175

:10.3228
 :10.3206
 is:10.3127
 in:10.1502
 y:10.0454
 list:9.70083
 length:9.61578
 fol:9.55948
 n:9.21124
 f:9.02717
 g:8.99119
 int:8.95769

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int, ([Int] -> Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int, ([Int] -> Int))
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: go
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position S Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor fun  go if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:15.755
(:15.7447
 of:14.0199
,:13.6694
 :13.4936
 in:13.4416
 xs:13.2056
 end:12.7964
 <:12.7207
():12.4568
 (:11.7879
 with:11.6488
(-:11.4083
 ==:11.2317
 =:11.2233
.:11.2125
 >:11.0023
  :10.9456
;:10.703
 -:10.655
 <=:10.583

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int, ([Int] -> Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int, ([Int] -> Int))
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.4977
end:15.088
     :14.8237
in:14.5496
    :14.3486
       :13.7824

:13.6084
let:13.5685
 :13.2448
#:12.9927
  :12.835
|:12.1631
      :12.1619
        :11.4963
	:11.3653
         :11.2024
```:10.2859
           :10.1223
                :10.0666
else:9.89505
             :9.57471

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
   

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int, ([Int] -> Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int, ([Int] -> Int))
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:18.5735
 #:14.0831
 end:12.2482
 go:12.2254
 in:11.8534
 when:11.5264
 match:11.234
 case:11.1592
 xs:11.0222
 -:11.0147
 fun:10.9866
 return:10.9345
 true:10.8731
 of:10.7721
 ||:10.4686
 h:10.4176
 p:10.4163
 _:10.3439
 if:10.2734
 []:10.0767
 x:10.0561

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    |

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | ? => ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | ? => ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | ? => ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | ? => ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 idx:15.079
 -:14.9103
 i:13.8351
 x:13.6579
 n:13.6018
 :12.3643
 index:11.912
 _:11.8461
 acc:11.7935
 h:11.6253
 go:11.2767
 v:11.1908
 (-:11.1301
 None:10.9593
 g:10.6062
 l:10.249
 res:10.2221
 k:10.1949
 len:10.1737
 f:10.1407
 found:10.1211

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
LSP: commas: p_ana is prod: Int (Arrow ((List Int), Int))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "=>"
root ::= completions | new-tokens

Top 20 Logits:
 =>:14.7096
 when:14.2688
,:13.529
 if:12.6427
 >=:12.4751
 <:11.6706
 ==:11.6284
 ->:11.6067
 !=:10.863
 as:10.5744
 >:10.5591
:::10.2364
 :::10.0911
 ~:9.80311
 <=:9.78784
::9.75263
_:9.63862
 =:9.61515
 where:9.56353
 :=:9.5629
 ::9.44322

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx =>

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 idx:16.4311
 if:13.7532
 go:11.8972
 Some:11.6449
 :11.4724

:11.3533
 xs:10.8448
 index:10.8337
 fun:10.6846
 fol:10.5314
 acc:10.4724
 (:10.4206
 find:10.3811
 f:10.3091
 h:10.1941
 p:10.128
idx:10.0789
 assert:9.96255
 x:9.84255
 func:9.77522
 int:9.6973

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if ? then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if ? then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if ? then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if ? then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 idx:16.2892
 p:14.7599
 is:12.9152
 xs:12.4283
 (:12.1887
 :11.7717
 go:11.5041
 index:11.3683
 t:11.3419
 not:11.3028
 h:11.1979
 x:10.691
 -:10.486
 !:10.0849
(:9.58822
 eq:9.53743
 find:9.5214
idx:9.38404
 ~:9.32702
 n:9.3085
 g:9.21251

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Int -> Bool)
  LSP: Info: Error Status: (Exp
   (Common (Inconsistent Expectation {ana = Bool; syn = (Arrow (Int, Bool))})))
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  p
Nature of error: Expecting type Bool but got inconsistent type (Int -> Bool)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new-tokens ::= whitespace | "(" | "then"
root ::= completions | new-tokens

Top 20 Logits:
(:17.6406
((:12.5732
 xs:11.8699
 (:11.844
 ==:11.7272
(@:11.7249
[:11.7244
([:11.7166
():11.2175
(*:10.9742
 x:10.8506
 =:10.7968
 then:10.4399
(_:10.4137
(?:10.2703
(!:10.1951
 idx:10.1566
 h:10.0582
(&:10.0472
.(:10.0352
 @:10.0193

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity p pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
xs:16.727
nth:16.5956
idx:15.3452
hd:14.6235
x:12.2654
get:11.9884
index:11.5362
go:11.385
n:11.2851
elem:11.1277
lst:11.0965
List:10.9797
list:10.7133
rev:10.6505
hs:10.5236
lookup:10.4903
find:10.2018
tl:10.1667
s:10.0083
nx:9.98971
ns:9.85332

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int;
           syn = (Arrow ((Prod [(Arrow (Int, Bool)); (List Int)]), Int))})))
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  find
Nature of error: Expecting type Int but got inconsistent type (((Int -> Bool), [Int]) -> Int)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: find
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((Int -> Bool), [Int]) -> Int)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:15.7773
_:14.2464
):12.4506
[:11.9238
()):10.7099
 xs:9.88916
.:9.74073
!(:9.73521
Index:9.54291
At:9.19159
((:9.10902
List:8.91067
,:8.90363
([:8.88466
i:8.8495
er:8.83587
(!:8.80582
(...:8.60209
s:8.55163
 x:8.55076
 n:8.45247

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
  LSP: Convex: Target types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  p type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "p" | "type "
root ::= new-tokens

Top 20 Logits:
xs:18.1424
idx:16.5531
p:15.456
hd:12.9394
x:12.6007
i:11.8363
go:11.7368
list:11.6947
hs:11.6719
index:11.355
f:11.3471
lst:11.2725
pred:11.0976
n:10.9514
0:10.9433
lambda:10.6214
tl:10.6193
ys:10.4751
ls:10.2909
t:10.1132
id:10.0318

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: (Int -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Arrow (Int, Bool)); (List Int)]);
           syn = (Arrow (Int, Bool))})))
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  p
Nature of error: Expecting type ((Int -> Bool), [Int]) but got inconsistent type (Int -> Bool)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Int -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Arrow (Int, Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Arrow (Int, Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
  LSP: Convex: Target types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  p type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:17.6523
)):15.5574
),:13.1683
)(:12.7634
 xs:11.3664
 ,:11.286
):11.0751
(:10.9408
::10.8476
)[:10.804
.:10.7792
)),:10.261
[:9.73203
 x:9.44134
 -:8.96385
).:8.92334
 in:8.91977
:::8.90215
 =>:8.8984
,(:8.83176
 +:8.6164

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p,

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, ?)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  xs ~INTLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
(Int -> Bool) <= ((Int -> Bool), [Int])
  LSP: Convex: Target types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  p type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "[" | "[]" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | "xs" | intlit
root ::= new-tokens

Top 20 Logits:
 xs:15.5113
 t:14.4157
 idx:12.4932
 h:12.4439
xs:12.3773
 x:11.9361
 l:10.9487
 go:10.6844
 n:10.3852
 tail:10.3178
 acc:10.1274
 list:10.0123
 [:9.87643
 ts:9.86495
 (:9.73678
 f:9.58279
 index:9.33719
 head:9.30031
 i:9.12898
 find:9.09033
 s:9.05002

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Int]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (Int -> Bool), ((Int -> Bool), [Int])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow (Int, Bool)) (List Int)
LSP: commas: self syn is (Prod [(Arrow (Int, Bool)); (List Int)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Int]
Int <= [Int]
Int <= [Int]
  LSP: Convex: Target types: Int, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( - [ [] abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  xs ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
)):18.5091
,:14.0402
),:14.0086
[:13.594
)[:13.4296
):13.0212
)),:12.855
))):11.9143
)(:11.5822
).:10.937
));:10.7192
 @:10.4755
);:10.2135
)){:10.1498
)::10.0313
))::9.93557
.:9.64645
[@:9.57166
 -:9.43932
)).:9.43725
 =:9.35463

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
 ==:14.1766
 then:13.1853
 !=:13.1535
 >=:12.9353
 =:12.7927
 <:12.7551

:12.1851
 >:11.6035
 &&:11.1886
 :11.1031
 return:11.0795
 idx:11.0407
 in:10.9748
 ||:10.6517
 @:10.6027
 :::10.5123
 ):10.3769
 !:10.3754
 <>:10.1972
:::10.18
 h:10.08

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
   :15.8985
       :15.5333
             :15.1795
               :15.177
     :14.8749
                :14.6318
in:14.5022
              :14.2583
           :14.1926
         :13.7183

:13.7155
let:13.5054
            :13.3363
      :13.0803
    :12.7244
end:12.571
        :12.5033
then:12.444
          :12.3782
 :12.265
else:12.0786

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
   

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs)) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
 |:16.9784
 then:13.9652
 #:13.3819
 else:13.3277
 in:13.0155
 return:11.8046
 end:11.5641
 let:11.2525
 idx:11.0163
 go:10.7387
 ||:10.4367
 -:10.3205
 if:10.1497
 true:10.1222
 _:10.0406
 elif:9.92929
 ?:9.88257
 ,:9.74357
 otherwise:9.57802
 ]:9.41835
 fun:9.35041

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
    -

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
    -
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - ?) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: -
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: -
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "find" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
1:12.0537
 :11.0756
----------------:10.2302
 idx:9.8958
idx:9.36474
#:9.11592

:8.7468
 find:8.60913
|:8.41674
 (:8.24529
 end:8.06516
 go:7.86764
 acc:7.79036
<:7.63755
 #:7.54099
 return:7.53196
  :7.45823
 else:7.45181
 -:7.34444
 <:7.30759
------------:7.23345

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
    -1

Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
    -1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  find if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= completions | new-tokens

Top 20 Logits:
 ->:13.9532

:13.8272
 =>:13.6943
 end:13.1925
 in:12.9603
 else:12.1171
 :11.7594
;:11.1596
 #:10.9463
 |:10.6314
 otherwise:10.2876
 if:10.1708
 ||:10.0914
  :10.0541
 then:9.91902
):9.86549
 +:9.85908
 =:9.76003
 &&:9.75714
 ::9.74435
::9.69584

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
    -1


Debug: true, Constrain: Types
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      case xs
      | [] => -1
      | hd::tl => if p(hd) then 0 else 1 + find(p, tl) end in
    case go
    | idx => if p(find(p, xs)
    -1

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, ([Int] -> Int)), go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = case xs
 | [] => -1
| hd :: tl => if p(hd) then 0 else 1 + find(p, tl)
end in
 case go
 | idx => if p(find(p, xs) - 1) then ? else ?
end in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + find(p, tl)
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  0
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int  
Error in term:
  not
Nature of error: Variable not is not bound  
Error in term:
  -1
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
in:17.0164
end:14.9347

:14.5331
   :14.1821
    :13.3933
#:12.6356
let:12.4953
 :12.2959
  :12.1139
else:11.9211
       :11.4778
|:11.2765
        :11.262
      :10.843
```:10.7476
}:10.7242
     :10.6694
;:10.4523
and:10.251
                :10.2142
};:10.1147
