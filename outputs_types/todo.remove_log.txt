
================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:17.2958
 :16.7978
 fun:15.82
  :12.4564
 (:11.5498
fun:11.2359
    :11.1389
   :11.033
 let:10.8829
 ?:10.7711
 function:10.7177
 n:10.585
 cons:10.389
                :10.1189
 {:10.0723
 <:9.85568
 #:9.71568
     :9.4948
 in:9.40144
 \:9.32507
 ...:9.16073

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 :19.3783
   :17.6327
fun:16.3711
let:14.0854
 fun:13.8401
  :13.5168
	:12.7298
       :12.473
     :12.2269
func:12.0409
 let:11.8896
    :11.2739
(:11.0104
fn:10.7532

:10.6388
case:10.2227
           :10.2108
in:10.202
#:10.1786
lambda:10.1545
{:10.1522

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:19.7655
 let:15.0176
 (:11.6531
 #:11.6216
 fol:11.2065
 match:10.9809
 func:10.8807
 cons:10.8494
 f:10.8084
 if:10.7047
 {:10.6247
 n:10.5137
 lambda:10.494
 fn:10.2107
 remove:10.1118
 ~:10.109
 \:10.0857
 mut:10.0689
 case:10.0444
 ?:10.0134
 function:9.9734

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 idx:18.2197
 i:16.8632
 n:16.4055
 index:14.7988
 id:13.9565
 x:13.7765
 at:13.5223
 pos:13.0193
 ind:12.7906
 k:12.6801
 p:11.9021
 (:11.7425
 t:11.499
 key:11.1393
 todo:11.1053
 target:10.9193
 j:10.7623
 :10.7133
 num:10.6239
 to:10.6219
 _:10.1513

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: (Int, [Todo]), remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (List (Var "Todo"))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
LSP: commas: p_ana is prod: Int (List (Var "Todo"))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:17.3076
 xs:13.8168
 ->:13.181
 l:12.4385
 ,:11.9084
 t:11.6815
 ts:11.533
_:10.4236
::10.3552
 todos:10.3017
 list:10.006
 to:10.0036
 x:9.96991
 acc:9.82815
1:9.81801
 todo:9.6695
 ls:9.59055
 lst:9.57635
0:9.29999
To:9.27955
 =>:9.25116

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: Int (List (Var "Todo"))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 xs:16.215
 todos:15.129
 ts:14.5485
 l:14.0316
 t:12.671
 items:12.6611
 list:12.4269
 todo:12.3925
 lst:11.6503
 ls:11.4537
 x:11.4383
 model:11.3778
 acc:11.1913
 to:10.7161
 tod:10.5402
 state:10.0939
 (:9.86466
 ds:9.75573
 _:9.66974
 Tod:9.60094
 td:9.50662

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (List (Var "Todo"))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
LSP: commas: p_ana is prod: Int (List (Var "Todo"))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.0929
->:14.6212
,:13.7851
 =>:12.6261
 :12.4122
0:12.1797
 =:11.9625

:11.6852
 $:11.1063
$:10.977
 in:10.8342
::10.7566
_:10.6671
 -:10.4707
':10.3281
=:10.2576
 |:9.60766
1:9.58757
 ,:9.5555
 ~:9.37158
  :9.29767

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] case  if  let  remove type  xs
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "case " | "if " | "let " | "remove" | "type " | "xs"
root ::= new-tokens

Top 20 Logits:

:16.506
 :14.4131
 rev:13.7353
 List:13.3711
 xs:12.3486
 cons:12.2577
 fol:12.1743
 go:12.0485
 let:12.0341
 take:12.03
 t:11.8383
 n:11.4927
  :11.4527
 [:11.3275
 list:11.1279
 {:11.0796
 (:11.0783
 case:10.9577
 conc:10.7338
 h:10.4236
    :10.3287

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] case  if  let  remove type  xs
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "case " | "if " | "let " | "remove" | "type " | "xs"
root ::= new-tokens

Top 20 Logits:
   :16.4666
List:12.9105
fold:12.5943
case:12.581
 :12.5565
let:12.3664
xs:11.9119
     :11.3555
rev:11.275
if:11.1537
       :10.8967
    :10.8477
cons:10.6789
  :10.6314
hd:10.0096
go:9.97976
list:9.76252
match:9.70222
remove:9.65161
#:9.53577
idx:9.42055

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
   

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] case  if  let  remove type  xs
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "case " | "if " | "let " | "remove" | "type " | "xs"
root ::= new-tokens

Top 20 Logits:
 let:15.695
 case:15.3163
 List:13.6598
 fol:13.6318
 if:13.3806
 rev:13.2475
 go:11.9379
 match:11.6457
 xs:11.5001
 #:11.4404
 t:11.3916
 n:11.3695
 cons:11.1344
 assert:10.5571
 h:10.5515
 (:10.5154
 take:10.358
 length:10.2518
 list:10.1843
 reverse:9.81954
 idx:9.5773

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 go:13.6596
 rec:12.4034
 len:11.8849
 h:11.8126
 f:11.5968
 l:11.3037
 left:10.9248
 before:10.8016
 (:10.7863
 n:10.6358
 acc:10.5705
 rev:10.4936
 length:10.4193
 head:10.4118
 y:10.1369
 aux:10.0143
 front:9.75657
 first:9.63726
 remove:9.56085
 t:9.54781
 rem:9.47973

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
::16.424
 ::12.6058
 =:12.5368
 acc:12.1471
_:12.0173
:(:11.9379
 i:11.1629
 (:10.7094
 _:10.5425
 f:9.93656
 xs:9.93633
,:9.93546
(:9.86145
 n:9.70814
1:9.59456
 x:9.53691
 idx:9.46636
:::9.37187
 prev:9.19867
 (_:9.03481
 l:8.95161

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go:

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go:
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >:<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: :
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: :
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ":"
new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StyleAttr" | "Todo" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
 (:18.7792
 ([:17.6199
 Int:15.5907
 ((:14.663
 (?:13.6121
([:13.3485
 [:13.0649
 (_:12.8181
 :12.5736

:12.0616
 ?:11.9569
 ($:11.5128
 ():11.1525
 List:11.0335
 int:10.8914
 ({:10.7043
 [[:10.5656
 (@:10.4455
 (*:10.4202
 [(:10.4015
 {:10.3342

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StyleAttr" | "Todo" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
Int:18.9845
List:14.8813
Bool:14.7037
([:13.7494
_,:13.4018
T:13.2965
[[:12.9353
?,:12.8796
int:12.5405
 Int:11.9949
t:11.3027
n:10.8916
N:10.6555
String:10.6444
i:10.6165
Model:10.5103
Index:10.4896
x:10.3753
((:10.3546
(),:10.3052
list:10.2698

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Base type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:19.0249
,[:15.8697
 ,:12.9119
 ->:12.5442
):11.5347
?,:11.1527
 [:10.8216
 x:10.6199
 *:10.3317
->:10.0525
 [],:10.0067
,(:10.0008
[:9.63903
 [[:9.38241
*,:9.26919
[,:9.1495
,$:9.14783
 list:9.12031
([:8.78212
 {:8.72813
 =>:8.71138

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StyleAttr" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 Int:17.118
 [:17.0446
 ?:13.9731
 Tod:13.4549
 Bool:13.2308
 ([:13.1631
 List:13.1352
 [[:12.7116
 [],:12.1638
 (:12.0435
 [(:11.6122
 Acc:11.045
 _,:10.3307
 {:10.25
 :10.1768
 String:10.0889
 _:10.057
 Maybe:10.0398
Int:9.42676
 Boolean:9.29186
 int:9.25352

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:18.8966
,[:15.1648
):15.0277
 ->:13.9662
 ,:13.166
?,:11.6939
 [],:11.6493
 [:11.6097
 list:11.0574
)->:10.9871
->:10.7584
[:10.6098
 *:10.1729
 List:10.0662
 [[:10.0473
*,:9.47068
 option:9.42828
List:9.38352
[,:9.29618
 =>:9.0836
 ):9.06435

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StyleAttr" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 [:18.1181
 Int:14.332
 ?:14.1895
 Tod:13.8686
 [[:13.8126
 ([:13.0671
 List:13.0567
 Bool:12.7904
 [(:12.0442
 :11.6077
 (:11.3005
 Acc:11.1417
 [],:11.1315
 _:11.0169
 String:10.8328
 Maybe:10.6048
 {:10.6023
 Model:10.1282
 x:9.98967
 _,:9.86124
 *:9.82742

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StyleAttr" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
T:19.5859
Int:15.4082
a:14.8967
?:14.2618
List:11.8492
x:11.7073
Maybe:11.6795
]):11.6464
t:11.2184
int:11.1695
Bool:10.9956
xs:10.7602
String:10.6325
A:10.5361
b:10.1222
[]:9.88749
<:9.8687
TO:9.86755
 Tod:9.82421
$:9.78849
([:9.68579

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [T

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [T
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <T>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "T"))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  T
Nature of error: Type variable T is not bound
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: T
LSP: Generating Completions for prefix: T
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo" | extend-constructor
root ::= completions

Top 20 Logits:
odo:24.2171
odos:13.434
od:13.3864
d:12.3918
odd:11.3032
udo:11.0327
],:10.9125
ogo:10.4398
 todo:10.236
]):10.1506
do:10.1063
oto:9.79839
]:9.74701
omo:9.63686
_:8.79377
1:8.69575
,:8.59277
-:8.39114
ado:8.24045
K:8.05759
dd:8.01844

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-concave or complete: Todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Todo
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "]"
root ::= completions | new-tokens

Top 20 Logits:
],:21.3815
]):20.1142
]:15.9511
]->:13.5519
],[:13.2399
,:12.2968
_:11.8758
]);:11.8452
]),:11.7005
1:11.4835
 ->:11.4677
]).:11.3254
),:11.057
->:10.9256
 ],:10.8043
]*:10.5548
*:10.4519
])):10.4228
2:10.3298
?:10.2764
.:10.0031

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo]

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo]
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= new-tokens

Top 20 Logits:
 ->:14.8866
 ):14.5441
 ,:13.4523
 @:12.1094
 |:11.3825
?):11.0112
?,:10.7515
 ?:10.7477
 *:10.571
 $:10.4784
 {:10.1111
 =:10.073
 &:10.0572
|:9.9706
@:9.96389
 [:9.84356
)$:9.74572
*):9.6416

:9.62798
 +:9.60805
 :9.55902

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ->
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ->
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StyleAttr" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 [:15.4872
 ?:12.3951
 ([:11.7472
 Bool:11.7199
[:11.4696
 List:11.4074
 Tod:11.2525
 Int:11.2351
 Maybe:10.7416
 [[:10.6305
 Option:9.79546
 Either:9.41854
 [(:9.4035
 (:9.26606
 :9.19675
 Result:8.98746
):8.88653
 bool:8.82154
 _:8.76074
 {:8.7209
 ):8.61427

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StyleAttr" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
T:19.2186
Int:13.3636
?:12.4662
a:12.4535
]):11.722
 Tod:11.2481
Maybe:11.2158
Bool:10.7124
TO:10.539
List:10.4406
t:10.3109
x:9.99526
int:9.88258
String:9.8246
$:9.79881
xs:9.78404
<:9.74467
X:9.37143
A:9.23567
Element:9.18585
Option:9.17992

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [T

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [T
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <T>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "T"))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  T
Nature of error: Type variable T is not bound
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: T
LSP: Generating Completions for prefix: T
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo" | extend-constructor
root ::= completions

Top 20 Logits:
odo:27.0864
odd:16.7263
odos:16.6514
od:16.2903
oto:15.0954
udo:14.9932
ogo:14.5651
oda:13.84
oo:13.8297
d:13.7924
oko:13.7046
ood:13.1369
ok:12.6697
odio:12.5426
olo:12.4513
dd:12.3034
do:12.2823
odot:12.119
odon:11.8293
oco:11.827
oso:11.4332

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-concave or complete: Todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Todo
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "]"
root ::= completions | new-tokens

Top 20 Logits:
]):18.1731
]:16.152
],:15.7591
):13.3945
]=:13.0282
])):12.1239
)):11.1021
]),:11.0612
]).:10.8966
)=:10.8919
)]:10.777
]);:10.7566
]]:10.302
];:9.99543
,:9.97276
),:9.88878
]->:9.77083
>):9.6923
][:9.457
]]):9.38968
=:9.35975

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo]

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo]
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= new-tokens

Top 20 Logits:
 =:15.2
 ):13.9372

:11.6219
 ->:10.9378
 |:10.7664
 in:10.2022
 :10.1646
>:9.80271
 end:9.61758
?):9.13309
 ==:9.12139
 ,:9.08019
 ~:9.05556
|:8.99938
?:8.70397
 ?:8.58496
 @:8.57908
*):8.40456
~:8.08374
)::7.95526
)$:7.8452

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] )

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] )
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Prod [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= new-tokens

Top 20 Logits:
 =:15.6535
 ->:15.2412
=:14.0522
->:13.8938

:12.1779
 :11.6036
 =>:11.2497
 <-:9.61277
 ~:9.27664
 ==:9.20191
 |:9.13919
(:8.81912
=>:8.81606
 {:8.39917
 -:8.37847
 in:8.34873
  :8.33945
 end:8.24406
=(:8.21712
 -->:7.94752
 x:7.53435

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:

:18.1862
 :16.1705
 fun:14.9738
  :13.412
    :12.475
 \:11.5013
                :11.423
 #:11.3674
 {:11.3042
 (:11.1027
     :11.055
   :10.9027
 ?:10.7517
        :10.6818
      :10.6008
 match:10.5701
fun:10.4267
            :10.3532
 @:10.1422
       :10.1073
 function:9.93245

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
     :18.4563
       :17.1042
   :16.6406
fun:14.9481
 :14.5121
    :13.5356
         :12.885
      :12.8754
           :12.8434
  :12.233
	:12.0367
func:11.6094
        :11.3539
               :11.2397
                :10.9991
 fun:10.7544

:10.7231
             :10.5253
function:10.2561
          :9.9576
if:9.7077

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
     

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
     
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 fun:19.0083
 if:14.2953
 match:13.5259
 #:12.7002
 (:12.5868
 case:12.5792
 let:12.4285
 |:12.394
 {:11.6591
 func:11.6137
 (*:11.245
 fn:11.056
 lambda:11.0406
 f:10.964
 @:10.815
 //:10.7881
 ?:10.2592
 go:10.1508
 switch:10.1014
 fix:10.065
 begin:10.0488

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Model.eq Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "Model.eq" | "Todo.eq" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 idx:14.8096
 is:11.6735
 xs:11.4598
 (:11.2363
 n:10.7257
(:10.7082
 length:10.6419
 :10.2692
_:10.1197
 len:9.92466
 x:9.91803
 i:9.89973
 eq:9.61641
 |:9.40052
 true:9.3866
 !:9.04399
 bool:8.98333
 l:8.96212
 t:8.95041
 else:8.84801
 int:8.70531

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: == != <= >= < >
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: idx
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Model.eq Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 <:18.6299
 ==:17.5313
 >:16.277
 <=:16.2376
 >=:16.0726
 $:14.3663
 =:14.2225
 ===:12.9659
 !=:12.5
 is:12.429
 -:12.324
 +:11.7798
<:11.7012
 :11.6394
==:11.6165
 <>:11.5276
 =>:11.2802
=:11.1768

:11.0147
$:10.6252
 %:10.0481

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx <

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx <
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: ><<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Integer Less Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Less Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Integer Less Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Integer Less Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: <
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: <
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Model.eq Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 :15.0019
 length:14.3845
 len:12.7798
 List:12.3562
 n:11.2099
 size:10.6744
 l:10.5222
 (:10.2353
 h:10.0814
 fol:9.98721
  :9.80712
0:9.63758
 list:9.55582
 -:9.25333
 idx:9.16103
 $:9.03424
 xs:8.94721
 t:8.93696
 init:8.19388
 rev:8.17219
 count:8.14564

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: ><<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Integer Less Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
0:24.1361
1:20.7621
2:16.8011
 length:15.7375
5:15.6255
3:15.588
4:15.0238
 n:14.3392
 t:14.3164
 len:13.8344

:13.3657
9:13.3636
6:13.266
 list:13.1504
 h:13.074
8:13.0501
7:12.6624
xt:12.5439
 List:12.2611
 rev:12.2116
nd:12.1312

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Integer Less Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 0
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 then:17.4733
 ||:17.3009

:15.5586
 :15.4747
 {:12.8365
 &&:12.4805
 or:11.8766
 |:11.8686
  :11.7215
 ?:11.3661
.:11.3404
 =>:10.9888
 //:10.7308
                :10.5808
    :10.5564
 return:10.3044
 end:10.1543
 #:10.1399
 =:9.87233
 ->:9.84293
;:9.84186

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 id:13.4759
 []:12.8354

:11.7807
 fun:11.5543
 raise:11.2835
 None:11.227
 error:11.131
 (:11.1184
 identity:10.6874
 :10.6564
 abort:10.5374
 List:10.4839
 xs:10.4633
 ([:10.4484
 fail:10.1507
 Some:10.0392
 t:10.0147
 @:9.76013
 [],:9.72194
 _:9.67653
 .:9.50504

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then id

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then id
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "id"))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  id
Nature of error: Variable id is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: id
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "x"
root ::= completions

Top 20 Logits:
 else:16.2511

:15.6781
 :13.7597
 end:13.7137
():12.8798
_:12.5101
(:12.0397
  :11.3634
 @:10.6174
n:10.4267
 #:10.3587
    :10.277
 elif:10.191
 in:10.1775
 ||:10.1084
 $:10.0351
      :9.98873
 //:9.91001
 ():9.89919
                :9.88598
 \:9.85139

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: idx
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:12.8382
 +:11.8003
:::11.4728
_:11.0565

:10.7007
,:10.5895
 =>:10.0127
 >=:9.69124
 -:9.56778
 end:9.43415
 =:9.26744
1:9.0295
 :8.90554
 in:8.88011
2:8.77374
':8.74621
 :::8.63295
 @:8.47816
 :=:8.44447
.:8.31673
 ->:8.30416

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:

:12.7856
 fun:11.8332
 go:11.6679
 :11.4766
 id:10.9668
 xs:10.6568
 (:10.5348
 x:10.4454
 _:10.4034
 t:10.3181
 List:10.1751
 idx:10.1705
 acc:10.1564
 f:10.0944
 h:10.0902
 fn:10.0376
 n:9.93542
 []:9.49891
 drop:9.4664
 if:9.37603
 {:9.33988

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
       :15.9241
     :15.3098
   :13.3623
         :13.0172
fun:12.6893
      :11.8252
        :11.6129
 :11.3214
           :11.2929
if:11.0813
    :10.9826

:10.885
                :10.874
	:10.6558
let:10.6181
go:10.1133
  :9.98335
func:9.96883
          :9.93885
               :9.88947
            :9.62956

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
       

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 fun:15.2698
 case:14.8964
 if:13.9458
 let:13.0346
 match:13.0276
 go:12.3235
 |:12.2683
 (:11.8926
 fn:11.7872
 fol:11.5831
 func:10.7085
 List:10.6359
 _:10.4708
 \:10.3022
 n:10.1803
 function:9.91195
 h:9.87725
 xs:9.86815
 begin:9.86548
 @:9.84757
 #:9.7938

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:15.7818
 idx:13.309
 t:13.0636
 list:11.929
 go:11.6392
 ts:11.3556
 List:11.0537
 x:10.9039
 l:10.8115
 n:10.8075
 h:10.3981
 y:10.3661
 :10.3358
 (:10.2021
 _:10.006
 id:9.99788

:9.88952
 lst:9.86921
 i:9.85386
 ls:9.79726
 in:9.42774

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.5575
 :16.3598
,:15.4393
 of:14.0756
 |:14.0136
  :13.7621
 in:12.5338
.:12.3447
 when:12.1747
    :12.11
 #:11.9483
 with:11.7978
 ,:11.5679
 =>:11.4642
[:11.4056
 match:11.1357
      :11.1286
 {:11.1019
 //:11.026
::10.9842
 =:10.9219

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :17.8237
         :16.1157
     :14.1603
           :13.8433
        :13.7034
   :13.3114
      :12.9526
	:12.4744
          :12.4466
    :11.6949
|:11.5059
             :11.4653
            :11.2755

:11.2457
  :10.9091
#:10.8593
 :10.7983
               :10.6597
                :10.3523
              :9.69796
 |:9.65918

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
       

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.9373
 #:13.9545
 when:13.3393
 idx:12.0759
 []:11.8586
 if:11.7148
 ||:11.3399
 match:11.2807
 end:10.5989
 ,:10.5375
 (*:10.4881
 {:10.3569
 let:10.2763
 $:10.2569
 *:10.1274
 -:10.1005
 @:10.0095
 _:10.0004
 x:9.97422
 ?:9.947
 [:9.9119

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        |

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 []:18.1665
 _:15.3454
 h:15.2663
 x:15.0593
 t:13.7574
 [],:12.8945
 [:12.4578
 todo:12.4158
 y:11.958
 (:11.7364
[]:11.574
 (_:11.3681
 [_:11.2959
 _,:11.1928
 a:11.1749
 ts:11.1113
 :10.9326
 l:10.8962
 td:10.8629
 i:10.2056
 z:10.138

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ":" | "::" | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.7171
 when:12.8311
 ->:12.5093
=>:12.4393
 :11.8404
    :11.7448
  :11.488
      :11.4493
 :::11.1909
 if:11.1164
         :11.0744
          :10.9004
        :10.8737
 |:10.8619
 ||:10.8175
 :=:10.721
           :10.6556
   :10.6492
:::10.6122
                :10.6122
     :10.4306

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] =>

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 id:14.7913
 []:13.4247
 xs:12.2815
 fun:11.6283
 acc:11.615
 t:11.2611
 nil:10.9596
 List:10.7311

:10.7103
 \:10.6648
 :10.5399
 rev:10.4164
 raise:10.3733
 (:10.3162
 fail:10.297
 error:10.2206
 @:10.1234
 fn:10.0693
 Nil:9.97972
 idx:9.90366
 go:9.90136

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => id

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => id
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "id"))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  id
Nature of error: Variable id is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: id
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "x"
root ::= completions

Top 20 Logits:

:15.5631
xs:13.1812
 :12.8306
(:11.595
 end:11.3643
t:11.0911
n:11.0883
k:11.0404
  :11.0037
 //:10.8348
 #:10.4689
():10.3653
 in:10.2722
 xs:10.2524
_:10.0696
c:10.0053
y:9.97618
x:9.87789
;:9.84363
.:9.69068
 _:9.61391

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: idx
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:15.5305
 +:13.7575
 -:13.5534
 else:13.3176
 =>:12.7953
 :12.6736
,:12.5797
:::12.43
 :=:12.0437
 >:12.0301
 @:11.5157
 ->:11.2966
  :11.2222
 #:11.163
 :::11.1616
 >=:11.117
 //:11.1135
 end:11.09
 <:11.0649
;:11.0271
 ==:11.0235

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :19.3257
        :13.4956
     :13.3821
         :13.2091
	:13.1543
      :13.0069
   :12.883

:12.5704
           :12.3709
    :12.1179
#:11.7881
          :11.7499
|:11.6695
            :11.577
  :11.3481
                :11.2926
 :11.2175
             :10.9018
end:10.7464
               :10.5044
              :9.87795

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
       

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:19.5492
 #:13.4208
 when:12.8251
 go:12.2081
 end:12.1472
 _:12.1146
 if:11.198
 idx:11.1312
 x:10.9918
 t:10.9843
 (*:10.6494
 (_:10.6426
 else:10.5873
 case:10.4798
 [_:10.4245
 i:10.4017
 elif:10.3293
 remove:10.1838
 h:9.99758
 #[:9.98337
 n:9.87526

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        |

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 _:18.0455
 h:16.436
 x:16.2398
 t:14.3681
 y:14.3121
 [_:13.4054
 todo:12.6378
 [:12.6076
 td:12.4757
 (_:11.7561
 head:11.4811
 a:11.4486
 ts:11.4324
 z:11.4281
 d:11.3719
 xs:11.2076
 (:11.1425
 p:10.939
_:10.8098
 item:10.5965
 :10.54

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= new-tokens

Top 20 Logits:
:::18.3636
 :::14.7086
 =>:13.7446
 when:12.2532
hd:11.8043
 ->:11.8035
=>:11.5879
 if:10.5779
::10.2528
 in:9.92902
 :9.77545
t:9.74663
 ::9.72806
__:9.70949
@:9.69304
 =:9.62817
x:9.57901
xs:9.57638
h:9.55872
  :9.4718
->:9.34762

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
xs:17.3114
tl:16.0613
ys:12.9289
_:12.8486
ts:12.8222
[]:12.4636
rest:12.3441
t:11.6964
tail:11.4394
l:11.0727
zs:11.0401
y:10.4644
ls:10.3208
x:10.1558
xl:9.92699
 xs:9.88377
rem:9.47369
lst:9.4601
 t:9.27355
rs:9.23948
s:9.23608

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
 =>:16.9617
 when:14.6998
 ->:13.9385
':13.2109
1:12.26
 :12.0892
_:11.9968
2:11.7209
=>:11.5452
 as:11.4449
 if:11.4356
,:10.9506
->:10.4954

:10.3283
 :=:10.2915
 :::10.1634
  :10.1631
 &&:10.0765
@:10.0059
 =:9.92886
 @:9.91592

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs =>

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 go:15.0356
 :12.1604
 remove:11.8327

:11.7475
 fun:11.6509
 idx:11.4679
 if:11.2537
 id:11.0299
 (:10.8234
 fn:10.6972
 f:10.3254
 xs:10.1254
 n:10.019
 x:9.97532
 h:9.82221
 inc:9.76646
go:9.71505
 t:9.68468
 let:9.43973
 @:9.38758
 func:9.29803

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
1:19.0512

:16.6672
 go:15.727
0:14.2873
2:13.1236
 if:12.6577
 idx:12.3107
 id:11.7441
 fun:11.6526
 (:11.53
 fn:11.2806
 f:11.2285
 remove:11.1724
 @:11.0846
3:11.016
 n:11.0058
 x:10.8571
 i:10.7755
 xs:10.6134
 match:10.6004
 let:10.4689

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: 1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= completions | new-tokens

Top 20 Logits:
 +:18.6032
+:13.5887
 in:12.7028

:12.3631
 end:12.3124
:::11.3538
 -:11.1916
 :::11.1454
 :10.3843
+(:10.1534
 ->:10.1258
 @:10.0298
.:9.89677
 =>:9.8651
+$:9.82393
 =:9.72713
 *:9.67713
(:9.55036
 $:9.48738
..:9.4645
 else:9.33568

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 +

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 +
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >+<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Addition
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + ?
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Addition
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))]);
           syn = Int})))
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + ?
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + ?
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: +
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: +
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
Int <= (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Target types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "abs" | "case " | "idx" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
 go:16.0345
 remove:13.7252
 idx:13.1367
 (:12.8829
 length:11.6993
 id:11.2649
 index:11.146
 n:11.0811
 fol:10.8891
 t:10.7537
 $:10.6835
 :10.6167
 len:10.6083
 xs:10.5424
 f:10.3489
 x:10.1355
 h:9.9279
go:9.67075
 @:9.47001
 int:9.35446
 i:9.21402

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: idx
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - abs case  idx if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "*" | "**" | "+" | "," | "-" | "/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:15.6407

:15.3102
 in:14.1121
 +:13.0641
 &&:12.9345
 :12.7541
 -:12.5409
 :=:11.9031
 @:11.6456
):11.5785
  :11.5498
,:11.4385
 =:11.3653
 =>:11.2509
 $:10.9994
;:10.7873
 ||:10.7519
(:10.6759
 go:10.5865
 ->:10.3751
 *:10.258

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: (Int, Int, ([Todo] -> [Todo]))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Int, ([Todo] -> [Todo]))
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int Int (Arrow ((List (Var "Todo")), (List (Var "Todo"))))
LSP: commas: self syn is (Prod [Int; Int; (Arrow ((List (Var "Todo")), (List (Var "Todo"))))])
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "*" | "**" | "+" | "-" | "/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:17.2838

:14.226
 end:12.7995
):12.5063
 :12.4118
 &&:11.0258
,:10.9892
;:10.9244
.:10.7827
 and:10.7617
 fun:10.5962
 ):10.4862
  :10.4477
 =:9.9892
 x:9.916
 ->:9.75796
 .:9.64672
in:9.6432
 then:9.47614
 ,:9.41162
 xs:9.347

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] case  if  let  remove type  xs
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "case " | "if " | "let " | "remove" | "type " | "xs"
root ::= new-tokens

Top 20 Logits:

:17.9004
 :14.745
  :13.5726
    :12.949
 go:12.2497
        :12.1279
      :11.7775
   :11.2426
            :11.2043
                :11.1318
     :10.6364
          :10.6353
 fol:10.2921
         :10.2053
 #:9.98457
       :9.92655
 xs:9.83107
 rev:9.81115
 fun:9.69333
 remove:9.68728
 ():9.61913

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] case  if  let  remove type  xs
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "case " | "if " | "let " | "remove" | "type " | "xs"
root ::= new-tokens

Top 20 Logits:
   :14.6575
go:14.5715
       :13.4709
let:12.5356

:12.4298
fold:12.4238
 :12.317
     :11.9794
    :11.9639
        :11.647
rev:11.4471
case:11.3786
List:11.3348
  :11.2563
      :10.6413
if:10.5461
         :10.3695
#:10.3673
xs:10.1419
           :9.82667
fun:9.52779

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
   

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] case  if  let  remove type  xs
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "case " | "if " | "let " | "remove" | "type " | "xs"
root ::= new-tokens

Top 20 Logits:
 List:13.9023
 go:13.7858
 fol:12.9515
 let:12.3921
 case:12.3842
 rev:12.2571
 if:11.3425
 drop:11.1396
 match:10.9419
 #:10.9099
 n:10.8757
 remove:10.7786
 t:10.1015
 xs:10.0358
 (:9.84748
 reverse:9.77764
 h:9.72864
 take:9.63811
 fun:9.39919
 todo:9.33903
 list:9.1554

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 rec:12.3743
 go:11.3779
 len:11.2474
 (:10.8492
 h:10.845
 n:10.8151
 l:10.8029
 f:10.775
 acc:10.7681
 remove:10.5627
 idx:10.4954
 left:10.3341
 _,:10.0361
 before:9.93592
 i:9.90615
 start:9.84132
 t:9.81245
 head:9.79129
 y:9.77693
 rem:9.76707
 drop:9.72278

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <rec>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rec: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: rec
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: rec
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 remove:12.4058
 go:12.1218
 loop:12.119
 drop:11.3606
 aux:11.1273
 helper:10.8291
 inner:10.6285
 rem:10.3256
 f:10.2742
 rm:9.98807
 impl:9.93952
 iter:9.76794
 r:9.73713
 g:9.53947
 filter:9.51862
 update:9.31478
 step:9.20563
 delete:9.18992
 split:9.12893
 take:9.10754
 skip:9.05164

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <rec>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rec: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= new-tokens

Top 20 Logits:
     :14.2801
       :13.4602
   :13.3935
go:12.3622
 :11.4431
    :11.032
#:10.9571
      :10.9231

:10.9093
remove:10.2461
         :9.96449
let:9.8618
        :9.7865
           :9.54952
  :9.34616
rem:9.3417
loop:9.26058
fun:9.19228
t:8.83341
func:8.8136
helper:8.7351

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
     

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
     
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <rec>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {rec: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= new-tokens

Top 20 Logits:
 fun:12.8469
 go:12.6891
 loop:11.9232
 remove:11.8822
 aux:11.3048
 f:10.5759
 case:10.5381
 #:10.4155
 drop:10.3988
 rem:10.2539
 rm:10.0488
 if:10.0274
 step:9.9508
 |:9.94313
 let:9.93766
 helper:9.93745
 inner:9.82945
 func:9.70629
 fn:9.68228
 g:9.59894
 rec:9.37772

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:12.0189
idx:11.6618
_,:10.8729
i:10.4707
xs:10.3789
n:10.2239
hd:10.1178
acc:10.0685
fun:9.95615
remove:9.66948
f:9.55632
rem:9.31012
len:9.21108
l:8.88364
x:8.74985

:8.68771
fn:8.6361
t:8.62926
p:8.61378
~:8.49484
rec:8.42167

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:13.1001
,:11.9169
::10.9927
):10.2744
_:10.104
2:9.86962
)(:9.61609
.:9.56613
 (:9.5529
 idx:9.32862
)::8.94697
 i:8.90787
 xs:8.89
 :8.68611
 acc:8.5387
 go:8.51619
((:8.35688
 ::8.28106

:8.22728
 n:8.21676
':8.19926

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:15.9947
0:13.3678
xs:12.6794
len:11.5411
i:11.5231
go:11.3764
1:10.4446
n:10.1207
List:9.82882
id:9.80658
length:9.75225
_,:9.62222

:9.4776
index:9.29669
 idx:9.10338
list:9.02609
acc:8.99183
x:8.93398
l:8.92288
ts:8.71375
 :8.60754

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:15.9533
),:14.5346
 -:14.1214
):13.4135
)):12.0855
)::11.3438
 +:11.2122
-:11.2054
 ,:10.9666
 =:10.5459
)(:10.43
)),:10.1565
 xs:10.111
.:9.8518
=:9.80366
+:9.47792
(:9.44204
);:9.1933
 *:8.95609
).:8.87983
))::8.80432

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :13.4802
 i:11.5411
 xs:11.4729
 acc:11.4686
 idx:11.3358
 len:10.8518
 go:10.8308
 n:10.7142
 _,:10.1235
 -:10.057
 length:9.70688
 [],:9.38175
 ts:9.19348
 t:9.191
0:9.1817
 x:9.00843
 l:8.93364
 count:8.82767
 y:8.76325
 c:8.4889
 (:8.40595

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
0:22.2438
1:19.0729
2:16.2365

:14.8808
9:14.3152
xt:14.3012
3:14.0624
 i:13.474
5:13.2678
4:13.2295
 n:13.1093
 xs:12.7406
6:12.5911
 x:12.5062
 ts:12.4637
)):12.391
 go:12.39
 -:12.2881
 t:12.251
8:12.2242
7:12.1676

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:16.3793
),:14.3932
):13.2246
)):12.6543
)::11.7501
 ,:11.7456
)),:11.1212
,[:10.9519
 xs:10.4665
))::10.3579
)).:9.2644
 [],:9.19122
));:9.16292
 []:9.07395
);:8.9399
 ->:8.89499
)(:8.87544
).:8.81126
 (:8.71588
 :8.7158
.:8.69512

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 id:13.4312
 fun:13.0205
 xs:12.1304
 []:11.4687
 List:10.9746
 identity:10.9721
 drop:10.906

:10.8157
 [:10.6861
 (:10.6672
 t:10.6421
 :10.4158
 fn:10.3595
 f:10.2573
 x:10.2377
 \:10.123
 acc:10.0323
 rev:9.93585
 go:9.71789
 remove:9.64217
 ts:9.55902

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
),:15.2949
):14.2005
)):13.2209
)::11.5769
)),:11.2253
))::10.6129
 ),:9.2559
)(:9.25389
))):9.22764
));:9.13204
)[:9.036
n:9.00219
);:8.82727
_:8.75774

:8.54551
 ):8.53023
)).:8.39321
)|:8.39268
 :8.37052
(:8.29531
).:8.26738

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:12.5323
 as:12.455
 @:12.1993
 xs:11.679
 ::11.5524
 ->:11.4145
 :::11.3573
 &&:11.3139
 ,:11.3072
 ||:11.1228
 in:11.0849
([:11.0161
 |:10.8314
 &:10.7911
 (:10.7334
 $:10.6987
 :10.5414
 ==:10.3552
 =:10.3067
 >>:10.1331
 ++:10.1112

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
      :14.6086
     :14.1946
   :13.6873
in:12.7923
       :12.7344
    :12.3278
end:12.0281
 :11.9201

:11.2996
  :11.1904
|:11.0643
#:10.6201
         :10.5741
        :10.5022
let:10.3276
           :9.82602
$:9.47513
          :9.33199
                :9.27297
fun:9.17513
||:9.12819

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
      

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
      
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 |:14.5357
 go:13.597
 (:12.6605
 @:12.6584
 ::12.5311
 ,:12.4247
 ||:11.8506
 fun:11.8007

:11.75
 xs:11.6188
 #:11.423
 .:11.1551
 ([:10.9814
 [:10.6661
 $:10.6247
 &&:10.4106
 ((:10.3509
 ):10.2452
 <:10.0728
 rev:10.049
 end:10.0244

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:12.2965
hd:11.213
fun:11.1153
case:10.5745
xs:10.3526
 go:10.1137
x:9.96069
[]:9.83775
tl:9.48185
rev:9.40473
map:9.29341
List:9.2843
acc:9.27666
idx:9.2639
_,:9.04461
cons:9.03287
if:9.01487
fold:8.88963
t:8.79381

:8.59592
id:8.57966

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:16.5645
::11.7594
((:11.5863
.:11.3457
 (:11.0235
(-:10.591
,:10.541
2:10.4035
)(:10.3248
)):10.2995
_:10.2353
 as:9.9362
(_:9.47979
 ->:9.47811
':9.43727
 -:9.35882
.(:9.2844
 xs:9.23663
):9.16802
 :::9.15799
 <:9.08257

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:16.4694
len:13.4765
0:12.7503
length:12.2427
go:11.9614
xs:11.5568
List:11.3878
n:11.1052
1:10.9749
i:10.7361
list:10.373
l:10.3268
hd:10.2153
id:9.99967
count:9.51349
_,:9.38119
 idx:9.34459

:9.13101
tl:9.04171
index:9.03341
t:9.00738

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.47
 -:16.1417
-:13.8067
 +:13.2749
+:12.0796
 ,:11.8535
),:11.5284
 /:10.8341
):10.3869
)):10.1342
.:10.0463
_:9.55606
::9.37279
(:9.27302
))):9.24886
,$:9.22237
',:9.176

:9.16785
 =:9.13542
 :8.99737
/:8.96109

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :14.0822
 idx:12.9088
 go:12.7244
 len:12.4259
 n:12.3891
 length:11.7704
 i:11.0575
 xs:11.0058
 _,:10.7932
 -:10.0191
 l:9.62569
 acc:9.5911
 t:9.42109
 (:9.28576
 x:9.24706
 ?:9.04798
 h:8.96434
 ts:8.8877
 List:8.78589
1:8.77824
 _:8.50587

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
1:21.6879
0:20.0125
2:18.4846
3:16.578
5:16.1539
9:16.0192
4:15.8909
6:14.6376
8:14.5396
7:14.4349
 n:13.7288

:13.3881
 len:13.3834
nd:13.0783
xt:12.9436
 i:12.9158
 x:12.7014
 idx:12.6932
 l:11.6359
 length:11.4526
 (:11.3198

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.6218
 +:13.6499
 ,:12.494
+:12.2274
0:11.5149
)):10.3753
 -:10.3608
):10.2099
:::10.1896
,[:10.1852
),:10.1505
 :::9.87627
 [:9.32739
2:9.31455
 :9.08091
5:8.97386
+(:8.97087
)),:8.93585
))):8.88614
::8.86981
 t:8.72861

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:15.1796
 t:13.0698
 (:12.0593
 cons:12.0133
 List:11.6156
 tail:11.3124
 h:11.2923
 fn:11.2882
 xs:11.1982
 drop:11.1856
 f:11.112
 rev:10.8752
 \:10.7127
 x:10.587
 remove:10.2443
 id:10.1229

:10.0677
 go:9.9532
 [:9.89089
 reverse:9.81641
 :9.80801

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:14.2272
 y:13.2148
 l:12.3925
 acc:12.264
 [:12.2188
 xs:12.1443
 h:12.0085
 t:11.9275
 (:11.6241
 z:11.2208
 a:11.0867
 _:10.9495
 tail:10.4199
 todo:10.2859
 s:9.86424
 (_:9.80484
 r:9.67955
 rest:9.67204
 ts:9.61271
 p:9.57431
 ([:9.4426

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:15.3881
 xs:12.2661
 y:12.0594
:::11.7128
 acc:11.4911
->:11.3116
::10.879
ss:10.5167
 :::10.4193
 _:10.1982
 t:10.1975
,:9.95826
 =>:9.68291
 h:9.0739
 l:9.03232
1:8.97172
 s:8.899
xs:8.7885
 ts:8.78097
 rest:8.76896
ys:8.60434

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:14.4998
 x:13.9571
 go:12.8277
 t:12.5536
 fun:12.3182
 h:12.3064
 id:11.8952
 cons:11.8931

:11.4274
 (:10.926
 :10.8356
 List:10.6073
 xs:10.5932
 remove:10.487
 f:10.4013
 rev:10.244
 fn:10.2337
 acc:9.92102
 [_:9.77952
 _:9.69664
 tail:9.65213

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
x:15.1232
hd:14.4794
]):13.266
head:10.8723
@:10.6184
 x:10.3076
tl:10.1
T:10.0824
t:9.97541
f:9.72428
remove:9.65361
nth:9.49355
xs:9.4866
List:9.47682
id:9.35777
y:9.13333
h:9.0329
go:8.63447
].:8.50379
s:8.39007
 ]:8.38335

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:17.4111
@:14.4956
 ):14.1255
))):12.6768

:12.5876
 $:12.3044
:::12.2297
 :::11.9172
 ::11.2235
 :11.0989
 <>:10.7078
 <<:10.3193
)):10.2545
 |:10.1541
 ++:10.1484
  :10.0038
 ||:9.96022
 end:9.89198
)::9.83976
 //:9.77916
 ),:9.67411

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:14.742
 [:14.2934
 t:12.0904
 (:11.3693
 go:11.0285
 ([:10.1797
 xs:10.1531
 remove:10.085
 y:10.0227
 id:9.89167
[:9.87166
 :9.82102
 $:9.53183
 List:9.47424
 ?:9.45666
 h:9.25379

:9.23113
 [[:9.18626
x:9.07153
 [(:8.98692
 cons:8.97711

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x
Nature of error: Variable x is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
):14.9972
)):14.8098
 ):14.388
))):13.4407
:::12.5345
),:12.0886
 :::12.0031
 :11.8076
)),:11.5421
[:11.2408
 @:11.029
@:10.519
.:10.3813

:10.2002
)::9.78337
 ),:9.75766
 end:9.57133
[@:9.51991
)))):9.43513
 $:9.0111
))]:8.97644

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
)):14.6608
):14.5548
))):13.7451
 ):13.5219
[:12.7145
),:12.0469
)),:11.8824

:11.3832
 @:11.1888
[@:10.8363
 :10.7543
.:10.61
)))):9.59754
@:9.57155
 ->:9.52261
 end:9.51048
[::9.38827
 =>:9.10501
 >>:9.10259
 ),:9.10124
 |:9.09084

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:16.0322
 ):12.7097
 :12.6379
 as:11.7243
  :11.6092
 in:11.3902
 end:11.3866
 #:10.7873
    :10.3294
 @:10.2922
 //:9.87225
   :9.79391
 (:9.75323
                :9.6074
 xs:9.56711
 x:9.51728
 ::9.46002
 ,:9.39777
        :9.39698
@:9.3171
 :::9.2568

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
       :15.3562
      :14.5993
        :13.5193
         :12.5106
          :12.0334
     :11.7673
  :11.4685
    :11.371
   :11.2566
           :10.9752
	:10.8074
                :10.3448

:10.1457
(:9.74215
            :9.59775
              :9.40861
 :9.39013
in:9.24518
end:9.15425
             :9.10076
               :8.6819

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
       

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 (:18.025
 go:14.7006
 id:13.7894
 ([:13.589
 (_:13.3606
 ((:13.163
 xs:13.0958
 fun:13.0011
 x:12.5493
 t:12.383
 ):12.3772
 ...:12.3008
 [:12.2293
 []:12.0744
 |:11.9135
 end:11.8376
 if:11.7498
 ::11.6641
 .:11.6423
 (\:11.6348
 ,:11.5451

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:14.5741
fun:13.4803
xs:11.4955
id:11.3541
rev:11.244
case:11.1984
hd:10.931
let:10.8397
List:10.6212
if:10.5843
fold:10.4662
 go:10.2438
fn:10.171
tl:10.1089
map:9.86416
x:9.83848
cons:9.49361
[]:9.35674
_,:9.35196
idx:9.1281
match:8.80844

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:17.8145
((:11.9991
 (:11.8485
(-:11.2137
.:11.148
(_:10.6195
.(:10.3251
[:10.3067
([:10.2214
))):10.1744
():9.87624
::9.78178
,:9.71349

:9.5983
)))):9.54207
(...:9.48749
(@:9.4645
_:9.39373
)):9.28195
(`:9.14469
(":9.11859

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:17.8432
0:12.5067
1:12.3997
xs:12.151
go:11.975
id:11.6906
len:11.6447

:11.2798
i:11.2602
n:10.5626
 idx:10.4713
2:10.2644
x:9.9481
length:9.83756
l:9.67384
index:9.63455
--:9.61053
t:9.38471
List:9.18645
list:9.13084
_,:9.05888

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.7818
 -:16.3594
-:13.6376
 ,:13.0717
 +:12.6891
+:11.131
),:10.9337
.:10.8775
 /:10.751
 :10.699
 $:10.6761
,$:10.6445

:10.0852
):10.0427
 =:9.95092
,,:9.90215
)):9.8865
 <:9.87154
 >:9.8273
(:9.5784
::9.55254

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :16.226
 n:13.8934
 _,:13.3091
 go:13.2097
 idx:13.2008
 i:12.1647
 len:11.7169
2:11.177
 -:10.7995
 xs:10.606
 ?:10.4754
 _:10.2459
 x:10.1616
 t:10.0667
 length:9.94518
 (:9.72577
  :9.65369
 id:9.61195
 h:9.54776
 acc:9.44989
 _):9.27491

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
2:24.566
3:19.2723
1:19.2105
0:17.9082
5:17.3603
4:17.3415
9:16.1045
7:15.1352
6:15.0512
8:14.9969

:13.9124
 n:13.4865
)):12.8673
 i:12.7044
nd:12.4118
 _,:12.3679
 ,:12.1861
xt:12.088
 idx:11.3618
 -:11.1018
 x:11.1003

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 2
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 2
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.1504
+:13.111
 +:12.9031
 ,:12.4549
 xs:10.9958

:10.1979
..:10.1695
,(:10.1354
 x:10.0151
0:9.72949
),:9.6201
...:9.59413
 :9.52257
):9.4542
)):9.3596
 *:9.34988
 -:9.25549
 :::9.21438
+(:9.20892
)))):9.20871
 ...:9.19884

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:16.3652
 (:11.4189
 f:11.4013
 t:11.3753
 function:11.1299
 cons:11.0916

:11.0689
 :11.0663
 \:10.9555
fun:10.8888
 func:10.6434
 id:10.6306
 xs:10.626
 fn:10.1605
 List:10.086
 x:9.97308
 h:9.90929
 ?:9.74628
 drop:9.58357
 [:9.4816
 go:9.41489

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:17.1524
 y:15.0271
 _:14.5568
 xs:14.3572
 h:14.24
 (:13.5303
 t:12.8588
 a:12.7687
 (_:12.564
 [:12.51
 l:12.4713
 acc:11.9791
 head:11.624
 z:11.5503
 i:11.3208
 f:11.118
 [_:10.8649
 :10.7363
 e:10.6725
 n:10.4756
 _,:10.4331

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:17.0344
 y:15.0709
 xs:14.6325
->:12.794
 h:12.2609
 _:12.0234
 acc:11.9235
 t:11.6183
 =>:11.2491
,:11.1666
 :::11.1375
 x:10.9829
:::10.902
1:10.8252
xs:9.93693
 l:9.88669
_:9.86928
y:9.78601
@:9.73034
':9.71739
ys:9.52936

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:14.3068
 [:13.9646
 h:13.4873
 xs:13.1275
 t:12.9571
 []:12.0277
 List:11.7279
 go:11.7257
 (:11.6296
 [_:11.0718

:11.0612
 :11.0009
 id:10.7675
 remove:10.4742
 if:10.4102
 rev:10.4037
 f:10.2453
 let:10.1891
 drop:10.1833
 ([:10.1349
 y:9.98221

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
:::15.033
 :::14.3179
[:12.7202
 @:12.6991
s:12.6333
 $:11.3776
)):10.8018
))):10.684
@:10.5815
):10.5773
.:10.2835
::10.1636

:9.655
hd:9.59082
[::9.55819
)))):9.54934
 ::9.54005
 h:9.42142
 xs:9.22737
h:9.21596
d:9.20447

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
[:14.9133
 @:13.7976
.:12.8239
))):11.7678
)))):11.2101
)):11.1279
 $:10.9076
):10.8149
.[:10.813

:10.2984
.(:10.0322
[::9.81694
(:9.74021
 |:9.54273
@:9.51926
[[:9.48493
 :9.41365
[@:9.32313
 :::9.23672
:::9.15845
.$:9.1253

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:14.9689
 []:14.5943
 [:14.3638
 x:13.3751
 y:12.6384
 t:12.1789
 ts:11.5636
 go:11.1049
 [(:10.8523
 h:10.7526
 (:10.6271
 [[:10.4047
 [_:10.3822
)))):10.2574
 :10.0769
[:10.0278
 id:9.96333
 ([:9.80932
[]:9.43051

:9.22113
 _):9.15073

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
)))):15.1062
)):14.7228
))):14.1476
):13.9883
[:12.336
 ):11.6706
 :10.8636
.:10.2718

:9.61058
[::9.47369
)),:9.47044
)));:8.76159
[@:8.66765
)[:8.41706
),:8.33197
)]:8.24439
')):8.12736
(:8.01367
[]):7.94602
 @:7.92756
2:7.92044

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:15.4905
 ):13.2474
 :12.7109
 end:12.3458
  :11.2122
 in:11.0785
 as:10.8406
 x:9.98287
    :9.70273
 xs:9.4314
        :9.4157
 (:9.40492
   :9.38007
 @:9.3302
                :9.20504
 $:9.049
 id:9.04444
end:8.95714
 #:8.82835
():8.73472
()):8.60011

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
        :17.197
         :15.0751
       :13.1947
          :12.3696
           :11.6236
    :11.2785
   :11.2433
     :11.1456
      :11.1199
  :10.9247

:10.7958
	:10.5206
end:10.2467
                :10.2061
))):10.1217
 :10.044
            :10.0436
)):9.69522
             :9.63697
              :9.12609
)))):9.12423

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
        

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
        
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 (:16.5678
 id:14.3432
 []:13.4814
 go:13.3911
 (_:13.391
))):13.1394
 ([:13.0415
 end:12.5361
 xs:12.5202
 x:12.3244
 ...:12.2923
 _:12.1678
 ((:11.8155
)):11.809
 nil:11.7812
 ():11.7399
 ):11.6903
 .:11.6516
 None:11.5878
 identity:11.5577
 acc:11.5277

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:13.3746
id:12.7915
fun:12.5917
xs:11.7657
x:10.6692
[]:10.42
_,:9.93958
)))):9.79147
error:9.55505
rev:9.50937
idx:9.22682
 go:9.16236
)):9.03397
raise:8.88548
if:8.87131
fn:8.84938
let:8.8472
List:8.77338
hd:8.68834
identity:8.46565
None:8.45649

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:17.4708
.:11.6897
(-:11.5637
 (:11.2776
)))):11.072
((:10.8342
,:10.7127
(_:10.4888
[:9.75463
)):9.62737
 idx:9.59899
 :9.52781
 :::9.47269
.(:9.46759
(...:9.39047
 -:9.31222
 xs:9.23589

:9.14441
($:9.05238
:::9.03682
 _:9.01725

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:17.9148
xs:13.5442
0:12.919
1:12.5837
id:11.8947
go:11.6013
len:11.5188
i:11.2628
x:11.2146
3:11.1445

:10.9778
2:10.8198
_,:10.6579
4:10.5215
n:10.2541
 idx:10.0788
5:9.8724
index:9.83391
length:9.81382
+:9.64663
l:9.56352

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.3205
 -:14.825
 +:12.6355
-:12.2419
 ,:12.1704
),:11.6388
+:11.4345
)):11.2399
)))):11.1045
.:10.451
 =:10.387
 :10.3616
):10.2963
,,:10.0752

:9.872
 <:9.78057
 $:9.66629
))):9.62208
,$:9.61659
 *:9.5728
 /:9.51835

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :16.7402
 _,:14.7466
 n:14.1077
 -:12.6645
 len:12.5719
 idx:12.4866
 _:12.4814
 i:12.268
3:12.036
 go:11.8618
 xs:11.2233
 ?:11.1184
 Int:11.0641
 x:10.905
 length:10.6864
 acc:10.555
 ,:10.332
 _):10.1357
 N:10.1306
 ts:10.0463
  :9.72025

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
3:24.6887
4:20.4023
5:19.7583
9:18.8309
1:18.0044
7:17.6675
2:17.5301
6:17.504
0:17.3357
8:16.6365

:13.9077
)):13.6515
))):12.3596
 -:12.249
 >:11.8874
 _:11.8609
 ?:11.8279
 ,:11.7994
)))):11.3732
 *:11.3551
 ):11.2711

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <3>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 3
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 3
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.0411
 ,:12.3742
 +:11.8871
+:11.3969
),:11.2235
0:11.101
)))):10.983
)):10.8892
...:10.4755
 ...:10.4687
..:9.96739

:9.89694
 :9.85284
4:9.8352
):9.79197
 ..:9.7156
3:9.5869
 -:9.57351
,[:9.51158
 [:9.42285
1:9.40853

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:15.6234
 id:11.9148
 (:10.5494
 ?:10.2799
 _:10.2796
 t:10.1746
fun:10.1709
 :10.1397
 go:10.1304

:10.1077
 const:10.0824
 []:10.0772
 f:9.95505
 function:9.91949
 h:9.77396
 \:9.69827
 fail:9.63264
 x:9.44736
 List:9.39033
 xs:9.35621
 cons:9.33924

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:18.0566
 _:16.6055
 y:13.6318
 xs:13.3406
 (:13.0418
 [:12.5091
 l:12.3002
 t:12.1322
 h:12.0955
 a:11.8293
 (_:11.8257
 z:11.8013
 :11.3143
 i:11.2822
 acc:11.0406
 [_:10.8716
 ():10.7266
 n:10.7177
 []:10.709
(:10.6423
 f:10.6309

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.1374
 y:14.2282
->:14.2217
 xs:13.3982
 =>:12.8627
 _:12.6415
 acc:12.2219
 h:11.613
,:11.5397
 x:11.5259
 t:11.4107
xs:11.386
:::10.4301
 :::10.375
 :9.99335
 -:9.92976
_:9.86497
 l:9.68279
':9.62722
 xx:9.62358
@:9.5695

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:14.338
 xs:13.3375
 [:13.2378
 []:13.103
 h:11.7074
 t:11.5993
 (:11.4319
 rev:11.2041
 :11.1773

:10.9169
 id:10.7399
 go:10.7365
 ([:10.4107
 _:10.3139
 List:10.2714
 ?:10.162
 ts:10.0372
 let:9.91216
 [_:9.85945
 if:9.62006
 y:9.59891

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
:::16.7205
 :::14.3288
 @:13.0544
[:12.0515
::11.5857
s:11.5715
)):11.2475
)))):11.2458
xs:10.7552
@:10.6559
):10.4575
 $:10.3233
 ::10.1997
 +:10.0176
))):9.92245
h:9.91956
.:9.80689

:9.576
 :9.00522
 xs:8.88518
d:8.71581

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:16.8361
[:13.7684
)))):13.5242
)):12.7214
):12.4574

:11.7827
@:11.345
 :::11.1842
:::10.9993
 :10.9604
))):10.9561
 +:10.9261
.:10.918
 $:10.7229
 ):10.4355
[@:10.1028
 [:9.59488
 |:9.5385
[::9.43983
 *:9.34853
 ...:9.15176

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 []:14.4802
 x:14.4659
 [:14.4549
 xs:14.3827
 ts:11.9895
 (:11.8016
 t:11.7128
 y:11.2631
 ([:10.7974
)))):10.5601
 :10.3986
 id:10.246
 [_:10.0137
 [(:9.98128
 go:9.822

:9.57872
[:9.55937
 h:9.49495
 [[:9.39798
 _:9.34592
[]:9.33021

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
)))):16.1718
)):16.0408
))):14.2622
 ):13.1593
 :12.0395

:10.9076
),:10.2409
 @:9.97916
):9.79213
).:9.69609
)));:9.52097
:::9.3457
 :::9.13134
 end:9.12988
@:9.06631
  :8.66297
);:8.53226
)::8.31229
 |:8.06849
 ?:8.0165
 .:7.82817

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:14.1868
 end:12.7648
 :11.4455
 id:11.1848
 in:10.9756
 ):10.9629
(:10.9572
end:10.4947
 (:10.2643
  :9.82848
id:9.82618
 ?:9.28411
 x:9.27476
   :9.23405
 _:9.22617
in:9.14513
():9.07447
    :8.92937
 xs:8.89091
     :8.81536
(_:8.70125

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
         :16.7803
          :13.9069
        :12.5539
           :12.0652
            :11.6239
       :11.4541
     :11.0166
   :10.9626
    :10.9346
      :10.8909
                :10.7706
  :10.5508
             :10.3558
	:10.336

:10.2774
              :9.91044
)))):9.59617
end:9.51691
               :9.26538
)):9.17567
id:9.12594

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
         

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
         
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 (:16.568
 id:15.0498
 (_:13.7366
 end:13.7127
 go:13.5712
)))):13.4037
 ([:13.3929
 []:12.7107
 xs:12.4752
 x:12.3029
 _:12.2552
 nil:12.2237
 ((:12.0771
 ():11.9956
 fail:11.8126
 acc:11.6973
 None:11.6055
 ,:11.59
 [:11.5869
 #:11.48
))):11.4024

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:13.01
id:12.4891
xs:12.447
fun:12.3126
x:10.3463
[]:9.94014
 go:9.72029
error:9.52683
)):9.25942
)))):9.16823
_,:9.0084
raise:8.85405
idx:8.49596
fn:8.44318
case:8.34228
rev:8.31839

:8.28141
if:8.14369
List:8.13658
let:8.13282
fail:8.07931

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:17.2268
 (:11.5139
(-:11.428
.:11.0439
)))):10.8825
 idx:10.6559
((:10.4633
 :10.2786
,:10.1896
(_:10.0444
)):9.89978
 xs:9.42813
 -:9.40781

:9.1999
[:8.93969
 :::8.9139
_:8.87374
 _:8.80216
.(:8.77909
)(:8.76936
():8.60025

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:17.1791
xs:13.3332
0:12.1782
 idx:12.0663
1:11.7904
id:11.1326
4:10.9086
go:10.7569
x:10.5397
len:10.3476
i:10.3016

:10.153
3:9.94797
2:9.93186
_,:9.66468
5:9.43251
+:9.08812
 :9.08544
n:9.03304
ix:8.99142
,:8.74285

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.9651
 -:14.4569
 +:13.4485
 ,:12.455
-:11.8798
)))):11.5887
),:11.3236
)):11.2694
+:11.01
):10.5806
 :10.3703
.:10.1532
,,:9.91258
))):9.711
 =:9.6403

:9.61278
,$:9.4381
 <:9.28613
 $:9.02481
 /:8.95295
 *:8.90341

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :16.6492
 _,:15.2714
 idx:13.2516
 n:12.9576
 -:12.8808
4:12.8519
 _:12.8179
 xs:11.4142
 i:11.2548
 len:11.2435
 ?:10.9926
 x:10.9627
 go:10.7089
 _):10.4806
_,:10.48
  :10.4352
 Int:10.4088
 ,:10.2744
 acc:9.62158
 default:9.58943
 ~:9.49013

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
4:23.702
5:19.433
0:18.556
9:18.1369
1:17.4212
6:17.1634
7:16.9519
8:16.453
3:16.4414
2:15.893

:13.8659
 _:13.6011
)):12.9931
 _,:12.7504
 -:12.633
 >:12.5023
 ?:12.2985
 ,:11.8618
))):11.7521
 #:11.742
 n:11.6533

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <4>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 4
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 4
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.8771
 ,:12.7899
2:12.71
0:11.9841
 +:11.3007
),:10.9668
)):10.9053
+:10.9037
 :10.455
)))):10.4245

:10.2945
5:10.2502
9:10.0319
):10.0279
..:10.0073
4:9.95693
...:9.92709
 ...:9.90002
1:9.84055
,,:9.83582
3:9.69147

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:15.2559
 id:12.7214
 const:10.4608
 (:10.4419
 :10.1815
 f:10.1047

:10.0827
fun:9.99649
 go:9.96134
 fail:9.84204
 h:9.72617
 _:9.55061
 function:9.52199
 t:9.48621
 ?:9.46733
 \:9.39567
 cons:9.38012
 error:9.3109
 []:8.99513
 List:8.99026
 x:8.78842

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:17.8043
 _:15.9494
 y:13.1101
 xs:12.5517
 (:12.5043
 l:11.5168
 t:11.4884
 (_:11.4413
 :11.374
 z:11.3572
 a:11.3465
 [:11.2489
 acc:10.8893
 h:10.8816
 i:10.7055
 f:10.6317
(:10.4918
 ():10.4892
x:10.4401
 id:10.3332
 ->:10.2643

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:17.9524
->:14.2708
 y:13.7152
 xs:13.1393
 =>:12.9664
 _:12.405
 acc:11.9193
 x:11.564
,:11.4192
 t:11.2561
xs:10.9368
 h:10.9146
 :10.4453
 -:9.91962
 xx:9.83021
_:9.80515
 :::9.75066
1:9.63844
 =:9.63294
 ts:9.61822
:::9.58008

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:14.1313
 []:13.4122
 [:13.2309
 xs:12.5808
 id:12.3493
 (:11.3484
 :11.0665
 h:11.0102
 t:10.9743
 rev:10.9248

:10.5542
 ([:10.5251
 go:10.4562
 ts:10.1086
 let:10.0624
 List:9.82971
 [(:9.43348
 _:9.4289
 [_:9.35183
 f:9.21789
 ((:9.06149

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
:::16.3873
 :::14.371
 @:12.7902
s:11.6345
::11.4285
[:11.3032
)))):11.2096
)):11.1312
xs:10.8059
):10.7086
@:10.5481
 ::10.3093
 $:9.98939
 :9.8895

:9.63873
.:9.46932
))):9.39832
h:9.29326
 +:9.20392
x:9.05558
 xs:9.04424

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:16.9918
)))):13.1287
[:13.044
)):12.4108
):12.0977

:12.0065
@:11.9293
 :11.6707
 ):11.5268
 :::11.4946
:::11.1459
 +:10.6271
.:10.4983
 $:10.4449
[@:10.3626
 [:10.219
))):9.6504
 ::9.48601
 ...:9.35116
 |:9.20645
[::9.10595

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:14.3682
 x:13.828
 xs:12.816
 []:12.7151
 id:12.3052
 (:11.9147
 ts:11.6072
 t:11.5241
 y:10.9815
 ([:10.8628
 :10.4449
[:10.4193
 go:10.3885
 h:10.3084
 [(:10.1941
 [_:10.0021
 [":9.52643

:9.35833
 rev:9.34973
 ((:9.2886
 [[:9.27275

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):14.0673
x:13.7008
hd:12.6714
xs:12.4389
(":11.856
T:11.8124
1:9.53707
t:9.49386
0:9.22026
 x:9.20803
5:9.09176
 ]:8.95956
(':8.77739
4:8.72364
remove:8.67073
[]:8.66941
d:8.61733
 (":8.59275
head:8.58834
ts:8.5865
[":8.47943

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:13.8728
 ):13.7816
 :13.3452
@:12.097
  :11.6743

:11.5303
))):11.493
)))):10.515
 :::10.4805
:::10.4782
   :10.4393
 end:9.28211
    :9.06342
 ::9.00391
 .:8.69073
 (@:8.60552
 ),:8.49968
     :8.31468
 x:8.25059
 $:8.06346
@@:8.03402

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:15.6478
 x:15.2193
 []:13.105
 ts:12.9521
 [:12.7855
xs:11.8631
 y:11.7625
 t:11.557
 (:10.8229
 :10.8124
[]:10.631
 id:10.3471
x:9.98613
 ):9.98195
 xx:9.82069

:9.68433
[:9.4827
):9.37763
[]):9.32736
 z:9.21854
)):9.17006

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
):15.1787
)):15.0879
)))):14.9227
 ):13.5238
))):12.833
 :12.3986
 @:10.7588
)),:9.60366

:9.59485
)[:9.37233
@:9.19489
[:9.15432
[@:8.94069
  :8.82941
)(:8.7864
),:8.7837
)]:8.62678
).:8.53493
)));:8.43915
))]:8.24336
 :::8.21521

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:15.1212
 id:12.994
 end:12.3544
 :12.2219
 ):11.4087
  :10.8136
 x:10.5917
 (:10.2985
 xs:10.2293
   :10.0807
id:9.90381
 in:9.51715
 ,:9.40701
    :9.36678
                :9.12351
     :9.06799
 _:8.98618
 idx:8.94161
 ?:8.85306
      :8.84451
 @:8.8128

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
          :17.4164
           :14.4657
            :12.2452
         :12.204
     :11.6032
                :11.5075
       :11.5068
             :11.2583
      :11.1189
   :11.0572

:10.5861
	:10.5403
        :10.4854
              :10.4787
               :10.4727
 :10.114
  :10.0196
)))):9.90576
    :9.75944
end:9.13793
)):9.13342

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
          

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
          
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 (:17.1535
 id:16.5448
 go:13.6329
 end:13.3932
 ([:13.3848
 (_:13.1353
)))):13.0482
 []:12.6133
 xs:12.5441
 x:12.4266
 fun:12.0991
 fail:12.0989
 ((:12.0376
 nil:11.9008
 identity:11.87
 _:11.6685
 ():11.6113
 raise:11.5815
 [:11.5593
 ...:11.5481
 acc:11.3654

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:14.1276
fun:12.9765
xs:12.6111
id:12.5978
x:10.6219
[]:10.1827
 go:10.1619
error:9.63331
rev:9.52473
)):9.21036
)))):9.11145
fn:8.81181
let:8.66566
if:8.60773

:8.57056
_,:8.48759
raise:8.4671
List:8.4469
case:8.40796
 id:8.26137
0:8.25498

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:18.463
 (:12.3008
 idx:12.0114
((:11.4735
(-:11.1977
)))):11.1437
(_:10.5538
.:10.4732
 :10.4546
)):10.2838
[:10.0043
 x:9.9766
 xs:9.94093

:9.72095
([:9.71272
,:9.60905
_:9.46116
(...:9.40326
():9.32413
 id:9.3232
 _:9.26404

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:18.0496
xs:13.4926
 idx:12.8125
0:12.7822
1:12.5649
go:10.8313
id:10.8161

:10.3237
i:10.3128
x:10.2257
4:9.99192
len:9.72701
2:9.54257
5:9.52825
+:9.52108
ix:9.17188
3:9.11393
_,:9.09519
 :8.95337
ids:8.92077
n:8.89633

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.936
 -:13.9839
 +:13.0246
 ,:12.1803
-:11.753
+:10.9796
),:10.8555
)):10.6027
)))):10.2949
):10.1051
.:10.0236
 :9.92524
(:9.83764
,,:9.29037
))):9.21193
,(:9.0692
,-:9.00831

:8.92534
1:8.77423
 xs:8.61956
 =:8.60021

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :17.2585
 _,:13.7484
5:13.694
 idx:13.2693
 -:12.6659
 n:12.4381
 _:11.913
 go:11.4509
 len:11.1673
  :10.8855
 ?:10.8586
 i:10.7604
 xs:10.7409
 x:10.1928
 ,:9.95201
 Int:9.94523
 length:9.89797
 _):9.88568
 id:9.78146
_,:9.45658
 (:9.36728

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
5:24.629
1:19.1837
6:18.9442
0:18.8451
4:17.8713
9:17.8092
7:17.7284
8:17.576
2:16.197
3:16.1077

:14.7637
)):13.002
 _:12.0752
 >:11.8474
 -:11.7788
 #:11.4588
 ,:11.3541
))):11.337
 ?:11.2791
]):11.2523
 //:11.0422

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <5>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 5
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 5
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.124
 ,:13.2304
0:12.2151
 +:11.07
 :10.4446

:10.4312
1:10.4138
5:10.3497
+:10.3454
,[:10.0194
),:10.0046
):9.77424
)):9.7634
6:9.60653
 x:9.4213
 id:9.41635
4:9.41515
...:9.31704
 [:9.30394
,,:9.27196
 -:9.21536

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:16.0339
 id:12.4555
fun:11.0626
 :10.6536

:10.5891
 (:10.5391
 go:10.503
 f:10.0015
 const:9.67746
 _:9.54615
 function:9.53741
 xs:9.5273
 rev:9.48936
 \:9.31973
 h:9.29724
 t:9.2012
 ?:9.11222
 List:9.08439
 cons:9.03237
 fail:8.9233
 [:8.91482

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:18.6188
 _:15.3743
 y:13.1046
 xs:12.7555
 (:12.2873
 l:11.7944
 :11.652
 z:11.5245
 t:11.4803
 [:11.4584
 a:11.3695
 (_:10.9128
x:10.7927
 h:10.7235
 i:10.548
(:10.4996
 acc:10.4233
 n:10.3749
 ->:10.3124
 f:10.1676
 s:10.0992

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.4972
->:14.3398
 =>:12.8914
 y:12.7023
 xs:12.6447
 _:11.592
 x:11.3947
,:11.2355
 t:10.9777
 acc:10.8799
 :10.7545
xs:10.7214
1:10.6851
 h:10.391
 -:9.95595
_:9.81332
 :::9.70755
 =:9.53463

:9.49428
:::9.40911
 xx:9.33961

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:15.319
 [:13.6849
 xs:13.5259
 []:12.7498
 id:11.9295
 (:11.6513
 :11.3648
 ([:11.098

:10.9678
 t:10.7345
 rev:10.6025
 h:10.5053
 ts:10.2821
 go:10.1877
 let:9.7994
 List:9.68227
 ():9.59817
 _:9.50651
 ((:9.4951
 [(:9.4597
 idx:9.24622

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
:::16.727
 :::14.4207
 @:13.2542
[:11.9647
xs:11.6815
::11.3894
s:11.2633
):11.2046
)))):11.2035
)):11.0982
@:10.5614
 ::10.5155
x:10.3866
 +:10.2224
 $:10.128

:10.0354
h:9.93509
1:9.68501
))):9.57022
.:9.44193
 xs:9.40441

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.1241
@:12.9223
[:12.2468
)))):11.8098
 :11.6186
):11.3139

:11.1827
)):10.9153
[@:10.3174
 ):10.2197
@@:10.0639
 +:9.94026
 [:9.82134
 :::9.68766
 $:9.6514
.:9.43826
 *:9.35869
 x:9.28687
:::9.26889
[]:9.12386
1:9.10007

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:15.8417
 x:15.0539
 xs:14.3561
 []:14.0234
 ts:12.8234
 (:12.3409
 ([:11.8344
 :11.332
 [(:11.3093
 y:11.2699
 id:11.0257
 h:10.998
 t:10.8815
[:10.7299
 [_:10.7251
 [[:10.4148
 ():10.3698
 [":10.2664
 ((:9.96273
 _:9.96152

:9.57369

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
x:13.9715
]):13.5894
hd:12.9551
xs:12.0823
T:11.9157
1:11.0641
(":10.8394
[]:9.77948
 ]:9.60653
d:9.36156
 x:9.296
0:9.28468
t:8.95698
():8.94147
].:8.87666
](:8.78388
[":8.74282
(':8.58518
true:8.5768
2:8.54667
 xs:8.47942

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:17.0685
 ):13.2073
 end:12.6131

:12.1954
 :12.0647
@:11.6418
))):10.5939
)))):10.4409
 x:10.0461
  :9.78444
 +:8.86273
   :8.7764
 .:8.6856
 :::8.61072
 xs:8.49557
    :8.40339
 ),:8.37945
 id:8.32662
:::8.22456
 $:8.12714
 ...:8.11105

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:16.0906
 x:15.3862
 [:14.0919
 []:13.9936
 ts:12.8796
 (:11.8045
 y:11.5486
xs:11.2362
 t:11.229
 :11.0726
[]:10.9618
[:10.356
 ():10.1937
 ):9.91601
 id:9.84017
 ([:9.82742
 xx:9.52731
[]):9.42627

:9.38608
 z:9.33428
):9.2841

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:15.0958
):14.4373
)))):14.201
)):13.6176
 ):12.6684
 :11.4886

:11.2532
@:11.1507
))):10.7804
[:8.80157
)[:8.75231
.:8.64273
 ...:8.58363
2:8.45826
)),:8.4407
 *:8.42645
  :8.41271
)(:8.36448
 .:8.27461
 +:8.24922
[@:8.19521

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:15.657
 xs:15.6357
 x:15.3409
 []:14.7452
 ts:12.4372
[]):11.9054
[:11.2806
[]:11.2609
xs:11.0782
 (:11.0751
 :11.0457
 t:10.9996
 [(:10.8933
 y:10.8571
 [[:10.4334

:10.193
 ([:9.99366
 xx:9.91492
 ):9.68532
 _):9.42029
 [_:9.11243

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):16.8494
x:13.5461
T:12.0748
hd:12.0091
xs:11.3508
1:10.2564
 ]:10.0945
])):10.032
[]:9.39522
t:9.28297
0:9.19578
...:8.95951
 x:8.7828
(":8.74164
](:8.68863
].:8.5914
[":8.56726
)))):8.45782
2:8.44983
 :8.43517
5:8.40456

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:15.1875
 ):14.5669
 :12.9591
 end:12.8715
))):12.276

:12.0624
@:11.9878
)))):11.4147
  :10.6714
 x:9.32671
   :9.1151
 +:9.0543
 .:8.99365
:::8.82256
 ),:8.74254
 at:8.43257
 :::8.08917
    :8.06247
 xs:8.051
 );:8.04742
 ::8.02141

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:16.8372
 x:15.0507
 [:13.261
xs:13.2449
 ts:12.7886
 []:12.1758
 :11.3503
 (:10.7805
 t:10.7125
 y:10.5719
 ):10.4629
x:10.3306

:10.2869
[:10.2064
):9.97507
 id:9.79448
[]):9.72584
[]:9.67689
 xx:9.25996
 idx:9.18042
 _):8.98823

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
):15.8793
)))):15.1706
)):14.8715
 ):13.6037
))):12.0972
 :12.0055
 @:11.7001

:10.551
)),:9.53133
@:9.43542
)[:9.32991
)]:9.31478
),:9.28737
)(:9.17727
).:8.98465
  :8.97077
 .:8.95234
 end:8.74161
);:8.68012
)`:8.5755
.:8.5269

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:15.4005
 id:13.0055
 end:12.611
 :12.0047
 ):11.081
  :10.7521
 x:10.7209
 (:10.432
   :10.1331
id:10.0637
 xs:9.907
 in:9.82437
    :9.66004
 ,:9.58367
 []:9.12174
end:9.10303
       :9.0995
                :9.07105
     :9.02277
      :8.96016
            :8.79681

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
           :17.8816
            :14.0333
          :13.2756
      :12.5606
             :12.4615
        :12.3339
       :12.2757
                :12.1989
         :12.1849
     :11.5436
              :11.4498
    :11.2676

:11.0762
	:11.0746
   :11.0644
  :10.8039
               :10.6784
)))):10.2913
 :9.70104
)):9.50701
(:9.39115

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
           

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
           
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 (:16.6451
 id:16.1645
 (_:13.2232
 end:13.0915
 go:12.8631
)))):12.4816
 ([:12.4007
 []:12.2061
 x:12.1104
 fail:12.0345
 xs:11.9468
 fun:11.9216
 _:11.5886
 ():11.5851
 nil:11.3426
 ((:11.2342
 raise:11.0634
 undefined:11.0196
 ...:10.9791
 acc:10.8626
 (\:10.8237

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:14.2599
fun:12.8671
id:12.7202
xs:12.5629
x:10.5532
[]:10.4315
error:10.1018
 go:10.0204
)))):9.52005
)):9.51349
rev:9.39462
fn:8.78447
raise:8.774

:8.75436
let:8.72118
assert:8.61386
if:8.4932
_,:8.43572
0:8.35829
fail:8.31154
pan:8.27903

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:18.3803
 (:12.0652
)))):11.7502
 idx:11.7078
(-:11.1742
.:11.1219
 :11.0118
((:10.885
)):10.5171

:10.0217
(_:10.0208
[:9.92296
 :::9.90446
,:9.8651
([:9.70341
 xs:9.52322
():9.5013
 _:9.4058
):9.31389
)(:9.31002
_:9.28741

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:18.0913
xs:13.3951
 idx:12.9442
0:12.9147
1:12.3992
id:10.9653

:10.738
go:10.5536
2:10.544
x:10.0484
i:10.0316
5:10.0126
4:9.95098
6:9.91573
len:9.30671
3:9.19963
ix:9.1922
 :9.15095
_,:9.10679
ids:9.00301
+:8.80548

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.9307
 -:12.7654
 +:12.1498
 ,:11.7222
)))):11.2672
)):10.8051
):10.2997
(:10.1427
 :10.1415
-:10.1326
.:9.99103
+:9.95554
),:9.8931
))):9.57144
 xs:9.54429

:9.15532
 =:9.07772
,,:8.88237
...:8.75291
 (:8.73273
 x:8.44858

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :17.2147
6:13.2861
 idx:13.0612
 _,:12.8665
 -:12.3741
 n:11.9157
 _:11.5324
 go:11.1871
 xs:11.004
  :10.771
 Int:10.6186
 ?:10.4543
 len:10.4529
 length:10.2722
 i:10.1563
 ,:9.95972
 id:9.84273
 x:9.68699
 _):9.48768
 (:9.43769
1:9.40746

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
6:24.5448
1:19.7972
7:19.3588
0:19.0335
9:18.4247
8:18.0772
2:17.9424
5:17.6239
3:17.3505
4:16.2806

:14.2057
)):13.8627
))):12.4918
 _:12.3554
 -:11.9601
 >:11.7713
)))):11.7548
 ?:11.6316
 idx:11.6216
 #:11.5349
]):11.4321

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <6>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 6
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 6
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.9763
 ,:13.047
,[:10.3682
0:10.3622
 +:10.298
 :10.1432

:10.1402
)):10.0975
6:10.0055
 id:9.65697
+:9.65683
7:9.6334
):9.44788
),:9.43901
 x:9.41016
 ...:9.39578
 -:9.22999
)))):9.18786
x:9.13518
 [:9.13416
 (:9.09489

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:16.1519
 id:12.6876
fun:11.3037
 :10.6727

:10.5799
 (:10.5766
 go:10.503
 f:9.63247
 _:9.60145
 function:9.38487
 xs:9.38485
 const:9.26144
 \:9.2092
 rev:9.18537
 ?:9.14323
 fail:8.98731
 [:8.97146
 identity:8.78098
 x:8.77454
 h:8.76624
 t:8.75151

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:18.7718
 _:14.96
 xs:12.451
 y:12.2553
 (:11.9798
 :11.5382
 l:11.3069
 z:11.0842
 a:11.0198
 t:10.9776
 [:10.9493
x:10.6877
 (_:10.4568
(:10.3747
 acc:10.2782
 i:10.1066
 n:10.1011
 ->:10.0954
 f:9.99888
 id:9.90579
 ():9.87886

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.4351
->:14.1999
 =>:12.3648
 xs:12.0854
 y:11.312
 x:11.2161
 _:11.059
,:10.7346
 t:10.6781
 :10.6179
 acc:10.3052
1:10.3032
xs:10.0923
 -:9.90459

:9.74697
 h:9.70155
_:9.53489
 $:9.4269
 idx:9.3974
 =:9.17379
 xx:9.04474

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:15.5283
 [:12.6327
 id:12.4855
 xs:12.349
 []:11.7206
 :11.3875

:11.1294
 (:11.1031
 rev:10.8866
 go:10.4987
 t:10.3354
 ([:10.0949
 let:9.76373
 List:9.72513
 h:9.65687
 idx:9.25791
 _:9.20961
 acc:9.15018
 ?:9.08131
 ts:9.02376
 todo:8.9924

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
:::15.8074
 :::13.9794
 @:12.6875
s:12.5327
xs:12.1912
)))):11.5123
):11.221
[:11.0822
)):11.0445
::10.8807
x:10.4518
 ::10.3452
 $:10.1799
 !:10.0043
))):9.88132

:9.85688
@:9.63826
1:9.46344
 s:9.46212
 +:9.39043
.:9.35689

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.3439
@:12.4024
)))):12.0123
 :11.5019
[:11.2324

:11.158
):11.1071
)):10.8784
[@:10.2147
 ):10.0931
 x:9.95395
 +:9.75539
 $:9.64507
 ...:9.52145
@@:9.30739
 :::9.12609
 *:9.07582
 [:9.05255
 ..:8.87146
(@:8.68049
:::8.67611

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:17.3441
 []:16.5902
 x:15.0302
 xs:14.1593
 ts:12.5583
[:11.4907
 :11.4888
 (:11.4844
 [(:11.0548
 ([:10.9143
 [[:10.7494
 ():10.6496
 t:10.5363
 [":10.5075
 y:10.4126

:10.1415
 h:10.0959
 [_:10.0396
 id:10.0129
xs:9.82892
[]:9.77278

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):14.3921
x:13.0061
T:12.0721
hd:11.7213
1:10.9736
 ]:10.8175
xs:10.7717
():10.0228
(":9.95374
]:9.64004
[]:9.49397
 x:9.25545
t:9.15506
...:9.10597
d:9.09373
0:9.06752
].:9.01817
](:8.85892
 :8.65591
[":8.52268
remove:8.4754

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.3032
 ):12.8831
@:11.9114
 :11.8119

:11.3569
 x:11.2743
 end:11.0378
)))):9.7748
 xs:9.5318
))):9.48425
  :9.38988
 $:8.88002
 ...:8.87296
 id:8.86869
 +:8.76763
 .:8.46272
 ..:8.20227
 *:8.17001
   :8.14429
 (:8.13193
 :::7.9906

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:17.7398
 []:15.0469
 x:14.5753
 [:14.0689
 ts:13.3059
 (:11.9127
xs:11.5269
 :11.2708
 y:10.9609
 ):10.7577
 Ts:10.2711
 id:10.159
 ():10.0313
 t:9.98993
 ([:9.9741

:9.79876
[:9.47993
[]:9.29885
 [(:9.23758
 [[:9.21982
 h:9.05092

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.4413
)))):14.3244
 ):13.4053
)):13.0959
):12.8856
 :12.5434
@:12.2052

:11.9321
))):10.4503
 +:10.1832
 end:9.72861
  :9.63079
 x:9.56491
[:9.53993
(@:9.29334
 ...:9.23278
 *:9.10042
1:9.04276
2:8.90777
 $:8.71546
[@:8.6364

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:18.0431
 []:17.5965
 x:15.0872
 xs:13.5758
 ts:13.0222
[:12.2383
 :11.9165
 ():11.7071
 Tod:11.6511
 [[:11.6465
 [(:11.5719
 (:11.4092
 ([:11.2796
[]:11.2763
 todo:11.2255
 y:11.1683
 [_:11.1252
 [],:10.8645
 ):10.7964

:10.7619
 [":10.5585

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):15.3046
x:13.0477
T:12.0061
 ]:11.4036
xs:11.2496
hd:11.1858
1:10.9201
[]:10.1521
]:9.96302
():9.75822
t:9.51342
0:9.33974
 x:9.33151
d:9.32662
].:9.20558
](:9.14993
@:9.11615
])):9.00927
2:8.78568
 xs:8.78214
 :8.77886

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.1647
 ):14.8904
 end:13.1948
 :12.6531

:12.2926
@:12.1785
 x:11.9758
)))):10.918
))):10.8821
  :10.3908
 xs:10.1633
 .:8.86717
 id:8.85061
 at:8.75585
   :8.75422
 (:8.64198
    :8.48598
 +:8.43924
 (@:8.39293
 ...:8.30028
 ),:8.24708

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:17.2352
 []:15.6917
 [:14.2989
 x:14.0803
 ts:12.7099
 (:11.3874
xs:11.3089
 ):11.0846
 :11.0705
 y:10.6877
 id:10.0975
 Ts:10.0702

:10.0065
 t:9.94544
 ():9.91939
[]:9.87549
 [(:9.53087
 ([:9.35461
[:9.35029
[]):9.34578
):9.23473

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:16.7445
 ):14.8712
)))):14.6695
):14.6261
)):14.2333
 :12.4686

:12.1956
@:11.596
))):11.5537
 end:10.1981
  :9.6073
 ...:9.58356
)),:9.45002
 *:9.01853
 .:8.97205
)]:8.96966
)`:8.81743
 x:8.79631
(@:8.78184
)(:8.77999
.:8.6052

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:16.9915
 []:16.5527
 xs:14.5147
 x:14.3106
[:12.3813
[]):12.3002
 ts:11.5607
[]:11.4501
 :11.2451
 [(:11.0762

:10.9756
xs:10.9213
 ([:10.8362
 ):10.7961
 (:10.7438
 [[:10.4488
 [_:10.3719
 y:10.2529
 t:10.1831
 xx:9.71947
 [],:9.61515

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):16.9765
x:13.3279
])):12.2143
 ]:11.6652
T:11.0863
xs:11.0327
]:10.6379
 x:10.3715
1:9.80275
hd:9.64355
 :9.4962
](:9.47572
 xs:9.39051
)))):9.0554
0:8.86386
t:8.79475
:::8.78625
...:8.73742

:8.56753
)):8.4754
].:8.35633

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:17.2623
 ):15.2262
 end:14.2642
@:12.9949
 :12.8044

:12.3302
 x:12.0453
 xs:11.3659
))):11.2008
)))):10.859
  :10.3658
 at:9.36443
xs:9.22007
end:9.00615
 ),:8.74809
   :8.67067
 ...:8.59058
 (:8.40583
 *:8.24139
 +:8.20466
:8.17947

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:17.4483
 x:14.5431
 [:13.5062
xs:13.2037
 []:13.1138
 ts:12.7811
 :11.3637

:10.9795
 ):10.7578
 (:10.6425
 id:10.5231
 t:10.3247
[:10.2306
 y:9.9781
x:9.41752
):9.26495
 _):9.20746
[]):9.09154
 xx:8.9696
 idx:8.94828
[]:8.94728

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
):15.7143
)))):15.0684
 ):14.8872
)):14.8015
))):12.3168
 :12.1874
 @:11.3674

:10.3688
)]:9.54468
)),:9.53191
@:9.45473
)[:9.20325
)(:9.0069
  :8.96415
),:8.84884
))]:8.62338
 :::8.59224
 end:8.55856
 .:8.48604
)`:8.32805
.:8.12784

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:15.7807
 end:13.1457
 id:12.8044
 ):12.7292
 :12.3651
  :11.1274
   :10.6363
 in:10.5757
 (:10.2387
            :10.2299
    :10.1823
 x:10.1693
                :10.1658
id:10.1339
 []:9.74426
     :9.71662
        :9.66226
       :9.6537
end:9.55475
      :9.49139
         :9.12546

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
            :17.9752
             :15.0211
           :12.7813
         :12.6191
)))):12.3955
       :12.279
              :12.1272
     :11.8264
                :11.818
               :11.6992
        :11.694

:11.2941
	:11.2768
          :11.1283
      :11.093
   :11.0045
    :10.5036
 :10.3503
)):10.2554
  :9.92637
):9.55143

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
            

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
            
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 (:17.0709
 id:15.9522
 end:13.2456
 []:13.2437
)))):12.8504
 (_:12.8021
 go:12.4593
 ([:12.3993
 x:11.9226
 fun:11.7558
 ():11.7192
 nil:11.6941
 identity:11.6418
 raise:11.5752
 xs:11.4701
 ((:11.455
 fail:11.4083
 ...:11.3413
 _:11.1895
 (\:11.1744
 let:11.0582

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:14.9017
fun:13.1395
id:12.9669
xs:12.426
x:10.503
 go:10.3303
[]:10.2132
error:10.0259
)):9.45258
)))):9.3999
let:9.29735

:9.05829
rev:8.97779
fn:8.92503
assert:8.89477
raise:8.85212
if:8.81591
0:8.58577
_,:8.44851
fail:8.41689
function:8.3364

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:18.6213
 idx:11.8036
 (:11.6907
)))):11.6786
.:10.7679
((:10.7565
 :10.621
[:10.4309
)):10.4307
([:10.3935
 x:9.95324
 xs:9.87715

:9.84101
():9.56784
,:9.49957
 :::9.42098
):9.39906
(-:9.38583
)(:9.36591
(_:9.23001
.(:9.17192

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:18.8581
 idx:13.356
xs:13.2983
0:12.6738
1:12.2835

:11.0206
id:10.8101
go:10.5005
2:10.4415
6:10.3034
4:10.2853
i:10.1802
x:10.1506
3:9.92236
7:9.69333
ix:9.60714
 :9.28334
_,:9.26857
ids:9.25821
5:9.22358
8:9.13173

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:17.9638
 ,:11.6284
 -:11.3457
,(:10.5779
(:10.5057
 +:10.3006
.:10.1467
-:9.88371
::9.79285
,":9.66144
,,:9.52053
,[:9.50752
[:9.24793
),:9.20642
 :8.83159
):8.77971
))):8.77241
..:8.72338

:8.66011
,-:8.51015
(),:8.50702

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :17.5444
7:13.5134
 idx:12.7521
 _,:12.1906
 -:12.1089
 n:11.6146
 _:10.8711
  :10.8063
 Int:10.5865
 xs:10.5327
 ?:10.4632
 go:10.3505
 len:10.1259
 length:10.0743
 i:9.85006
 id:9.63655
 ,:9.50811

:9.43257
1:9.39113
 x:9.29047
 acc:9.28504

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
7:24.4002
1:18.9811
8:18.648
0:18.2145
9:17.9008
6:17.4209
2:17.1211
4:16.4769
3:16.4731
5:15.4283

:14.4014
)):12.4892
 ?:11.855
 _:11.6822
 ):11.4085
 -:11.3502
 //:11.34
)))):11.1965
 idx:11.1546
 #:11.0589
 x:11.0103

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <7>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 7
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 7
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.1508
 ,:12.6773
,[:10.3761
)):10.3623

:10.1445
 :10.1202
0:9.99512
 +:9.89868
)))):9.87872
):9.54633
7:9.47964
+:9.27815
),:9.14241
 ...:9.11426
1:9.11129
...:8.80608
8:8.80318
 [:8.68014
 ):8.50424
,(:8.47097
))):8.45667

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:16.6151
 id:12.6785
fun:11.7603

:11.1133
 :11.0912
 go:10.752
 (:10.4539
 f:9.41773
 _:9.28837
 \:9.17677
 function:9.07447
 xs:8.92145
 ?:8.88893
 func:8.87774
 [:8.82068
 []:8.81874
 identity:8.70897
 const:8.66042
 x:8.63374
  :8.59528
 fail:8.58985

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:19.0739
 _:14.0434
 xs:12.0181
 y:11.548
 :11.3231
 (:11.2763
 l:10.701
x:10.6978
 z:10.6038
 a:10.5726
 t:10.4016
 acc:10.1371
 [:10.1103
(:9.82976
 n:9.7826

:9.7424
 f:9.66343
 ->:9.55583
 (_:9.53871
 id:9.52943
 ():9.50214

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.9618
->:14.2573
 =>:12.3841
 xs:11.3344
 x:11.0257
 :10.892
 _:10.6867
 y:10.2355

:10.2133
 t:10.1634
 acc:10.1493
 -:9.9169
,:9.90563
1:9.86862
_:9.49417
xs:9.45999
 =:9.40943
 idx:9.38214
 $:9.1326
 :9.04516
 id:9.03062

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:15.9874
 id:12.3565
 []:11.8424
 :11.6583
 [:11.5652
 xs:11.5282

:11.5273
 go:10.8925
 rev:10.7497
 (:10.6264
 t:9.72874
 List:9.71066
 let:9.65805
x:9.41534
 acc:9.12691
 ([:8.94641
 todo:8.90315
 ):8.85855
 h:8.84178
 fol:8.77928
 fail:8.75401

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:18.0475
:::15.0731
 :::13.2071
 @:12.0212
):10.8018
xs:10.2002

:10.0623
 ::9.94322
x:9.90108
::9.78322
)))):9.75933
 +:9.69131
)):9.4777
[:9.40635
@:9.38114
ss:9.37453
 s:9.27676
1:9.23017
z:9.11165
 ):9.10156
.:9.05431

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.6473
@:11.666
 :11.1282

:11.1203
)))):11.0459
):10.7708
 ):10.71
)):10.4444
[:10.2231
 +:10.1689
 x:10.1467
 $:9.94811
[@:9.55053
 ...:9.39154
 *:9.3238
 ..:8.62579
 :::8.61993
1:8.44694
(@:8.41399
:::8.37536
))):8.37255

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:18.7126
 []:16.0897
 x:14.6432
 xs:12.8129
[:11.6496
 :11.4337
 ts:11.14
 t:10.8619
 (:10.8217

:10.762
 ):10.4026
 ([:10.1971
 [[:10.1671
[]:10.0835
 id:9.9692
 y:9.9542
xs:9.89134
 [(:9.81537
 [],:9.78591
 ():9.64713
 [":9.59365

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):14.0412
x:12.6059
T:12.0763
 ]:11.7176
]:11.6795
():11.1259
hd:10.9002
xs:10.8473
1:10.5853
[]:9.92302
...:9.52661
t:9.5227
].:9.14269
 x:9.09603
0:9.0109
](:8.69147
idx:8.57892
 :8.56864
d:8.50107
@:8.42927
 xs:8.38192

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.1381
@:12.5108
 :11.8041
 ):11.7915

:11.7669
 x:10.939
 ...:9.8971
 end:9.63913
 +:9.24311
  :9.1719
 ..:9.0628
 $:8.97357
 *:8.7832
 .:8.73467
:8.72509
 ....:8.51144
)))):8.50638
 xs:8.45632
 ...):8.22563
))):8.2144
 at:8.1776

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:19.3083
 x:13.9844
 []:12.8679
 [:12.6256
xs:12.5832
 ts:11.5834
 :11.3992
 (:10.6929

:10.5123
 ):10.3769
 ...:10.2322
 y:9.81974
 id:9.69805
 t:9.44195
 ...):9.34242
):9.17992
 ws:9.13915
[:9.11346
 go:8.9049
 List:8.81147
 Ts:8.79645

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.2931
@:12.5953
 :12.4978
 ):12.1522
)))):12.0731
):11.9253

:11.7439
)):11.6852
 +:10.1797
 ...:10.0108
 x:9.92428
  :9.49676
))):9.29581
 *:8.98184
(@:8.96559
 ..:8.95965
 $:8.91808
   :8.34715
[:8.32006
 ....:8.299
 .:8.28764

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.4315
 []:15.9649
 x:13.5392
[:12.2599
 xs:11.8617
 :11.6319

:11.0181
 ts:10.6479
 todo:10.6052
 ):10.5981
 [],:10.5602
 Tod:10.4649
 ():10.4431
 [[:10.328
 ([:10.2854
 y:10.2617
 (:10.1779
 ...:10.0802
[]:9.92193
 t:9.91505
 id:9.57154

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):14.626
 ]:12.6114
]:12.5555
x:12.1741
T:11.707
():11.2495
1:10.7301
xs:10.5883
[]:9.83734
t:9.79286
hd:9.52235
0:9.44923
@:9.37589
](:9.17349
 :8.94695
].:8.92934
2:8.88402
idx:8.80989
 x:8.80397
3:8.68732
])):8.66155

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.4555
@:12.6523
 :12.4747

:12.0751
 ):11.9146
 x:11.5015
  :9.89053
 end:9.80801
 ...:9.48425
 +:9.46448
 xs:8.9354
:8.87543
 .:8.60057
 $:8.38383
 *:8.34989
   :8.33406
 (:8.2808
)))):8.273
 &:8.1849
 at:8.18251
    :8.12838

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:19.1565
 x:13.25
 []:13.093
 [:12.8107
xs:12.3275
 ts:11.7821
 :11.3601

:10.6185
 (:10.4866
 ):10.2283
 Ts:10.1172
 y:10.0921
 id:9.15491
 t:9.15036
 [(:8.76819
 ...:8.72498
 ws:8.65934
):8.46554
[:8.43322
 ():8.4214
 ids:8.41963

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.1984
 :13.0028
 ):12.928
):12.6452

:12.4667
@:12.2892
)))):12.2891
)):12.0035
 x:10.3081
 +:10.2882
 end:10.2012
  :9.87857
))):9.81866
 ...:9.76949
 *:9.21388
(@:8.92058
 &:8.88975
   :8.62621
 ..:8.58973
 $:8.4965
 #:8.46739

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.4093
 []:16.0132
 x:13.7287
 xs:12.8101
[:12.7184
 :11.9872

:11.5467
 ts:11.2356
 [],:11.1284
 id:10.837
 ([:10.7182
 ():10.5641
 ):10.5564
 y:10.431
 (:10.3509
 [[:10.3314
[]:10.2992
 [(:10.0367
 idx:9.93319
xs:9.93251
 t:9.75073

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):14.7531
]:13.0539
 ]:12.8726
x:12.2046
():11.0215
T:10.8481
xs:10.5892
1:10.3491
@:10.3423
t:9.5029
](:9.47124
0:9.32407
 x:9.18583
[]:9.14899
 :9.1289
])):9.01186
idx:8.90888
 xs:8.90339
4:8.86886
2:8.77257

:8.76577

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.0961
 :12.6701
@:12.5333

:12.466
 ):12.0693
 x:12.0463
 end:10.9614
 xs:10.8914
  :10.2222
 +:9.28418
:9.0047
 id:8.98052
 &:8.83675
 ...:8.83539
    :8.78347
   :8.72667
 *:8.6151
xs:8.57969
 (:8.56915
 .:8.41876
))):8.41648

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:18.6507
 x:13.7816
 []:13.2137
 [:13.109
xs:12.2152
 ts:11.9886
 :11.5172

:11.2664
 (:10.6756
 id:10.2718
 ):10.2227
 y:10.2206
 Ts:9.49572
 t:9.3439
 ws:8.82436
[:8.77777
):8.64769
 ds:8.58768
 ...:8.57561
 ids:8.57293
 [(:8.51937

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.0422
 ):13.9429
):13.618
 :13.4347

:13.3068
@:12.7348
)):12.6042
)))):12.5928
 end:10.8054
))):10.7514
  :10.6657
 ...:9.9839
 x:9.97524
 +:9.6073
 *:9.29777
   :9.14412
 ..:8.96788
 at:8.95709
 #:8.89354
)]:8.7937
 .:8.79268

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:17.5361
 []:16.4312
 x:14.0038
 xs:13.8712
[:12.5375
[]):12.4458

:11.7954
 :11.7461
[]:11.3012
xs:10.9703
 ):10.8793
 ts:10.4644
 (:10.4228
 ([:10.3594
 [(:10.314
 [],:10.1613
 y:10.057
 ():10.048
 t:9.75748
x:9.65914
 [_:9.5695

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):16.7862
 ]:12.8921
x:12.4223
]:12.3491
])):11.3382
T:10.4971
xs:10.3647

:9.88895
:::9.72294
](:9.67021
 :9.58829
...:9.34232
@:9.30762
 x:9.18389
1:9.06852
0:8.70332
 xs:8.6482
():8.63389
t:8.3964
4:8.29343
5:8.23311

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:17.6294
 ):13.924
 end:13.6242
@:13.34

:12.9431
 :12.7938
 x:11.733
  :10.3234
 xs:9.57195
))):9.48938
 at:9.48194
)))):9.0859
 ...:8.98616
 *:8.91442
end:8.83877
   :8.79385
 &:8.75927
 ..:8.49032
 (:8.38849
 #:8.37089
    :8.31809

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:17.6594
 x:14.5715
xs:13.4251
 [:12.8685

:12.3981
 ts:11.866
 :11.5709
 []:11.4813
 ):10.5137
 (:10.3648
[:9.74852
 y:9.65059
 id:9.48596
 t:9.33426
 ...:9.28713
x:9.25532
 ...):9.14308
):9.09355
  :8.75383
 _):8.51152
 idx:8.40518

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
):15.774
)))):14.6523
)):14.4594
 ):14.4061
))):12.1505
 :12.003
 @:11.172

:10.3269
),:9.45384
@:9.42487
)]:9.41947
)),:9.28725
))]:8.8427
)(:8.80054
  :8.71659
)));:8.31789
)`:8.31454
)[:8.20496
);:8.13355
 end:8.11869
 .:7.89528

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:

:15.9021
 end:13.2608
 ):12.511
 :12.1925
 id:12.0858
  :10.9904
 in:10.9631
                :10.937
   :10.4978
    :10.0308
end:9.98952
 (:9.76919
 x:9.71442
        :9.66277
id:9.66212
     :9.6016
       :9.55961
            :9.46509
              :9.40577
          :9.34561
           :9.34427

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
             :18.0227
              :13.4752
           :13.0027
            :12.7308
               :12.5887
                :12.5133

:11.4943
          :11.2486
       :11.1278
      :10.9741
	:10.9705
        :10.7921
         :10.7674
   :10.6336
)))):10.3537
    :10.2519
  :10.1313
):10.124
     :9.90049
 :9.76971
)):9.43008

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
             

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
             
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 (:17.0791
 id:16.2632
 []:13.5863
 end:13.1299
 (_:12.7454
 go:12.7228
)))):12.6758
 x:12.3439
 ([:12.3413
 fun:11.5521
 identity:11.552
 nil:11.5511
 fail:11.5215
 raise:11.4031
 ():11.3748
 _:11.3736
 xs:11.2313
 ((:11.1859
 ):11.1472
 #:11.14
 ...:11.0076

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
go:15.0081
fun:13.1614
id:12.8872
xs:12.4342
[]:10.5148
x:10.2681
 go:10.2545
error:9.96007
let:9.59394
)):9.58297
)))):9.55358

:9.31752
fn:9.09947
rev:9.08553
if:9.07709
assert:9.04989
raise:9.03715
0:8.81163
fail:8.54974
function:8.54736
f:8.38187

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
(:18.483
 (:11.4318
)))):11.2768

:10.29
.:10.2687
 :10.0594
 idx:10.0211
[:9.96874
((:9.95785
([:9.90332
(-:9.20121
():9.05185
 id:8.9962
.(:8.89801
 :::8.885
 xs:8.83684
)):8.80117
::8.78787
,:8.72408
)(:8.71477
(_:8.69373

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:18.8626
xs:13.5694
 idx:13.1532
0:12.7852
1:12.2562

:11.8072
id:11.2581
go:10.8984
8:10.6241
4:10.401
2:10.2728
i:10.2702
x:10.0653
7:9.94649
3:9.88577
5:9.83638
_,:9.81261
ix:9.58861
len:9.47595
 :9.36843
6:9.34862

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:19.1486
 -:12.5687
 ,:12.5391
-:11.8194
.:11.6826
 +:11.0345
),:10.8798
)):10.761
,,:10.0036
 :9.94272

:9.91072
):9.84519
+:9.69477
)))):9.49189
))):9.45614
1:9.313
,(:9.30444
(:9.14752
::9.13618
,[:8.99722
,$:8.8773

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 :17.5143
8:13.325
 idx:12.2683
 -:12.0559
 _,:11.6381
 n:11.5102
  :10.9706
 go:10.7319
 ?:10.7043
 _:10.691
 Int:10.54
 xs:10.5115
 length:10.3406
 i:10.0749
 len:10.0313

:9.91778
 ,:9.62002
1:9.52946
 acc:9.40981
 id:9.39036
 x:9.11323

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
8:25.2499
1:19.741
9:19.5981
0:19.0822
2:17.8504
7:17.4273
3:17.1641
5:17.1167
6:17.053
4:16.8502

:15.1296
)):13.0128
 #:12.2044
 //:12.0873
 ):11.8731
 -:11.5402
 _:11.5137
 ?:11.3707
))):11.2179
)))):11.1354
]):11.0441

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <8>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: 8
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 8
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.6502
 ,:13.3281
0:10.7077
 :10.5392
)):10.5274
,[:10.4657
),:10.4279

:10.3831
 +:9.87756
1:9.81395
):9.76418
)))):9.61641
  :9.44727
))):9.39915
 ...:9.36054
 [:9.15712
+:8.95283
...:8.9255
 (:8.89847
 [],:8.78837
,,:8.66626

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8,

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:16.9045
 id:12.9173
fun:11.936

:11.771
 :11.6686
 (:10.516
 go:10.3275
 \:9.49966
 f:9.49158
 function:9.48872
  :9.34221
 _:9.18352
 func:9.05743
 ?:8.79777
 xs:8.78021
 let:8.77643
 identity:8.77146
 [:8.72196
 fn:8.55469
 _):8.49995
 x:8.48481

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ? ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 x:19.239
 _:13.7912
 xs:11.7916
 :11.4101
 (:11.2627
 y:11.1661
 l:10.7504
x:10.5993
 a:10.4834
 z:10.4494
 t:10.3515
 acc:10.0948

:10.0711
 [:9.90291
(:9.83314
 n:9.79341
 ():9.56263
 f:9.53936
 ->:9.4154
  :9.35748
 e:9.33472

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: ?, idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Broken pattern
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position RemoveTodo S ToggleTodo UpdateBuffer Width [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.1925
->:14.4746
 =>:12.5959
 xs:11.2544
 :11.095
 x:10.976

:10.6999
 _:10.4769
 acc:10.4066
 y:10.2048
 t:10.1612
1:10.0384
 -:9.85151
,:9.82624
 =:9.51235
 idx:9.48575
_:9.4388
 $:9.41929
 :9.24348
xs:9.19741
 id:9.01714

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:16.2577
 id:12.3463

:12.1771
 :12.1638
 xs:11.6764
 [:11.5317
 []:11.5302
 go:10.9636
 (:10.5723
 rev:10.4935
x:9.67183
 t:9.61221
 let:9.42082
 List:9.39588
  :9.22163
 ):9.20979
 todo:8.96238
 ...:8.94285
 remove:8.93394
xs:8.74808
 acc:8.73145

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> x

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x x
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
:::14.1071
s:13.6724
xs:12.6098
 :::12.5645
 @:11.4969
 $:10.4795
):10.4726
::9.87124
[:9.77815
ss:9.75039

:9.69912
x:9.55333
1:9.46973
 s:9.21467
)):9.21269
 ::9.19711
 xs:8.97245
_:8.95879
@:8.94121
)))):8.91664
d:8.84714

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.9883
@:11.91

:11.6641
 :11.5463
 ):11.1995
):11.0452
)))):10.6444
 x:10.3864
[:10.3851
)):10.3083
 $:10.2952
 +:10.2481
 ...:9.57882
 *:9.47746
[@:9.42268
 ..:8.85257
 :::8.59686
:::8.56396
 |:8.55551
@@:8.49397
 [:8.44363

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.0222
 []:15.5298
 x:14.8323
 xs:12.719
[:11.9984
 :11.789

:11.4954
 (:10.8002
 t:10.5672
 ):10.5142
 ([:10.3681
 ts:10.3403
 id:10.2916
 [[:10.1711
xs:10.1638
 ...:10.0354
[]:9.82218
x:9.73847
 [(:9.62821
 [],:9.44991
 [":9.3424

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):14.0458
x:13.2146
 ]:12.1578
]:11.9072
():11.5038
T:11.5008
xs:11.0677
hd:10.7613
1:10.6073
[]:10.279
...:9.81933
t:9.43906
 x:9.41473
0:9.35994
idx:9.12718
].:9.0987

:8.83473
](:8.80146
 :8.7671
d:8.64573
@:8.52772

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.4238
@:12.6029

:12.3212
 :12.0219
 ):11.7203
 x:10.6489
 ...:9.96362
 ..:9.5425
 end:9.41229
 +:9.31141
  :9.23785
 $:9.17891
 ....:9.0722
 *:9.0355
 .:9.00943
:8.5909
 ...):8.55976
 #:8.47268
 at:8.36196
 |:8.28348
 ::8.26004

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:19.8394
 x:14.1268
xs:13.2234
 [:12.3672
 :11.8697
 []:11.8575
 ...:11.3441

:11.2447
 ts:10.6503
 ...):10.5573
 ):10.3515
 (:10.2629
 ..:9.7651
 ws:9.42073
 id:9.3962
):9.32816
 y:9.19915
 t:9.15228
[:9.01754
 ....:8.77091
 \:8.75144

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.7981
@:12.8256
 :12.6161

:12.2633
 ):11.6958
):11.5079
)):11.282
)))):11.0418
 ...:10.6464
 +:9.91589
  :9.77026
 x:9.69762
 ..:9.66037
 ....:9.34758
 $:9.12413
(@:8.97191
 ...):8.94222
 *:8.87997
 .:8.72967
   :8.69978
 #:8.64778

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:20.147
 []:15.2084
 x:13.4042
[:12.6565
 :11.9165
 xs:11.8243

:11.4842
 ):10.7813
 ...:10.7077
 [[:10.1971
 [],:10.0991
 id:10.0162
 ([:9.9755
 (:9.8384
xs:9.83415
 [...]:9.79482
 t:9.70348
[]:9.5224
 y:9.44563
 [\:9.35489
 ts:9.27459

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):13.9844
]:13.2324
 ]:12.9819
x:12.1856
():11.6581
1:10.5652
T:10.523
xs:10.4739
[]:10.2059
](:9.47734
@:9.36249
t:9.34432
0:9.30005
 :9.22521

:9.09362
 x:8.98695
...:8.98099
idx:8.85458
].:8.75142
2:8.70132
4:8.52852

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.9691
@:12.6098
 :12.5514

:12.2898
 x:11.1476
 ):11.0667
 ...:10.213
  :9.80256
 +:9.75624
 .:9.06631
:8.92656
 $:8.74686
 *:8.66621
 ..:8.64571
 end:8.64197
 ...):8.58298
...:8.5787
   :8.44383
 xs:8.42914
 at:8.42152
 ....:8.36012

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:20.0535
xs:13.2217
 x:13.212
 [:12.5387
 []:12.2962
 :11.8405
 ts:11.5841

:11.3842
 ):10.1463
 ...:10.0469
 (:9.83059
 y:9.7625
 ws:9.51123
 Ts:9.20168
 t:9.12561
 ...):9.04424
 ls:8.78034
  :8.74215
):8.72523
 ds:8.7142
 \:8.66072

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.8457
 :13.1202
@:12.671

:12.5686
 ):11.6854
):11.4821
)):10.6517
)))):10.2352
 +:10.1436
 x:9.9971
 ...:9.98582
  :9.97231
 *:9.26385
 $:9.06474
 ..:8.94351
 #:8.87746
(@:8.7409
   :8.7019
 &:8.69037
 .:8.6772
 end:8.3934

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.9791
 []:15.1142
 x:13.3103
[:13.0456
 xs:12.2173
 :12.1751

:11.7722
 id:10.9028
 [],:10.4405
 ):10.4308
 ([:10.3205
 ts:10.1194
 [[:10.0797
xs:10.0508
 ():9.92031
 (:9.82898
 ...:9.74082
 t:9.54356
 y:9.5391
 [(:9.49319
[]:9.41784

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]:14.3429
]):13.6384
 ]:13.4509
x:12.1141
():11.9685
@:10.4245
1:10.3742
T:10.3652
xs:10.1912
[]:10.0634
 :9.48451
](:9.36014
 x:9.17411
0:9.09104

:9.05724
4:8.9338
t:8.82472
...:8.77287
idx:8.73629
 xs:8.71286
2:8.57426

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.8466
 :13.073

:12.8376
@:12.4599
 x:11.4554
 ):10.7372
  :10.4055
 ...:9.63828
 xs:9.57025
 +:9.54284
   :9.05359
:8.96172
 end:8.95995
    :8.88973
 *:8.81326
 $:8.79439
 &:8.60653
 .:8.50072
 #:8.49589
 @":8.37335
     :8.3262

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:19.8201
 x:13.1913
xs:12.7432
 [:12.472
 []:12.1688
 :12.0255

:11.5831
 ts:11.0829
 (:10.0565
 y:9.85242
 ):9.73789
 ws:9.46953
 ids:9.17763
 id:9.10336
 ...:8.99165
 Ts:8.90971
 ds:8.86135
  :8.8574
 ls:8.83702
 t:8.77958
 fs:8.737

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.4873
 :13.3664

:13.0158
@:12.5618
 ):12.4226
):12.3247
)):11.1028
)))):10.7406
  :10.401
 x:10.3048
 +:10.2252
 ...:9.49975
 *:9.33466
 &:9.15833
 end:9.10945
   :9.05101
 #:9.02395
))):8.90779
    :8.72762
(@:8.71231
 .:8.65396

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.8828
 []:16.0111
 x:13.9046
[:13.0218
 xs:12.8675
 :12.4583

:12.0029
 id:11.217
 ():10.9421
 ([:10.7279
 [],:10.6327
 ):10.6241
 (:10.3858
 ts:10.273
 [(:10.2483
xs:10.1219
[]:10.0214
 [[:10.0129
 y:9.92605
 [_:9.59973
  :9.54436

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]:14.2685
]):13.9405
 ]:13.197
x:12.3769
():11.3909
xs:11.1494
@:11.0056
T:10.5071
1:10.064
](:9.73908
[]:9.65081
 :9.32701
 xs:9.2898
t:9.23879

:9.1227
 x:9.03653
0:8.9206
2:8.7265
true:8.61337
4:8.5832
].:8.30776

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:19.377
 :12.758
@:12.6565

:12.6209
 x:11.96
 ):11.1751
  :10.4776
 xs:10.4226
 end:9.6708
    :9.54274
   :9.26813
 +:9.19863
 id:9.18231
:9.07263
 *:8.94267
 &:8.93435
 .:8.75057
 fun:8.62615
     :8.52057
xs:8.49033
 (:8.47393

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:19.0014
 x:13.7592
 [:13.0864
xs:12.9366
 []:12.8885

:12.0569
 :11.6903
 ts:10.8777
 (:10.1901
 id:9.9427
 y:9.81912
 ):9.74594
 ws:9.14499
 t:9.06334
[:8.92545
  :8.90057
 [(:8.72078
 ds:8.63226
 Ts:8.61372
 ...:8.53781
 ids:8.45385

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: xs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.1804
):13.7817

:13.6892
 ):13.5952
 :13.4431
@:13.0751
)):12.6656
)))):12.4166
))):10.6799
  :10.5995
 +:9.98855
 end:9.9216
 .:9.69452
 *:9.62249
 ...:9.48803
 x:9.30493
 #:9.25446
   :9.12871
 at:9.09342
 &:9.00437
)]:8.99991

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs @

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx go xs idx remove Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:17.5228
 []:16.1199
 xs:14.1401
 x:14.0866
[]):12.8979
[:12.4597

:12.045
 :11.682
xs:11.3463
[]:10.9222
 ):10.7529
 (:10.6727
 ([:10.4161
 ts:10.2084
 [(:9.86401
 ():9.85405
 [],:9.84234
 y:9.81891
x:9.6678
 t:9.63566
 [[:9.60182

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs @ [

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs @ ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: [
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
root ::= completions

Top 20 Logits:
]):17.5573
]:13.1959
x:12.888
 ]:12.5549
])):11.506
xs:10.7685
T:10.3343
 :9.77361
():9.58845

:9.58626
 x:9.37739
](:9.35812
@:9.30703
...:9.22428
1:8.80559
t:8.79372
 xs:8.72138
)):8.60089
):8.56646
[]:8.52707
].:8.43336

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs @ []

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Remove a todo item by its index #
let remove: (Int, [Todo]) -> [Todo]=
  fun idx, xs ->
    let go: (Int, Int, [Todo] -> [Todo] ) =
      if idx < 0 then idx else
        case xs
        | [] => idx
        | _::xs => 1 + idx end in
    let rec
      (go(idx, 0, id)
       (go(idx, 1, fun x -> [] @ xs)
        (go(idx, 2, fun x -> xs @ xs)
         (go(idx, 3, fun x -> xs @ [] )
          (go(idx, 4, fun x -> xs @ [] @ xs)
           (go(idx, 5, fun x -> xs @ [] @ xs @ [] @ xs)
            (go(idx, 6, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs)
             (go(idx, 7, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs)
              (go(idx, 8, fun x -> xs @ [] @ xs @ [] @ xs @ [] @ xs @ [] @ xs @ []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, go: (Int, Int, ([Todo] -> [Todo])), xs: [Todo], idx: Int, remove: ((Int, [Todo]) -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) ) ) ) ) ) ) ) = in in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 6, x xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  x xs @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound  
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 0, id))
Nature of error: Expected a constructor  
Error in term:
  x xs @ 
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 7, x xs @  @ xs @  @ xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  rec
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  1 + idx
Nature of error: Expecting type (Int, Int, ([Todo] -> [Todo])) but got inconsistent type Int  
Error in term:
  go((idx, 3, x xs @ ))
Nature of error: Expected a constructor  
Error in term:
  x xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  x xs @  @ xs @  @ xs @  @ xs
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go((idx, 1, x  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 2, x xs @ xs))
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go
Nature of error: Expected a constructor  
Error in term:
  go((idx, 5, x xs @  @ xs @  @ xs))
Nature of error: Expected a constructor  
Error in term:
  go((idx, 4, x xs @  @ xs))
Nature of error: Expected a constructor
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx xs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go idx idx if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi remove sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  xs ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 @:18.1143
 ):14.7256
@:13.7047
 end:13.3603

:12.7441
 :12.7295
 x:11.7955
  :10.2493
))):10.1284
 xs:10.0635
)))):9.50917
 at:9.19784
 *:9.11748
 $:8.84466
 &:8.77432
 #:8.71002
xs:8.69746
   :8.64951
 +:8.63024
end:8.55019
)):8.49298
