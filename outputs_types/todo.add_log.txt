
================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:16.6928
 fun:16.2102
 :15.7061
 model:13.8353
 Model:12.4303
 (:12.2548
 let:11.5619
 {:11.3454
 function:11.2087
  :11.1486
 s:11.0279
 f:10.5965
 fol:10.5582
    :10.2721
 h:10.2645
 Tod:10.1258
 t:10.065
 rev:10.0119
 todo:9.99018
 m:9.97502
 fn:9.85585

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 :19.4137
   :16.71
fun:15.7443
let:13.9126
 fun:12.9881
model:12.3598
  :12.2062
Model:11.5297
	:11.5254
       :11.3442
 let:11.2366
func:11.1891
     :11.1445
function:10.3053

:10.2652
#:10.1914
(:10.1896
{:10.0145
fn:9.95811
match:9.90848
    :9.86707

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
 

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Model -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Model -> [Todo])
  LSP: Convex: Target types: (Model -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:18.7287
 let:14.6821
 model:12.9874
 Model:11.4293
 (:11.4227
 f:11.3719
 fol:11.2719
 #:10.7177
 m:10.3903
 {:10.1052
 update:10.0788
 function:10.0128
 func:9.70712
 cons:9.70522
 todo:9.68232
 rev:9.6765
 mod:9.62428
 fn:9.62385
 lambda:9.57695
 cur:9.53995
 match:9.45806

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 model:16.6807
 (:16.552
 m:16.4661
 {:14.114
 s:13.1134
 state:13.0351
 ({:12.9034
 buffer:12.6861
 x:12.457
 ((:12.4153
 buf:11.9614
 st:11.9356
 md:11.8966
 xs:11.8147
 t:11.3835
 todo:11.3563
 p:11.3431
 _:11.0675
 ms:10.9631
 Model:10.8975
 self:10.839

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:16.3596
,:12.9182
@:10.7223
->:10.5669
 =>:10.3861
 buffer:10.3699
::10.1887
 (:9.91982
 x:9.79173
 state:9.78517
 _:9.7807
 =:9.75846
$:9.7115
_:9.69378
 acc:9.69116
 xs:9.61155
 m:9.41398
 s:9.41206
 :9.24754
 t:9.2376
 todo:9.14156

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] add case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "add" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:16.9821
 :14.4534
 model:14.1667
 t:13.7186
 (:13.5338
 let:13.4512
 [:13.0974
 rev:13.0404
 cons:12.5397
 s:12.3232
 case:12.2595
 [(:11.852
 match:11.7825
 [":11.5816
 (":11.5709
 h:11.417
  :11.4098
 {:11.3935
 n:11.0857
 ([:11.0273
 f:10.8423

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] add case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "add" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :16.6774
model:13.6635
case:13.319
let:13.2266
match:13.0162
 :12.2708
List:12.0884
if:11.8766
     :11.6616
t:11.3754
cons:11.0482
fold:10.9804
    :10.9041
rev:10.8714
[:10.8623
hd:10.7331
Model:10.7208
  :10.6613
       :10.5855
s:10.4017
(:10.4013

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
   

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Model -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
Todo <= [Todo]
Todo <= [Todo]
  LSP: Convex: Target types: Todo, [Todo]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( [ [] add case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "add" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 case:16.7544
 let:16.6454
 match:15.227
 if:14.5634
 (:13.2077
 cons:13.0853
 model:13.0608
 rev:12.9172
 t:12.2721
 fol:12.0879
 [:12.0201
 h:11.9386
 Tod:11.7139
 #:11.657
 [(:11.6461
 List:11.3341
 n:11.1688
 {:10.815
 todo:10.7318
 ([:10.6707
 [":10.524

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 model:15.115
 h:13.7885
 rev:12.2943
 (:12.1093
 n:11.8477
 t:11.6124
 Tod:11.3953
 String:11.1072
 s:10.9612
 is:10.5085
 let:10.1604
 reverse:10.1432
 string:10.0539
 !:9.90004
 fol:9.78656
 Model:9.7629
 List:9.64354
 bool:9.52623
 cons:9.49896
 split:9.49886
 length:9.35114

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: model
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: model add Model.init Model.eq Todo.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AddTodo AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Model.eq Model.init Opacity Outline Overflow Padding Position RemoveTodo S Todo.eq ToggleTodo UpdateBuffer Width [ [] abs abs_float acos add asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod model nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:16.6397
 of:14.752
 :14.5966
.:13.8702
 with:12.2913
,:12.0906
 |:11.8162
 {:11.7348
.$:11.5024
  :11.4505
 in:11.0439
._:11.0359
 $:11.0091
 f:10.997
::10.9259
 ?:10.8487
[:10.5385
 t:10.508
$:10.446
 #:10.3762
#:10.1399

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model


Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.2102
     :15.2313
 :13.472
|:13.2109
       :13.0737
    :13.0722
  :12.6376
#:11.8026

:11.7779
	:11.4385
      :11.0415
         :10.6691
        :10.4802
 |:10.3289
in:9.93435
let:9.78722
           :9.55139
                :9.26783
s:9.05861
if:8.95782
             :8.63562

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
   

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Model
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.1234
 #:14.4872
 let:12.1181
 !:11.919
 when:11.8336
 length:11.5982
 {:11.5356
 ":11.5144
 (:11.3997
 [":11.3744
 $:11.3592
 ~:11.3374
 @:11.3185
 if:11.3139
 [:11.261
 match:11.1197
 #[:11.1057
 //:11.0091
 rev:10.9498
 s:10.9033
 `:10.7817

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    |

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 (:17.0402
 _,:14.1616
 buf:13.73
 buffer:13.7126
 "",:13.3733
 desc:13.0384
 b:12.9137
 (":12.5434
 s:12.2021
 str:12.1786
 _:12.1702
 (_:12.0961
 d:12.002
 description:11.9055
 [],:11.8398
 txt:11.3717
 "":11.3684
 ":11.291
 x:11.2887
 ([:11.1539
 text:11.0253

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
buffer:16.7716
buf:15.5416
desc:15.5269
b:15.163
d:15.1019
description:14.4825
_,:14.2662
buff:13.4768
text:13.286
des:13.2548
input:12.9594
txt:12.8383
s:12.7241
x:12.0643
str:11.9802
new:11.8764
t:11.8021
bd:11.3732
xs:10.6375
name:10.4607
msg:10.4002

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:18.0704
_:13.6215
_,:13.2734
:::12.4878
 $:12.1484
 @:11.4895
 ,:11.2924
::11.2866
,[:11.0881
 as:10.9949
 =:10.8319
$,:10.7286
',:10.6744
@:10.5481
 &:10.4166
,":10.2938
,,:10.1341
 :::10.1261
 ^:9.94727
 +:9.77406
1:9.76643

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
text:15.4013
str:14.8727
content:14.4146
value:14.179
desc:14.01
description:13.9905
string:13.3859
model:12.7369
txt:12.7364
val:12.699
t:12.2086
input:12.173
contents:12.0701
state:11.9283
s:11.8429
d:11.589
data:11.5168
x:10.8571
name:10.8514
new:10.634
des:10.6265

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:17.1031
 $:12.2273
::11.1969
_,:11.1649
 as:10.9092
 @:10.8957
 &:10.69
_:10.5518
:::10.5266
,[:10.4104
 ,:10.3938
 =:10.2528
s:10.0022
$,:9.82682
 ::9.67521
(),:9.66426
@:9.57321
),:9.53593
 :::9.51361
,,:9.24714
 $$:9.20741

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
value:12.7877
content:12.2947
input:12.0508
str:11.5459
val:11.4053
field:11.4042
box:11.3381
t:11.0717
model:11.018
string:10.8691
state:10.6796
0:10.2221
1:10.1852
in:10.1587
un:10.064
data:10.0603
length:9.92475
s:9.90784
description:9.76677
to:9.71292
v:9.68914

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:15.5325
 $:11.2077
:::10.8822
_,:10.6087
 @:10.4272
 as:10.4239
$,:9.92778
(),:9.8644
),:9.85804
_:9.84712
::9.81567
 ,:9.62673
(:9.60573
 :::9.39059
@:9.35786
 +:9.26634
 =:9.20541
 &:9.18493
',:9.10294
$:8.78856
 =>:8.62667

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:11.4784
model:11.0093
input:10.9835
string:10.8849
str:10.8267
t:10.7514
1:10.6926
here:10.5644
of:10.2126
x:10.1665
content:10.0155
s:10.0102
get:9.97292
buffer:9.96013
id:9.92792
name:9.8734
as:9.86801
field:9.80074
v:9.75917
state:9.72315
description:9.66358

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:14.1403
0:11.509
_:10.7293
1:10.6918
 as:10.5521
_,:10.543
@:9.75035
 @:9.71691
3:9.38121
::9.13358
:::9.08473
 ,:9.02048
4:9.01753
2:8.99413
__:8.96207
$:8.95999
5:8.94178
$,:8.89062
8:8.88385
.:8.79755
6:8.78458

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_00

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_00
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_00>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_00: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_00
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_00
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:14.6399
1:14.2332
,:13.6096
3:13.5641
5:13.2222
4:12.9685
2:12.9352
7:12.6285
6:12.4946
8:12.2271
9:11.776
 as:11.3401
__:11.1695
_:10.4837
_,:10.475
 ,:10.1134
a:9.88047
d:9.6383
b:9.58338
@:9.25571
::9.1828

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_000

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_000
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_000>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_000: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_000
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_000
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:13.4865
1:12.7509
0:12.697
3:11.9681
4:11.443
2:11.4014
_,:11.2912
 as:11.2816
5:11.0763
7:10.7434
8:10.5544
6:10.4687
9:10.0491
__:9.5239
@:9.11806
$,:9.0539
_:9.04617
a:8.90139
 @:8.84058
#,:8.81671
 ,:8.78568

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:14.3195
_:10.2488
_,:10.2455
0:9.95515
2:9.93482
3:9.92373
1:9.83067
:::9.81424
8:9.77581
 as:9.77359
4:9.73107
5:9.69166
::9.67397
@:9.64358
6:9.61125
7:9.50409
 $:9.43296
$,:9.3755
 @:9.35784
9:9.27519
$:9.20701

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:11.1247
1:10.3722
input:9.62718
2:9.31654
ref:9.24135
3:9.22485
$:9.16842
5:9.10634
t:9.04848
un:8.96391
4:8.92997
id:8.88711
add:8.68564
model:8.56821
int:8.51664
f:8.4721
r:8.41693
arg:8.39359
value:8.38537
temp:8.3482
new:8.34734

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:14.8952
,:13.8666
_,:12.6005
1:12.4981
 as:11.9438
3:11.5981
8:11.1038
4:11.1
5:11.084
2:11.0237
_:10.8959
6:10.8441
7:10.8308
9:10.8035
@:10.3101
x:10.0475
f:9.81827
 @:9.70914
__:9.20874
::9.17982
$,:8.91003

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_00

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_00
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_00>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_00: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_00
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_00
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:17.4837
1:15.9078
3:15.2532
4:14.6781
2:14.6514
5:14.4686
6:14.2657
,:14.1348
7:14.1314
8:13.8346
9:13.3985
_:12.002
_,:11.2283
e:10.8325
d:10.6961
a:10.6925
 as:10.6287
b:10.5235
c:10.3029
x:10.208
f:10.2038

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_000

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_000
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_000>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_000: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_000
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_000
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:16.917
1:16.7635
0:16.4979
3:16.398
2:15.7729
4:15.5179
5:15.3162
7:14.8815
6:14.8214
8:14.3235
9:14.1766
_,:13.9419
b:12.2397
a:12.2281
d:12.0514
A:12.0445
 as:12.0243
_:11.9749
c:11.9271
f:11.9096
D:11.6432

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:15.2489
_:12.2813
_,:11.8761
 as:9.96415
 $:9.6421
@:9.50245
$:9.39533
 @:9.37316
),:9.11388
0:9.10667
:::9.01325
__:8.99241
$,:8.85711
::8.79791
 ,:8.61403
1:8.49604
2:8.22473
3:8.20473
(:8.15096
5:8.05311
4:7.89632

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:14.1984
2:11.1078
1:11.0539
5:10.4332
3:10.411
4:10.1088
6:9.83468
f:9.65027
7:9.57657
9:9.45685
8:9.34874
t:9.32225
input:9.01068
model:8.87506
$:8.85663
s:8.85493
des:8.84556
new:8.80451
e:8.77924
value:8.72085
string:8.51261

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:19.2689
,:17.438
1:15.2314
2:14.7067
3:14.3338
5:14.2567
4:14.2019
6:13.8359
8:13.7168
7:13.7129
_,:13.6637
x:13.5661
9:13.548
 as:13.3839
_:13.0993
 ,:11.2709
[:11.247
f:11.1503
X:11.094
__:10.9953
xx:10.9193

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_00

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_00
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_00>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_00: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_00
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_00
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:19.2445
2:16.7984
1:16.6052
3:16.0959
4:15.6379
,:15.4997
5:15.3297
6:15.1289
7:14.8819
8:14.5611
9:14.2537
[:11.9191
_:11.5376
xx:11.4379
_,:11.3444
XX:11.1871
a:11.1076
x:10.8698
...,:10.8226
..:10.804
e:10.684

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_000

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_000
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_000>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_000: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_000
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_000
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
1:19.9938
2:19.6249
3:18.6995
0:18.334
4:18.1564
5:17.8053
6:17.3162
7:17.2286
,:17.0242
8:16.7434
9:16.5736
a:13.6148
[:13.5788
x:13.4813
_,:13.4429
A:13.3831
e:13.2239
F:13.0332
X:13.0217
E:12.9505
...,:12.8355

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:15.5742
_:13.3389
_,:11.9291
 as:10.4928
:::10.3713
@:9.95
 @:9.75135
 $:9.44662
),:9.24862
 ,:9.16563
__:9.09487
$:9.02431
):8.89816
::8.7641
$,:8.66147
 ::8.3238
 :::8.18182
0:8.00813
[:7.94053
 _,:7.79403
(:7.74056

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:14.7648
1:10.9219
2:10.5368
3:9.77554
t:9.71144
5:9.6188
new:9.45191
4:9.44108
s:9.42298
f:9.35992
$:9.24153
6:8.96835
x:8.96045
9:8.913
e:8.77822
g:8.76864
model:8.74779
7:8.65284
8:8.6405
add:8.60069
...:8.56182

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_0: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:19.4082
,:17.2757
1:15.0455
2:14.8849
3:14.6332
5:14.5033
4:14.411
6:14.0349
7:13.9448
8:13.8537
9:13.6652
 as:13.5064
_,:13.2129
x:12.8992
_:12.6981
[:11.4787
 ,:11.4317
f:11.4118
(:10.9893
$,:10.9785
...,:10.8793

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_00

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_00
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_00>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_00: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_00
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_00
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:20.4817
1:17.4122
2:17.3274
3:16.6536
,:16.3738
4:16.0897
5:15.882
6:15.5354
7:15.3915
8:15.2125
9:14.9509
xx:12.757
...,:12.5339
[:12.299
x:12.1547
..:11.9812
_:11.9556
XX:11.898
...:11.8745
_,:11.8693
 ,:11.5535

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_000

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_000
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_000>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_000: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_000
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_000
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
1:20.2639
2:19.4253
3:18.4921
4:17.9414
0:17.5119
5:17.5063
6:16.8904
7:16.6631
8:16.2338
,:16.1438
9:16.1095
x:13.6783
X:13.1567
a:13.058
e:12.9702
_,:12.8746
[:12.6896
c:12.6193
f:12.6136
$:12.4309
...,:12.4154

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_0001>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_0001: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_0001
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_0001
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
,:15.519
_:13.6733
_,:11.634
 as:9.97996
:::9.73703
@:9.49243
$:9.34437
 @:9.27338
):9.188
 ,:9.17005
),:9.06334
 $:9.03578
__:8.93457
$,:8.77979
::8.49399
$$:8.19872
 ::7.97732
0:7.87103

:7.85356
 :::7.83485
 +:7.70555

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_0001_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_0001_: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_0001_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_0001_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:14.8368
1:10.9195
2:10.5729
t:9.9897
3:9.88826
5:9.80446
4:9.59452
9:9.44171
f:9.40146
new:9.3661
s:9.35338
6:9.31975
model:9.26878
g:9.23482
add:9.09653
xxx:8.81637
x:8.77377
7:8.71158
_,:8.62311
e:8.61758
8:8.59355

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_0

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_0001_0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_0001_0: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_0001_0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_0001_0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:20.5302
,:17.6564
5:15.5885
3:15.5627
2:15.5122
4:15.3745
1:15.3412
6:15.1078
7:15.0727
8:14.9857
9:14.8165
_,:13.3688
_:13.3358
 as:12.7167
x:12.4658
...,:12.405
.:12.2652
f:12.2134
[:11.9126
),:11.8108
):11.7864

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_00

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_00
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_0001_00>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_0001_00: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_0001_00
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_0001_00
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
0:21.0254
1:17.0731
2:16.985
,:16.9035
3:16.3281
4:15.7772
5:15.7101
6:15.2531
7:15.165
8:15.0014
9:14.8515
...,:13.349
_:12.5271
_,:12.3976
):12.1439
...:12.1141
..:12.0922
xx:11.9851
[:11.8865
x:11.8064
 ,:11.7574

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_000

Debug: true, Constrain: Types
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
+ UpdateBuffer(String) in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = (, []) in

# Add a todo item #
let add: Model -> [Todo] =
  fun model ->
    case model
    | (buffer_text_value_0001_0001_0001_0001_000
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer_text_value_0001_0001_0001_0001_000>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer_text_value_0001_0001_0001_0001_000: Model, model: Model, add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  bool_eq
Nature of error: Variable bool_eq is not bound  
Error in term:
  List.equal
Nature of error: Variable List.equal is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer_text_value_0001_0001_0001_0001_000
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer_text_value_0001_0001_0001_0001_000
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
1:19.9212
2:18.4919
3:17.3075
0:17.0759
4:16.8414
,:16.3335
5:16.2873
6:15.7784
7:15.4561
8:15.0025
9:14.9584
_,:13.0878
...,:12.8674
X:12.6189
f:12.5392
x:12.533
a:12.3556
$:12.3323
d:11.9615
$,:11.9565
c:11.938
