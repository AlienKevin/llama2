
================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Exp, Exp) -> Bool)
  LSP: Convex: Target types: ((Exp, Exp) -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:17.4788
 fun:16.4684
 :15.2715
  :12.3746
 ?:11.9949
    :11.7917
 fix:11.5453
                :11.0114
 #:10.9513
 function:10.9432
 {:10.9198
   :10.8565
 (:10.7669
 let:10.6558
 rec:10.6512
     :10.4384
 ...:10.4244
        :10.2746
 _:10.2713
 exp:10.2445
 eq:10.1441

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =


Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Exp, Exp) -> Bool)
  LSP: Convex: Target types: ((Exp, Exp) -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :19.8717
 :18.5315
fun:17.6301
  :14.9681
 fun:14.9438
	:13.8691
let:13.7786
     :13.5959
       :13.543
    :12.9866
func:12.8488

:12.4123
 let:11.9149
match:11.4983
#:11.4071
lambda:11.3251
fn:10.9491
function:10.897
{:10.8505
      :10.72
switch:10.5634

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
   

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Exp, Exp) -> Bool)
  LSP: Convex: Target types: ((Exp, Exp) -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:19.2833
 let:15.5434
 match:12.7706
 #:12.078
 fix:11.6293
 rec:11.2963
 var:10.8639
 (:10.818
 //:10.7783
 (*:10.6358
 ?:10.3584
 switch:10.2015
 lambda:10.1674
 case:10.0967
 type:9.98505
 {:9.93924
 eq:9.85169
 func:9.83182
 function:9.81639
 /*:9.63332
 |:9.55651

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 e:17.7707
 p:17.3984
 x:16.6028
 exp:15.6137
 a:15.5236
 expr:14.2921
 l:14.1766
 ex:13.0976
 left:12.7147
 xs:12.5495
 t:12.5153
 f:12.4875
 s:12.1867
 u:11.9822
 m:11.728
 v:11.5643
 (:11.4686
 r:10.3383
 w:10.3092
 le:10.2593
 c:10.1802

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: (Exp, Exp), equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
1:19.9856
0:16.5586
,:16.3675
_:13.9517
e:12.8292
a:12.8158
 e:11.8369
2:11.6911
f:11.5818
 p:11.4033
 f:11.2765
px:11.0914
A:10.9821
i:10.8508
 ,:10.8404
ps:10.445
',:10.2053
_,:10.0738
 xs:10.0614
₁:9.96943
L:9.93681

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: (Exp, Exp), equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: e1
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e1
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:20.1162
 e:15.7699
 ,:15.0838
 ->:13.9104
::13.6717
 ::12.5171
_,:12.2932
?,:12.0049
',:11.8129
@:11.3186
 x:11.1202
->:11.1185
s:11.0726
.:11.0089
 p:10.9583
e:10.9564
_:10.6952
2:10.6272
0:10.4325
*,:10.3653
 =>:10.2942

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 e:19.6035
e:15.0633
 x:14.0174
 exp:13.6453
 f:12.4959
 :12.2719
 xs:11.5594
 p:11.5262
 ex:11.412
 s:11.3113
 y:11.2628
 a:11.2456
 expr:11.1967
 other:10.9956
 _,:10.8765
 v:10.8003
 t:10.7874
 _:10.5801
 es:10.3634
 n:10.0897
 (:10.0038

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
2:23.9001
0:15.6754
1:15.1807
 ->:14.7013
3:14.2265
e:13.542
_:12.3397
':11.5593
4:11.5225
->:11.4511
a:11.4187
 :11.2003
,:10.9495
f:10.6891
o:10.2847
5:10.2783

:10.1738
w:10.0314
i:9.63374
 in:9.6078
?:9.56054

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: e2
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e2
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.1919
->:15.4072
,:14.5691
 =>:14.1523
 :13.9729

:12.0361
 -:11.5119
  :10.9502
 in:10.5585
::10.4753
 =:10.336
 -->:10.2768
 ::10.2178
 |:10.1725
 →:10.062
 ,:10.0082
 ~:9.84007
 {:9.8163
 //:9.79836
':9.66141
_:9.17282

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.6512
 :15.3112
 match:14.7195
  :12.9957
 false:12.8395
 e:12.5683
    :12.2128
 true:12.1366
 ?:12.0648
 ...:12.0211
 fail:11.7278
 #:11.5337
 let:11.3253
 case:11.3106
     :11.1312
                :11.0669
 False:11.0595
        :10.7543
 (:10.7037
 True:10.603
      :10.5856

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->


Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :17.9099
   :17.0192
     :14.5695
match:13.3905
    :13.2232
case:12.6455
      :12.5254
let:12.422
        :11.9218
 :11.8859
           :11.8842
  :11.7707

:11.6245
	:11.5958
if:10.9969
         :10.5904
switch:10.3936
in:10.3653
               :9.36308
 match:9.2713
(:9.08495

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
       

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:17.0576
 match:15.3227
 let:14.7708
 #:11.141
 e:11.1165
 var:10.9153
 switch:10.4473
 fun:10.3642
 if:10.1308
 rec:9.90536
 (*:9.8961
 (:9.74646
 type:9.55295
 true:9.30647
 equal:9.15649
 //:9.14588
 false:8.86113
 eq:8.85855
 ~:8.85498
 def:8.83452
 fail:8.77446

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e1 equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos e1 e2 epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "Ap" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Lam" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Var" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "e1" | "e2" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 e:16.5429
 (:13.2853
 [:11.9591
 h:11.5676
 :11.2213

:11.1556
 is:10.7772
 type:10.3852
 {:10.2439
 eq:9.91899
 compare:9.83785
 Int:9.56251
 equal:9.56206
 exp:9.51732
 let:9.49597
_:9.49014
 &:9.41087
(:9.36257
 f:9.30431
 pair:9.16743
 #:9.1519

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "e"))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  e
Nature of error: Variable e is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: e
LSP: Generating Completions for prefix: e
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e1 equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos e1 e2 epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2" | "nd" | "psilon_float" | "qual" | "xp"
root ::= completions

Top 20 Logits:
1:23.1432
2:17.408

:13.6371
3:13.3748
,:12.8824
_:12.449
0:12.3723
e:12.1836
i:11.6948
 :11.5454
::11.2731
4:11.1425
.:10.9096
 =>:10.8391
a:10.684
5:10.4897
:::10.3224
 as:10.2487
 ->:9.86728
 ==:9.57443
 of:9.45369

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: e1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Exp
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: e1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e1 equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos e1 e2 epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
,:19.0626

:16.5593
 :14.9686
 ,:14.2258
 e:14.2132
 ==:13.2109
 |:13.0835
 in:12.8328
.:12.6648
 ::12.5867
::12.4689
 as:12.3169
 of:12.2727
 with:11.7494
 {:11.6104
  :11.467
 =>:11.4638
 #:11.3619
 <:11.3416
 is:11.3107
 //:11.2671

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Exp, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Exp, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e1 equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos e1 e2 epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e1 equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos e1 e2 epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "Ap" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Lam" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Var" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "e1" | "e2" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 e:19.7019
e:15.398
 :12.4163

:10.4025
 x:9.9983
 is:9.98752
 type:9.97755
 h:9.86888
 t:9.70773
 a:9.40319
  :9.38544
 eq:9.34612
 y:9.27951
 f:9.25762
 E:9.09786
 c:9.09714
 (:9.0242
 s:8.83488
 p:8.64762
 exp:8.61152
 n:8.5394

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "e"))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  e
Nature of error: Variable e is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: e
LSP: Generating Completions for prefix: e
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e1 equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos e1 e2 epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2" | "nd" | "psilon_float" | "qual" | "xp"
root ::= completions

Top 20 Logits:
2:23.3116
1:16.0302
4:13.8936
3:13.8586

:12.5715
0:12.4038
.:11.2013
5:10.922
_:10.7538
,:10.6865
 :10.3447
 ->:10.337
6:9.65127
 =>:9.46631
                :9.46117
9:9.21165
7:9.18721
8:8.78249
::8.66587
->:8.20423
beta:8.16198

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: e2
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Exp
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: e2
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e1 equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos e1 e2 epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.2495
 :18.0174
 of:16.7762
 with:15.4294
  :15.2083
    :14.622
 {:13.4198
 in:13.3054
     :12.9242
                :12.8934
        :12.8895
      :12.8628
::12.8288
,:12.6227
   :12.6041
 =>:12.5807
 |:12.4407
 match:12.0619
         :11.9955
 //:11.8334
 ::11.8294

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2


Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Exp
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :18.4869
           :15.4328
        :14.5062
         :14.3907
   :14.1389

:13.4789
     :13.1858
	:12.9719
    :12.7968
            :12.7459
      :12.2292
          :12.1689
               :11.1362
#:11.0904
                :11.0672
|:10.8646
             :10.6823
  :10.6683
 :10.1922
 |:9.90696
              :9.58098

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
       

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Exp
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.7245
 #:16.0477
 +:14.2568
 //:13.588
 /*:12.8906
 (*:12.7631
 Var:12.5357
 ~:12.3581
 (+:12.2467
 ||:12.1965
 ##:11.6007
 -:11.3349
 /:11.2854
 match:11.2602
 *:11.2536
 let:11.1464
 of:11.048
 ###:10.9349
 #[:10.6248
 {:10.5904
 var:10.5885

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        |

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Var:17.4712
 Lam:13.3946
 _,:11.4057
 (:11.3877
 Ap:11.1946
 Exp:10.911
 #:10.4142
 x:10.3728
 e:10.2948
Var:10.0669
 var:9.96613
 V:9.74154
 +:9.44455
 :9.42161
 _:9.27278
 v:8.9236
 L:8.86969
 l:8.86632
 E:8.77021
 [],:8.60716
 Variable:8.45841

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Var>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (String -> Exp)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Arrow (String, (Var "Exp")))})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Var
Nature of error: Expecting type (Exp, Exp) but got inconsistent type (String -> Exp)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Var
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Var
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:17.0657
 x:15.3956
 v:14.5477
 s:14.1662
(_:13.6181
 a:13.3941
(":12.8761
 n:12.2464
 var:11.5429
 str:11.3902
 (:10.9955
 name:10.9361
 i:10.8695
,:10.5946
 p:10.3573
 _,:10.3028
 id:10.2648
 m:10.0559
 l:9.72791
(),:9.60713
(':9.56441

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Var(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Var(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Var(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~STRINGLIT~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Var "Exp")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
x:18.7252
v:17.3048
s:17.163
n:16.3633
a:15.9158
name:15.3
str:14.5812
id:14.5719
e:14.2324
var:14.1488
i:13.9352
p:12.5684
l:12.5427
y:12.4538
c:12.197
m:12.1679
f:12.1534
idx:11.9666
k:11.7611
string:11.5245
nm:11.4863

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Var(x)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~STRINGLIT~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
),:21.8086
1:18.4172
0:15.4223
_:14.2846
):13.5529
,:12.6835
::12.408
n:12.0804
2:11.8401
'),:11.2646
),(:11.1607
)::10.9523
d:10.9415
 ),:10.9064
v:10.9019
str:10.6854
name:10.6237
:::10.6006
3:10.5129
=:10.4702
 ::9.97979

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Var(x1)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x1
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~STRINGLIT~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
),:22.3953
):14.663
,:13.6286
 as:12.5634
_:12.3479
:::12.2762
::12.096
),(:11.9006
s:11.8233
 ::11.0456
).:10.9421
'),:10.8368
)::10.8053
 ),:10.767
);:10.7099
@:10.5877
1:10.3826
0:10.2828
.:10.0781
 :::10.0326
a:10.0221

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Var(x1)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Var "Exp")
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 ,:15.581
 Var:14.022
  :13.8658
 =>:13.3591
    :12.9381
     :12.9205
 as:12.9001
      :12.7733
 :12.4787
   :12.2004
 &:12.0302
 and:11.8563
 &&:11.4385
:::11.3481
 ->:11.2276
        :11.1277
       :10.8842
 |:10.8761
 :::10.7555
 ::10.5495
 =:10.4984

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) ,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) ,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Var:17.0386
Var:15.2942
 :12.5607
  :11.6639
 _:10.6089
    :10.4395
 var:10.3262
     :10.1962
   :10.0624
      :9.6871
 x:9.57937
 Lam:9.57554
 Ap:9.01197
        :8.92781
_:8.76979
 (:8.72275
 y:8.65382
 Vari:8.50441
       :8.4954
 Variable:8.38104
 e:8.3172

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Var>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: (String -> Exp)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Exp"); syn = (Arrow (String, (Var "Exp")))})))
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Var
Nature of error: Expecting type Exp but got inconsistent type (String -> Exp)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Var
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Var
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.3542
 (:16.662
 x:15.0985
(_:14.2011
 y:13.7936
((:12.14
 :11.495
():11.3014
  :11.156
(":10.7659
{:10.2002
 v:10.156
([:10.0179
(*:9.99159
[:9.93835
 _:9.90858
(@:9.86771
 (_:9.77938
({:9.75189
(?:9.73793
x:9.70915

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~STRINGLIT~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
x:20.9777
y:17.629
 x:14.5111
s:12.9345
v:12.5973
n:12.1658
X:12.1233
a:11.855
z:11.8068
xs:11.5631
e:10.9433
c:10.5668
t:10.5298
w:10.4954
i:10.3314
 y:10.2155
p:10.2154
r:10.0035
var:9.96099
f:9.91024
xx:9.87736

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~STRINGLIT~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
2:23.6941
1:18.3891
3:16.9418
0:16.0444
):15.6496
4:14.2858
5:13.2428
),:12.6778
n:12.2937
_:12.0494
)::11.6114
 :11.4783
 ):11.4473
6:11.4417
d:11.2599
::11.1712
_):11.0365
)=:10.9575
r:10.9363
@:10.8853
'):10.8764

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x2
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x2
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~STRINGLIT~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):21.9062
 ):18.4866
)=:16.0036
),:15.5714
)->:14.6038
)::14.0137
  :13.5649
)|:13.5343
)):13.4663
 :13.3834
 =>:12.8224
)>:12.1498
)?:11.9503
_):11.8657
)]:11.7967
);:11.3585
    :11.2896
)`:11.287
   :10.9086
)':10.838
     :10.7963

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.6142
  :16.2767
 :15.8022
    :15.1561
      :14.8503
     :14.8493
 ->:14.6931
 when:14.2416
        :14.1387
   :13.9776
         :13.7466
          :13.5462
                :13.4318
           :13.1456
 if:13.1342
       :12.8571
            :12.781
             :12.3265

:12.259
               :11.8076
	:11.6913

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) =>

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  x1 x2 ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | "x1" | "x2" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:18.1936
 :12.4436
 if:12.423
 true:12.0644

:11.8788
 (:11.1028
 eq:10.6824
 e:10.6743
  :10.3923
 String:10.2769
 True:10.2637
 Bool:9.58165
 false:9.57183
 string:9.48247
 equal:9.45432
     :9.23536
 equals:9.21825
    :9.00015
 assert:8.94881
 ?:8.89165
 compare:8.83829

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x
Nature of error: Variable x is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  x1 x2 ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2"
root ::= completions

Top 20 Logits:
1:22.0549
 ==:16.8121
2:15.0556
 =:13.2423
 ===:13.037
3:12.5729
==:12.5353
.:11.9113
0:11.5477
=:11.4525
 :11.4513
 :=:11.1422
_:10.8729
e:10.8208

:10.7713
[:10.649
l:10.5831
 !=:10.247
i:10.2273
:::10.1908
(:10.0061

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: x1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: x1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  x1 x2 ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 ==:22.183
 ===:16.726
==:16.472
 =:16.4265
.:15.6494
 :14.6581
=:13.2982
 <:13.1433
 is:13.1301
 !=:12.312
 ::12.1709
 eq:12.0806
[:12.0241
 =~:11.9503
 <=:11.8523
 equals:11.8212
  :11.5443
 ~:11.5197
 ?:11.5131
 &&:11.4846
 as:11.4668

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 ==:17.6443
 =:13.2073
:12.7371
≡:12.5745
 ===:12.0435

:11.9957
≈:10.6776
==:10.5958
 <:10.3078
	:10.1691
 <=:9.87853
 =~:9.79239
 is:9.52667
≠:9.46666
∈:9.36963
 :=:9.36013
:9.35317
:9.27881
 !=:9.09744
 ::9.0022
 eq:8.9973

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 


Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :16.571
                :16.0865
           :15.0146
               :13.3612
         :13.2389
        :12.8127
   :12.3647

:12.2899
            :12.2159
             :11.9129
=:11.8907
              :11.848
          :11.7849
     :11.5392
      :11.2845
	:10.7226
==:10.533
end:10.3349
    :10.2335
|:10.0919
#:9.59861

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
       

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {x2: String, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:17.1808
 Lam:13.2352
 =:12.9059
 ...:12.3135
 else:12.2474
 #:12.227
 end:11.8603
 ~:11.2489
 ==:11.2206
 and:11.0957
 Ap:11.0913
 //:10.9146
 in:10.6759
 case:10.5238
 match:10.4301
 (*:10.2883
 =>:10.2456
 ||:10.2039
 --:10.193
 elif:10.1207
 ?:9.95154

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        |

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Lam:16.6753
 Ap:13.1155
 _:11.6158
 Var:11.4319
 _,:10.2254
 :9.41531
L:9.37682
 e:9.15075
 x:9.03003
 Lamb:9.02525
 (:8.65211
                :8.51976
 L:8.4879
 ,:8.46242
 App:8.33617
 l:8.28481
 Exp:8.16853
  :8.09154
 var:7.85918
 ap:7.54992
 |:7.46478

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Lam>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn =
           (Arrow (
              (Prod
                 [String;
                   (Rec ("\206\177",
                      (Sum
                         [("Var", (Some String));
                           ("Lam", (Some (Prod [String; (Var "\206\177")])));
                           ("Ap",
                            (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                           ])
                      ))
                   ]),
              (Var "Exp")))})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Lam
Nature of error: Expecting type (Exp, Exp) but got inconsistent type ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Lam
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Lam
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.3973
(":14.3289
(_:13.385
 (:12.9843
((:12.677
 _,:11.9672
([:11.8312
(),:11.2882
,:11.1732
 _:10.9347
(*:10.6371
(@:10.4151
(':10.3454
 x:10.2307
 a:10.0598
{:10.0448
 p:9.92087
({:9.91902
():9.71739
(?:9.44847
 s:9.4473

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Var "Exp")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
x:16.5445
v:14.9123
p:14.7699
_,:14.7326
s:14.7109
a:14.1958
f:13.9679
n:13.8505
y:13.3952
arg:13.1957
e:12.7993
l:12.7782
var:12.7093
param:12.4788
name:12.3374
b:12.2414
xs:11.8352
str:11.5015
id:11.2615
i:11.1931
k:11.145

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam(x)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
1:21.6479
,:19.0224
3:16.2525
0:16.1558
2:15.5605
),:14.8704
_:14.2994
 ,:14.2046
n:13.3686
_,:13.2531
):13.1523
b:12.8878
4:12.6624
',:12.4431
5:12.3864
v:12.2184
d:12.002
,(:11.992
r:11.878
N:11.8013
m:11.5544

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam(x1)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x1
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x1
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.1346
),:15.7674
 ,:14.4936
):13.7864
a:12.2957
y:11.7516
1:11.5713
_:11.532
b:11.3358
e:11.09
  :11.0134
,(:10.7915
::10.7014
_,:10.6911
s:10.6873
f:10.5646
2:10.5367
 :10.4819
 y:10.1908
 ::10.0447
,":9.9838

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam((x1, ?))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam((x1, ?))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam((x1, ?))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 e:14.6115
 b:13.623
e:13.5547
 y:13.1324
 body:12.2924
 t:12.0302
 a:12.0008
 f:11.8382
 x:11.6425
 _):11.5734
 exp:11.5686
b:11.4597
 l:11.0121
 xs:10.8041
 m:10.6465
y:10.6306
 ex:10.5267
 v:10.4578
 s:10.3932
 _:10.2274
 p:10.16

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam((x1, e))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
1:20.5237
),:16.7328
3:16.3264
2:14.9809
):14.8111
e:14.7053
0:14.6927
_:13.7678
ps:13.715
px:13.1557
a:12.3421
4:12.1544
f:12.0523
i:11.591
5:11.1695
y:10.8147
psilon:10.7584
body:10.6107
)::10.5528
X:10.4085
o:10.3528

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Lam((x1, e1))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e1
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e1
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
),:17.8038
'),:15.9163
):15.3654
1:14.2511
'):14.1776
_:13.4557
p:12.605
2:12.2968
a:11.6783
':11.4415
',:11.0995
b:10.6918
e:10.6578
.:10.6487
s:10.6325
_):10.4019
0:10.3527
,:10.1707
x:10.0738
),(:10.0115
f:9.80402

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Lam((x1, e1))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Var "Exp")
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 ,:16.3189
 :12.1272
 Lam:11.9385
  :11.3473
      :11.1624
 as:10.6092
    :10.4385
     :10.2593
 &:10.215
 ->:9.90789

:9.87843
   :9.77174
 ::9.77162
 =>:9.64789
 :::9.52303
 and:9.2714
 _,:9.05412
 +:8.912
 |:8.86201
       :8.83702
        :8.62232

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) ,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) ,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Lam:17.0552
L:13.996
 :11.7932
 Lamb:11.0127
 Var:10.9817
 Ap:10.0733
 L:9.98293
 _:9.43267
  :8.95428
 (:8.89564
lam:8.72468
 l:8.12543

:7.98529
 e:7.9659
 x:7.37043
 Exp:7.15803
	:7.04604
Var:7.02616
 Lab:6.99593
   :6.9816
 Laz:6.9614

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Lam>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Exp");
           syn =
           (Arrow (
              (Prod
                 [String;
                   (Rec ("\206\177",
                      (Sum
                         [("Var", (Some String));
                           ("Lam", (Some (Prod [String; (Var "\206\177")])));
                           ("Ap",
                            (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                           ])
                      ))
                   ]),
              (Var "Exp")))})))
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Lam
Nature of error: Expecting type Exp but got inconsistent type ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Lam
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Lam
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.3524
 (:15.7151
((:12.8083
(_:12.2285
 :10.3945
.(:10.3499
_(:10.2769
():10.2628
([:10.2027
 x:10.1736
{:9.73513
(":9.63398
[:9.6209

:9.55995
x:9.44327
*(:9.33645
y:9.0251
(*:9.0019
(::8.91414
 y:8.91206
 ((:8.81313

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
x:19.7968
y:14.7629
e:13.8646
 x:13.0935
_,:12.5348
X:11.8797
a:11.2072
s:11.1408
L:10.7309
xs:10.6964
l:10.6403
z:10.6341
v:10.5256
f:10.384
n:10.1944
var:10.0488
c:9.83661
t:9.73571
Var:9.64446

:9.27562
xx:9.25487

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
2:23.3147
1:19.0268
3:17.2402
,:14.9391
0:14.6119
4:14.4554
5:13.7333
_:12.7105
6:12.0455
 ,:11.9667
n:11.8941
_,:11.8131
d:11.687
9:11.5976
 :11.585
8:11.4916

:11.4276
7:11.3707
',:11.3355
r:11.3212
):11.1747

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x2: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: x2
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: x2
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.5809
 ,:14.5055
 e:12.1732
):11.6442
),:11.629
e:10.5681
.:10.1961
,,:9.74927
 :9.53433
::9.47211
 y:9.23586
2:8.82647
 f:8.78557
_,:8.72712
 _,:8.58417
 ::8.54773
1:8.42125
',:8.36255
s:8.27134
.,:8.25151
 x:8.24024

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 e:18.6241
e:15.3515
 y:13.0574
 _):12.3499
 :12.2504
 f:11.2569
 x:10.9098
 exp:10.7482
 Lam:10.5226
 l:10.4095
 _:10.3801
 a:10.2101
 b:10.0376
 (:10.0067
 xs:9.80162
 es:9.65261
 t:9.62336
 E:9.48088
 v:9.46761
  :9.41659
 h:9.30323

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
2:23.1739
1:17.9683
3:17.518
4:14.8575
):14.6464
e:13.6015
5:13.2754
0:13.0523
_:12.9675
6:11.8231
),:11.789
a:11.7146
 :11.3853
7:11.2492
 ):11.2455

:11.103
9:10.876
)::10.8474
8:10.8041
_):10.7217
X:10.533

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e2
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e2
LSP: commas: p_ana is prod: String (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [String;
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):20.2004
 ):15.5648
)=:15.4106
),:14.534
)->:13.9024
)):12.9806
'):11.7085
)|:11.6568
)>:11.5867
)':11.1384
 =>:11.0571
);:10.9564
)::10.7585
_):10.5934
)?:10.457
)`:10.3562
)]:10.2913
1:10.185
0:10.0741

:10.0378
s:10.0148

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.4676
 :13.9167
 ->:13.1535
 if:12.8341

:12.7655
 when:12.3836
  :11.9488
 =:10.9884
 &&:10.5413
=>:10.201
 :=:9.93009
 |:9.91269
 ==>:9.78402
    :9.67269
 ,:9.64198
 ?:9.58795
 {:9.58147
 where:9.52098
 and:9.49559
 ==:9.39836
   :9.17465

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) =>

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  x1 x2 ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | "x1" | "x2" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 x:14.5812
 equal:14.3904
 if:12.7046
 :12.1175
 (:11.5056
 let:11.3409
 Lam:11.232

:11.1525
 e:11.1496
 true:10.2858
 false:10.0053
 ?:9.90535
 and:9.57264
 is:9.4134
 eq:9.27036
 ((:9.12549
 fol:9.05742
 &&:8.8751
 [:8.85286
 length:8.77354
  :8.73011

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "x"))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x
Nature of error: Variable x is not bound  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: x
LSP: Generating Completions for prefix: x
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  x1 x2 ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2"
root ::= completions

Top 20 Logits:
1:20.7486
2:16.7445
 ==:16.51
 &&:13.8714
3:13.5987

:13.2791
 ===:13.0827
 =:12.8404
.:12.7299
==:12.3325
 :12.321
 and:11.7825
 +:11.6738
_:11.6713
e:11.6171
0:11.5711
(:11.3501
l:11.102
 !=:11.0919
=:10.9976
 &:10.8763

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: x1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: x1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  x1 x2 ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 ==:18.0301
 &&:16.1273
 :13.4868
 =:13.1472
==:12.9739
 +:12.7006
 ===:12.25

:12.2349
 !=:12.1784
.:12.0981
 &:11.8538
 ||:11.7772
 and:11.687
=:10.9695
 <:10.7841
 *:10.7606
,:10.5755
 <>:10.2952
  :9.91431
 x:9.83259
 ++:9.80902

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.152
 ==:17.1784
 &&:16.9563
 !=:12.5924
 #:12.5284
 ||:12.5083
 and:12.3869
 //:12.2269
 ===:12.1306
 &:12.0166
 +:11.9905
 =:11.6598
 <:11.6346
 x:11.5365
 *:10.9858
 <=:10.9325
==:10.8647
:10.6907
 >:10.6143
 (:10.5895
 in:10.5111

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 


Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :18.0346
                :15.6997
           :14.9307
               :13.6269
             :12.2477
              :12.1609
            :12.1111
   :11.8278

:11.7876
         :11.6037
        :11.602
          :11.5116
in:11.371
end:11.2225
	:10.7452
#:10.7264
      :10.2867
     :9.80616
and:9.46432
    :9.3342
|:9.28956

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
       

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <x1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x2: String, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, x1: String, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: $==
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: $== ++
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: $== ++
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "$==" | "++" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:18.6119
 #:13.4784
 Ap:13.2734
 ||:13.1791
 &&:12.7914
 and:11.944
 else:11.8363
 //:11.8088
 match:11.6654
 end:11.6158
 in:11.2659
 case:11.2322
 if:11.0365
 (*:10.3558
 =>:10.3427
 ap:10.3346
 ?:10.3241
 =:10.274
 (:10.2204
 ...:10.1206
 +:10.0567

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        |

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Ap:18.0352
 Lam:12.4307
 _:11.4325
 App:11.0399
 e:10.8258
Ap:10.7477
 _,:10.4082
 :10.396
 (:10.1744
 Var:9.93244
                :9.87756
 ,:9.43151
 ap:9.29481
 &:9.18075
 x:9.17168
 Exp:9.17146
  :9.02101
 if:8.74152
 A:8.69211
 L:8.64397
,:8.30758

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Ap>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn =
           (Arrow (
              (Prod
                 [(Rec ("\206\177",
                     (Sum
                        [("Var", (Some String));
                          ("Lam", (Some (Prod [String; (Var "\206\177")])));
                          ("Ap",
                           (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                          ])
                     ));
                   (Rec ("\206\177",
                      (Sum
                         [("Var", (Some String));
                           ("Lam", (Some (Prod [String; (Var "\206\177")])));
                           ("Ap",
                            (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                           ])
                      ))
                   ]),
              (Var "Exp")))})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Ap
Nature of error: Expecting type (Exp, Exp) but got inconsistent type ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Ap
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Ap
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.1126
 (:17.1413
():13.2951
(_:13.2831
([:13.1424
((:13.1061
(),:12.3454
 e:11.8593
{:11.4322
[:11.3167
(*:11.2193
 l:11.1356
,:11.1303
 _:11.0458
({:10.8972
 :10.8802
 a:10.8762
 _,:10.606
 ,:10.3755
(?:10.3006
(":10.2406

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap(?)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: (
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Var "Exp")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
e:18.3956
f:15.7775
l:15.757
a:15.0311
x:14.1238
exp:13.068
p:12.2316
left:12.2243
u:12.2154
h:12.0597
t:11.8007
v:11.7599
Ap:11.6496
ap:11.5144
m:11.3954
ex:11.2145
L:11.1997
r:11.0444
el:10.9333
s:10.9218
y:10.4837

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap(e)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
1:21.8702
3:17.5704
0:17.2568
2:14.6775
ap:14.6517
_:13.9784
,:13.7871
L:12.7134
':12.6063
4:12.5696
A:11.7704
',:11.6729
5:11.5544
X:11.5518
Ap:11.3986
app:10.8823
o:10.6492
),:10.3876
ae:10.3584
ax:10.3375
F:10.3281

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap(e1)
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e1
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e1
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:18.4415
1:18.2925
a:18.0451
_:17.5627
',:14.4564
l:13.8521
 ,:13.5454
p:13.4161
0:13.3235
f:12.7359
e:12.7141
x:12.7009
L:12.5127
),:12.4047
-:12.2604
s:12.2299
_,:12.2042
.:12.1124
A:11.7357
2:11.6482
b:11.5605

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap((e1, ?))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap((e1, ?))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap((e1, ?))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 e:16.8169
 f:15.4452
 a:14.4606
e:13.1552
 x:13.1076
 t:12.6061
 es:12.4139
 u:12.3663
 y:12.326
 v:12.2664
 l:12.1355
 s:12.1123
f:11.8977
 exp:11.6851
 p:11.4497
a:11.2281
 args:11.164
 h:11.1169
 r:10.9873
 ex:10.9218
 g:10.9132

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap((e1, e))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
1:21.4301
2:20.3155
3:20.2867
e:15.8072
a:15.3765
_:15.0183
4:14.8693
):14.6804
0:14.6643
f:14.1007
),:13.6826
i:13.4519
5:12.8071
':12.642
A:12.2778
'):11.9428
o:11.6834
_):11.4623
ap:11.3402
w:11.0039
X:10.8969

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  Ap((e1, e1))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e1
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e1
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
'):15.3641
'),:14.8845
):14.8584
),:14.8488
1:14.1856
_:13.6714
p:13.1664
s:12.9668
a:12.7911
_):11.8796
2:11.4313
',:10.7013
b:10.4994
f:10.179
r:10.0578
':9.96355
0:9.88511
.:9.77329
e:9.76513
t:9.51277
l:9.2709

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn = (Var "Exp")})))
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Ap((e1, e1))
Nature of error: Expecting type (Exp, Exp) but got inconsistent type Exp  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Var "Exp")
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 ,:16.642
 :11.7352
 Ap:11.1927
  :11.1354
   :9.55125
Ap:9.23563
    :8.91381
 ::8.86377
 ap:8.75224
 &:8.63475
 |:8.6117

:8.60137
 and:8.4231
 ;:8.38237
 Lam:8.31236
      :8.26118
     :8.17078
 ->:8.06047
 .:7.946
 =>:7.9293
 ||:7.78248

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) ,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) ,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Ap:16.8666
Ap:12.7103
 Lam:12.4122
 :11.4001
 ap:10.6574
 App:10.4601
 (:9.69838
 AP:9.64385
 A:9.45962
 Var:9.1052
 L:8.93236
 _:8.71576
 e:8.46613
  :8.32779
 Exp:8.19068
 Lap:7.80634
L:7.80564
 Api:7.69932
ap:7.60619
 Lamb:7.47256
 Ax:7.32555

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Ap>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Exp");
           syn =
           (Arrow (
              (Prod
                 [(Rec ("\206\177",
                     (Sum
                        [("Var", (Some String));
                          ("Lam", (Some (Prod [String; (Var "\206\177")])));
                          ("Ap",
                           (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                          ])
                     ));
                   (Rec ("\206\177",
                      (Sum
                         [("Var", (Some String));
                           ("Lam", (Some (Prod [String; (Var "\206\177")])));
                           ("Ap",
                            (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                           ])
                      ))
                   ]),
              (Var "Exp")))})))
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Ap
Nature of error: Expecting type Exp but got inconsistent type ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp)  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Ap
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Ap
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.2911
 (:16.3151
():11.7718
((:11.7248
(_:11.3236
[:10.9749
([:10.9367
 e:10.8184
.(:10.0974
(*:9.99375
_(:9.98606
2:9.66968
{:9.36123
_:9.20771
,:9.19505
 :9.15919
*(:9.14367

:9.1322
(-:8.82445
(?:8.80964
e:8.79859

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: (
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
e:19.3482
x:13.9004
a:12.7244
f:12.383
Ap:11.9743
y:11.6479
E:11.5233
 e:11.4996
L:10.9795
ex:10.9352
s:10.692
ap:10.677
o:10.6216
t:10.4179
_,:10.4095
h:10.3783
l:10.3512
v:10.3239
r:10.3087
u:10.2596
d:10.2387

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
2:24.495
1:21.3682
3:21.0893
4:17.3648
,:16.4419
0:16.368
5:15.4958
_:13.7475
):13.662
9:13.242
6:13.2187
8:12.9757
X:12.9329
7:12.9005
),:12.5956
 ,:12.5658
.:12.2956
o:12.1485
A:12.1265
_,:12.0208
e:11.9081

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}), e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e2
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e2
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.9834
 ,:14.457
):13.7767
.:13.0349
 e:12.4528
1:12.0979
),:11.9947
a:11.2108
e:10.8071
_:10.7135
2:10.3416
',:10.1175
,,:10.1073
.,:9.80033
 :9.72949
0:9.71867
 ):9.48987
3:9.18853
_,:9.14903
::8.77477
)):8.60992

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Seft type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 e:18.6756
e:13.9532
 f:12.16
 a:11.3944
 :11.3912
 y:11.2789
 x:10.9684
 d:10.8537
 E:10.5987
 ap:10.4258
 _):10.2355
 Ap:10.1526
 t:9.96
 b:9.68238
 ):9.67839
 v:9.56992
 p:9.56651
 h:9.5493
 s:9.42987
 r:9.3876
 _:9.31662

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
2:24.1728
3:22.049
1:19.2405
4:17.8813
):15.6154
5:15.0384
e:14.32
0:13.8398
_:13.5774
a:12.9908
6:12.9375
 :12.9205
8:12.8532
9:12.7607
7:12.3359
X:12.2921

:12.0704
f:12.0484
 ):11.7789
)):11.6989
x:11.5

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))})
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: e2
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: e2
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   )) (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Var", (Some String));
            ("Lam", (Some (Prod [String; (Var "\206\177")])));
            ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
       ));
     (Rec ("\206\177",
        (Sum
           [("Var", (Some String));
             ("Lam", (Some (Prod [String; (Var "\206\177")])));
             ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
        ))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):19.0864
 ):13.6675
)=:13.3263
)):12.1334
),:12.1105
s:11.7915
2:11.5829
)->:11.0182
)>:10.9727
'):10.7649
1:10.6539
);:10.6295
_):10.4389
 =>:10.3306
).:9.98449
)|:9.87436
_:9.75251
3:9.66517
)':9.59241
)`:9.56448
)]:9.53028

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: Exp
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.0273
 :13.4055
 ->:13.3153

:13.092
  :11.6871
 =:11.4017
 end:11.173
 &&:10.2687
   :10.2212
=>:10.1609
 else:10.053
 if:9.66727
 :=:9.59622
    :9.35893
 ):9.28817
 e:9.28364
 where:9.27888
 :::9.26669
 ==:9.2361
 ==>:9.13375
 |:8.98226

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) =>

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 equal:14.3642
 e:13.7348
 x:13.4605
 true:13.1806
 false:12.4281
 :11.9387
 (:11.7336
 ?:11.05

:10.8388
 ap:10.6067
 [:10.5936
 False:10.0885
 True:10.0465
 Ap:9.80291
 fol:9.79426
 None:9.6718
 ():9.52837
 []:9.24505
  :9.0449
 if:8.95926
 ...:8.93868

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <equal>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ((Exp, Exp) -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool;
           syn = (Arrow ((Prod [(Var "Exp"); (Var "Exp")]), Bool))})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  equal
Nature of error: Expecting type Bool but got inconsistent type ((Exp, Exp) -> Bool)  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: equal
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Exp, Exp) -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: equal
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:18.2532
 (:14.6047
():13.6207
_:13.1958

:12.9786
 e:12.8085
((:12.4006
([:12.379
Exp:11.9779
?(:11.4613
 :11.366
(*:11.0914
Expr:10.6834
 in:10.5892
[:10.549
 exp:10.5447
 &&:10.51
(?:10.0777
 end:10.0556
.(:9.94677
.:9.85969

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "case " | "e1" | "e2" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
e:17.8005
x:13.4439
exp:12.7391
Ap:12.1545
xs:11.8063
a:11.7306
f:11.7274
equal:11.5629
ap:11.0345
eq:10.757
L:10.6383
Var:10.5628
h:10.5525
Exp:10.4746
l:10.2902
 e:10.2412
t:10.2064
v:10.0827
hd:10.0201
ex:9.75712
p:9.66587

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "e"))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  e
Nature of error: Variable e is not bound  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: e
LSP: Generating Completions for prefix: e
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2"
root ::= completions

Top 20 Logits:
1:23.4266
2:18.6291
3:16.902
,:16.252
0:15.7432
):15.1567
_:14.2825
.:14.1953
[:13.9322
4:13.9116
!,:13.2673
5:13.1138
!:12.61
(:12.3821
)):12.3576
X:12.2568
!):11.8111
)(:11.7852
),:11.7626
->:11.5261

:11.5202

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn =
           (Rec ("\206\177",
              (Sum
                 [("Var", (Some String));
                   ("Lam", (Some (Prod [String; (Var "\206\177")])));
                   ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                   ])
              ))})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  e1
Nature of error: Expecting type (Exp, Exp) but got inconsistent type rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: e1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: e1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:19.671
.:15.4518
):15.2085
 ,:14.7496
1:14.3295
),:13.4343
 e:13.0979
[:12.3588
:::12.2458
_:11.9692
::11.7627
e:11.6009
)(:11.338
2:11.1127
 ::11.0404
s:11.023
',:10.9965
a:10.9361
0:10.7407
 :10.7104
)):10.5555

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Exp
  LSP: Convex: Target types: Exp
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e2 e1 e1 e2 e1 ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "case " | "e1" | "e2" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 e:17.8865
e:15.3103
 x:12.2226
 f:11.236
 :10.8873
 exp:10.5947
 ap:10.2055
 a:10.0897
 (:10.0369
 [:9.97055
 v:9.94711
 t:9.72754
 y:9.72567
 ):9.51621
x:9.38548
 h:9.36834
 _):9.24429
 d:9.15743
 s:8.99434
 l:8.96174
 p:8.91958

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "e"))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  e
Nature of error: Variable e is not bound  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: e
LSP: Generating Completions for prefix: e
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Exp
  LSP: Convex: Target types: Exp
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e2 e1 e1 e2 e1 ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2"
root ::= completions

Top 20 Logits:
2:23.4322
1:21.4678
3:17.6025
):15.4014
4:14.5451
0:14.0546
5:13.0285
_:12.6683
),:12.4561
)):12.4443
f:12.1224
x:12
e:11.9779
);:11.7344

:11.6084
9:11.3702
a:11.3292
,:11.3096
8:11.1624
w:11.1599
 ):11.1109

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: e2
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: e2
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Exp
  LSP: Convex: Target types: Exp
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e2 e1 e1 e2 e1 ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):18.8681
),:14.6034
)):14.2438
);:14.1429
 &&:13.4937
 ):12.8812
,:12.6567
).:12.0454
)*:11.6665
.:11.5785
 ||:11.5313
));:11.1054
)?:10.8661

:10.7684
)]:10.5293
1:10.4416
)`:10.2922
 :10.1958
))):10.1039
)+:10.0895
)|:10.0544

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 &&:17.175
 ||:14.4361
 end:14.3584

:14.1113
 :13.2166
 in:12.5616
 &:11.3679
 ==:11.2463
 and:11.1127
  :10.5204
&&:10.4673
 @:10.3728
 else:10.0752
 #:9.99071
 *:9.94912
 +:9.82765
 or:9.40336
 //:9.19022
 |:8.97988
   :8.68009
    :8.65871

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) &&

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) &&
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >&&<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Boolean Conjunction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Boolean Conjunction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: &&
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: &&
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 equal:17.1422
 e:12.5347
 :12.5269
 (:11.1451

:11.0164
 eq:10.7968
 equals:10.5771
 x:9.99503
equal:9.98253
 equ:9.64187
 ap:9.26311
 eu:9.25949
 ==:8.88092
 \:8.87462
 true:8.87081
  :8.82111
 &&:8.80519
&:8.76095
 fol:8.67782
 ...:8.5974
 !:8.57607

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <equal>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ((Exp, Exp) -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool;
           syn = (Arrow ((Prod [(Var "Exp"); (Var "Exp")]), Bool))})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  equal
Nature of error: Expecting type Bool but got inconsistent type ((Exp, Exp) -> Bool)  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: equal
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Exp, Exp) -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: equal
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:20.3105
 (:16.8602
_:12.3679

:12.2414
():12.2105
 e:12.1841
((:11.5452
[:11.2326
.(:10.9651
([:10.8937
(*:10.684
2:10.4629
 :10.4398
.:10.1615
e:9.82324
(_:9.49781
 end:9.41319
(...):9.05296
_(:8.85857
  :8.85032
(&:8.72355

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "case " | "e1" | "e2" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
e:18.6944
f:12.7762
a:12.3074
x:12.2483
exp:11.8018
 e:10.9767
ap:10.9446
ex:10.6668
t:10.6576
l:10.6058
v:10.5486
Ap:10.5456
s:10.5198

:10.4282
y:10.4054
p:10.248
el:10.115
h:10.0107
d:9.91146
L:9.85473
es:9.83848

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "e"))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  e
Nature of error: Variable e is not bound  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: e
LSP: Generating Completions for prefix: e
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2"
root ::= completions

Top 20 Logits:
1:21.9275
2:21.7975
3:17.3495
0:15.2433
,:14.6798
4:13.7697
_:12.9629
5:12.8554
):12.7068
.:12.6587
X:11.7911
9:11.5324
o:11.3978
e:11.1211
N:10.849

:10.8337
6:10.8253
8:10.783
A:10.6538
)):10.6051
[:10.4759

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Var "Exp"); (Var "Exp")]);
           syn =
           (Rec ("\206\177",
              (Sum
                 [("Var", (Some String));
                   ("Lam", (Some (Prod [String; (Var "\206\177")])));
                   ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))
                   ])
              ))})))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  e1
Nature of error: Expecting type (Exp, Exp) but got inconsistent type rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: e1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: e1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Var", (Some String));
        ("Lam", (Some (Prod [String; (Var "\206\177")])));
        ("Ap", (Some (Prod [(Var "\206\177"); (Var "\206\177")])))])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:20.2031
 ,:13.8991
2:13.8086
.:13.7775
1:13.707
):13.2617
_:12.585
 e:12.4379
',:12.2491
0:12.168
),:11.5893
e:10.8053
a:10.6386
-:10.1428
[:9.92579
.,:9.67308
)):9.62292
3:9.54664

:9.52129
':9.51101
b:9.5041

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1,

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: (Exp, Exp)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Exp
  LSP: Convex: Target types: Exp
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e2 e1 e1 e2 e1 ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Exp, Exp)
Exp <= (Exp, Exp)
Exp <= (Exp, Exp)
  LSP: Convex: Target types: Exp, (Exp, Exp)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "case " | "e1" | "e2" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 e:18.7922
e:14.3172
 :11.1301
 x:11.1165
 y:11.0549
 f:10.4722
 equal:10.2334
 a:10.2237
 t:9.87226

:9.74018
 ap:9.53243
 v:9.41845
 eq:9.41757
 (:9.41522
 l:9.26388
 E:9.08345
 ):9.03346
 exp:9.01001
 h:8.93485
 [:8.74324
 d:8.55542

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "e"))
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  e
Nature of error: Variable e is not bound  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: e
LSP: Generating Completions for prefix: e
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Exp
  LSP: Convex: Target types: Exp
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e2 e1 e1 e2 e1 ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "1" | "2"
root ::= completions

Top 20 Logits:
2:23.6621
1:19.3151
3:18.7329
4:15.3043
):14.8181
0:14.1282
e:13.8276

:13.7474
a:12.6993
5:12.4404
_:12.3985
 :11.8226
y:11.7535
i:11.7142
9:11.5261
o:11.4809
)):11.213
f:11.1541
x:10.8795
);:10.8118
.:10.7463

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <e2>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Exp
  LSP: Info: Seft type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: e2
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: e2
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Exp, (Exp, Exp)
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Prod [(Var "Exp"); (Var "Exp")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Exp
  LSP: Convex: Target types: Exp
  LSP: Convex: Backpack: 
  LSP: Convex: Base: e2 e2 e1 e1 e2 e1 ( case  if  let  type 
  LSP: Convex: Lookahead: ( Ap Lam Var case  e1 e1 e2 e2 if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):20.2651
);:15.4969
)):14.8837
 ):14.698
),:13.9728
).:13.9692
)`:13.7124

:13.2568
));:12.4895
)]:12.2446
 end:11.4688
 :11.3613
,:11.3467
))):11.191
)))):11.0931
)":10.9002
)*:10.8951
)|:10.717
)}:10.4423
)\:10.3201
;:10.2784

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.7312
 end:16.616
 :16.556
  :15.0953
 in:14.7495
   :14.1227
 #:13.62
        :13.5284
    :13.5132
                :12.8004
 else:12.6063
 &&:12.4753
     :12.452
      :12.4486
end:12.3996
            :12.2396
 and:12.007
 //:11.8143
         :11.6417
 ||:11.6365
          :11.371

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)


Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :19.0112
in:17.3608
end:15.9885
   :15.7983
        :14.6526

:14.1901
#:13.4038
    :13.2264
           :13.1689
                :13.0263
	:12.7146
      :12.6344
            :12.5822
  :12.2205
     :12.1624
         :11.7859
let:11.7421
               :11.4834
 :11.4675
          :11.2488
and:11.2479

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
       

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e1: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:18.9521
 end:15.2395
 _:14.8489
 #:13.8602
 else:13.8005
 in:13.4785
 //:11.9616
 case:11.5589
 (_:10.9173
 otherwise:10.8593
 of:10.825
 e:10.6353
 true:10.5873
 ||:10.3746
 (*:10.0077
 }:9.9904
 false:9.95246
 return:9.93754
 x:9.78848
 =>:9.7753
 fun:9.77268

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        |

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Ap" | "Lam" | "Var" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 _:16.8519
 _,:15.5249
 Var:13.0979
_:11.2174
 Lam:11.2022
 :10.7873
 e:10.6722
_,:10.5018
 x:10.1004
 Ap:10.0844
 (:9.89014
 None:8.966
 ,:8.90099
 var:8.83338
 Exp:8.77698
 otherwise:8.75058
  :8.66961
 #:8.37486
 a:8.36454
 [],:8.30914
 true:8.21578

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Exp, Exp)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: (Exp, Exp)
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
LSP: commas: p_ana is prod: (Var "Exp") (Var "Exp")
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Ap Lam Var _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.7104
 ,:14.3535
 ->:14.2425
=>:13.6704
 :12.9013
 :::11.7664
,:11.7019
 :=:11.6999
  :11.6631
                :11.6502
:::10.9646
   :10.855
        :10.5012
    :10.3119
 ::10.2586
         :10.2294
     :10.1432
            :10.0977
 =:10.0559
      :9.93351
          :9.91296

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ =>

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 false:18.9938
 False:15.0644
 true:14.1067
 None:11.8878
 :11.815
 e:11.6685
 x:10.4226
false:10.3724
 fail:10.331
 f:10.3189
 equal:10.2199
 True:10.2141
 error:9.70272
 raise:9.66518
 (:9.5812
 Bool:9.55254

:9.53922
 fl:9.36908
 ():9.28779
 eq:8.95634
 if:8.93457

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <false>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Boolean literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: false
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: false
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:17.8751

:15.8303
 :14.0151
 in:13.6132
  :12.1618
                :11.5681
        :11.3684
   :11.3112
    :11.2059
;:10.7492
            :10.5511
      :10.1149
     :10.0924
end:9.91248
 #:9.70519
          :9.45355
         :9.44347
 //:9.40319
       :9.25949
           :9.0031
             :8.8459

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false end

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false end
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {e2: Exp, e1: Exp, equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Exp, Exp) -> Bool)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: ((Exp, Exp) -> Bool)
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.9299

:17.7572
 :15.3389
;:14.2021
  :14.1384
    :13.2401
   :12.9835
in:12.485
 #:12.3456
        :12.333
 end:11.9117
     :11.3506
                :11.2946
      :11.262
 and:11.1459
 with:10.9319
;;:10.6436
            :10.551
 //:10.5038
 ;:10.3582
.:10.2738

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false end in

Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false end in
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "Ap" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Lam" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Var" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.9514
 :14.5831
  :13.5116
    :12.9088
   :12.3531
        :12.0837
                :11.6683
      :11.4746
     :11.471
            :11.1153
          :10.8286
         :10.6906
 #:10.2907
           :10.2741
       :10.1478
              :9.81258
             :9.57714
	:9.57084
               :9.27469
 {:8.757
;:8.75684

================
# A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false end in


Debug: true, Constrain: Types
LSP: New token mode: # A simplified lambda calculus expression containing variables, lambdas, and applications #
type Exp =
  + Var(String)
  + Lam(String, Exp)
  + Ap(Exp, Exp)
in

# Check if two expressions are equal #
let equal: (Exp, Exp) -> Bool =
    fun e1, e2 ->
        case e1, e2
        | Var(x1) , Var(x2) => x1 
        | Lam(x1, e1) , Lam(x2, e2) => x1 
        | Ap(e1, e1) , Ap(e2, e2) => equal(e1, e2) && equal(e1, e2)
        | _ => false end in

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {equal: ((Exp, Exp) -> Bool), Var: (String -> Exp), Lam: ((String, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Ap: ((rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}) -> Exp), Exp:: rec α.{(Var(String) + Lam((String, α)) + Ap((α, α)))}, AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String  
Error in term:
  x1
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: equal string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Var Lam Ap AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - AlignItems Ap BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Lam Margin Opacity Outline Overflow Padding Position S Var Width [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float equal exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "Ap" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Lam" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Var" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "equal" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.6768
    :16.2482
        :15.6434
in:14.9945
#:14.7075
  :14.5206
   :14.4615
```:14.1825
let:13.8463
                :13.3367
            :13.2994
 :13.2814
     :12.5121
       :12.4549
      :12.4162
         :11.857
equal:11.7454
          :11.6988
print:11.4657
           :11.3157
	:11.2549
