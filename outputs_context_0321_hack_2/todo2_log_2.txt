

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.4781
 :16.3724
 fun:15.1736
  :13.4225
    :12.4937
                :12.2859
   :12.1469
 (:11.6577
 function:11.5135	rejected
      :11.1549
 #:10.9569	rejected
        :10.9271
     :10.677
fun:10.4572
            :10.4231
 switch:10.4071	rejected
         :10.3866
 match:10.3339	rejected
 \:10.2221	rejected
 action:10.2066	rejected
	:10.1913	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :21.162
   :16.3167
  :15.0691
fun:14.7799
 fun:14.5433
 let:13.0963

:12.7827
    :12.3384
	:12.2149	rejected
let:11.9929
#:11.526	rejected
     :11.3908
 switch:11.1513	rejected
switch:10.8689	rejected
 func:10.6885	rejected
 match:10.5406	rejected
|:10.329	rejected
func:10.3078	rejected
match:10.2797	rejected
      :10.2371
       :10.0575

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
 

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:18.7375
 let:15.3876
 switch:12.9978	rejected
 match:12.8372	rejected
 (:12.4229
 function:12.01	rejected
 #:11.7863	rejected
 f:11.4806
 (*:11.2161	prefix accepted: (
 |:11.0566	rejected
 case:10.7755
 Model:10.6037
 {:10.5228	rejected
 action:10.2273	rejected
 with:10.1847	rejected
 func:10.1215	rejected
 ~:10.073	rejected
 fn:10.0674	rejected
 ((:10.052	prefix accepted: (
 handle:10.0313	rejected
 go:9.893	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.004
 ((:16.7138	prefix accepted: (
 model:16.658
 m:15.7951
 ({:14.8522	prefix accepted: (
 state:14.5032
 old:12.9239
 {:12.6391	rejected
 todo:12.628
(:12.28
 current:12.0579
 prev:11.9978
 s:11.9355
 x:11.9237
 _:11.6352
 init:11.573
 :11.5324
((:11.3834	prefix accepted:(
 data:11.3335
 t:11.1583
 previous:11.132

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:17.4772
description:16.2735
model:15.4441
desc:14.254
buf:14.1172
_,:14.0836	prefix accepted:_
b:14.0488
buff:13.342
d:12.9762
des:12.5532
state:12.5042
text:12.255
input:12.19
t:12.1591
old:12.0182
s:11.5596
current:11.5384
m:11.4051
tod:10.9382
title:10.9343
x:10.301

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: (Model, Action), update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.3031
_:13.7716
_,:13.5973	prefix accepted:_
1:13.5251
',:13.382	rejected
0:13.2102
 ,:13.198
Model:11.4282
$,:11.1969	rejected
__:10.8641
::10.8525	rejected
 $:10.7738	rejected
 as:10.538	rejected
,[:10.3092	prefix accepted:,
2:10.1214
Text:9.97427
Description:9.8786
$:9.79943	rejected
T:9.76685
ed:9.7173
,,:9.62946	prefix accepted:,

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:15.7334
 todo:13.9116
 ts:12.394
 _:12.1239
 state:11.8638
 model:11.6615
 list:11.2835
tod:11.1305
 items:11.0799
 tod:10.928
 old:10.8921
 xs:10.4436
 entries:10.2666
 (:10.2575
 _):9.96032	prefix accepted: _
 tasks:9.87316
 Tod:9.82877	rejected
 current:9.48605
 to:9.33957
 {:9.32637	rejected
 t:9.28969

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: Action, buffer: Model, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
),:18.3734
):14.978
 as:14.5463	rejected
_:13.0406
,:12.1056
)::11.2772	prefix accepted:)
1:11.2297
),(:11.202	prefix accepted:),
 ),:10.7892
)->:10.7345	prefix accepted:)
0:10.6129
'),:9.95888	rejected
)=:9.91395	prefix accepted:)
::9.44995	rejected
)(:9.28195	prefix accepted:)
2:8.8888
 ::8.83796	rejected
()),:8.83621	prefix accepted:(
 =:8.8024	rejected
',:8.65877	rejected
)):8.60487

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos),

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos),
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ((String, [(String, Bool)]), (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 action:18.7599
 a:15.2335
 msg:14.1761
 act:13.7944
 message:13.6887
 todo:12.6643
 event:12.2799
 x:11.8501
 what:11.5978
 (:11.196
 e:11.1641
 next:11.083
 cmd:11.035
 t:10.9325
 input:10.7467
 :10.6878
 v:10.6219
 actions:10.4751
 _:10.3792
action:10.3275
 {:10.1179	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.5637
->:14.3483
 :13.5246
 =>:13.1472	rejected
_:12.1102
::11.5947	rejected
 =:11.2629	rejected

:11.2628
$:11.0323	rejected
 ::10.8944	rejected
':10.5855	rejected
  :10.3347
 +:10.2552	rejected
 {:10.2296	rejected
0:10.0753
 :10.0183	rejected
 -:9.88342
1:9.67301
?:9.65341	rejected
 ?:9.50247	rejected
 $:9.50154	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.3592
 :15.9528
  :15.2679
    :14.4027
   :14.2143
 match:14.1205	rejected
     :13.607
      :13.5884
                :13.4747
 case:13.3749
        :13.0244
         :12.7312
 #:12.3439	rejected
 ?:11.8998	rejected
          :11.8808
       :11.8782
 begin:11.8426	rejected
 {:11.8067	rejected
            :11.7104
#:11.7021	rejected
 (:11.5299

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :21.486
 :17.2994
  :16.9542
     :16.8165
    :16.4021

:14.9309
case:14.687
match:13.9728	rejected
      :13.9465
       :13.7251
         :13.4143
	:13.204	rejected
        :13.1251
switch:12.732	rejected
 case:12.6311
           :12.3493
 match:12.2822	rejected
                :11.9394
#:11.9153	rejected
          :11.5268
             :11.2301

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:18.5736
 match:16.445	rejected
 let:14.9465
 switch:12.8886	rejected
 (:12.8612
 print:11.9922	rejected
 if:11.4302
 #:11.1165	rejected
 action:10.9674
 todo:10.9448
 begin:10.7814	rejected
 model:10.5206	rejected
 (*:10.3743	prefix accepted: (
 printf:10.3644	rejected
 {:10.2652	rejected
 Model:10.256
 buffer:10.2277
 var:9.9873	rejected
 Tod:9.96898
 List:9.7059	rejected
 ?:9.51705	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:17.8573
 buffer:12.6254
 todo:11.4084
 todos:11.3632
 (:11.2184
 :10.9814

:10.5186
 @:9.98293	rejected
 Tod:9.8695
_:9.82748	rejected
 Action:9.79038	rejected
 add:9.73818
(:9.62284
 #:9.50929	rejected
 update:9.50866
 show:9.14001	rejected
 List:9.07717	rejected
 Buffer:9.04068	rejected
::9.01002	rejected
 s:8.97262
 ::8.95033	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.7965
 :15.9228
  :14.9719
    :14.5863
 of:14.5068	rejected
      :14.4304
     :14.1883
                :12.8095
   :12.785
         :12.6766
        :12.5891
 in:12.1787	rejected
,:12.0605
          :12.0296
::11.9825
       :11.8607
             :11.7498
            :11.7244
 #:11.6692	rejected
 |:11.665
 {:11.6212	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.7156
     :16.4016
    :15.7935

:14.7253
  :14.3612
#:13.6081	rejected
 :13.4148
      :13.3544
        :13.0596
|:12.5237
       :12.2047
         :11.9234
	:11.6408	rejected
 |:11.3635
                :11.0228
          :10.8675
            :10.4631
           :10.1655
(*:10.1192	prefix accepted:(
             :10.0801
##:9.73783	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.8266
 #:15.7899	rejected
 +:13.9864
 (*:12.4326	prefix accepted: (
 {:12.3182	rejected
 ##:11.9339	rejected
 #{:11.6996	rejected
 ||:11.6198	prefix accepted: |
 #[:11.5018	rejected
 ~:11.4708	rejected
 /*:11.4077	prefix accepted: /
 //:11.3247	prefix accepted: /
 match:11.2213	rejected

:10.8528
 <:10.8436
 ?:10.8128	rejected
 -:10.6443
 *:10.6401
 |\:10.5239	prefix accepted: |
 [:10.5084	rejected
 (+:10.4735	prefix accepted: (

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:19.4719
 Update:15.8238
 Remove:13.605
 T:12.9886
 _:12.687
Add:11.7705
 Tod:11.6494	rejected
 (:11.4868
 :11.4545
 Action:11.3541	rejected
 #:11.2029	rejected
 +:11.1679	rejected
  :10.9514
 @:10.8598	rejected
 Clear:10.2018	rejected
 add:10.2004
 ?:10.1554	rejected
 ~:10.0749	rejected
 {:9.93519	rejected
 Init:9.75361	rejected
 ::9.60477	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | Add

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | Add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:21.3458
 =>:12.3336	rejected
t:12.0625	rejected
To:11.9877
(:11.8884	rejected
 ->:11.863	rejected
 todo:11.7834	rejected
_:11.53	rejected
():11.288	rejected
Action:10.9877	rejected
New:10.7489	rejected
TO:10.6037	rejected
    :10.5133	rejected
 Tod:10.4704	rejected
      :10.2228	rejected
     :10.1252	rejected
Text:10.0718	rejected
         :9.78228	rejected
  :9.73373	rejected
   :9.73187	rejected
Item:9.66186	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddT"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddT
LSP: Generating Completions for prefix: AddT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:24.8119
odos:15.0498	rejected
od:14.5053
oto:13.8854	rejected
udo:11.9274	rejected
d:11.487	rejected
ogo:10.9625	rejected
odd:10.7543	rejected
do:9.8591	rejected
og:9.83699	rejected
oda:9.62821	rejected
of:9.46335	rejected
dd:9.33834	rejected
odio:9.32972	rejected
oco:9.24137	rejected
 todo:8.84532	rejected
odu:8.72167	rejected
os:8.58589	rejected
omo:8.58232	rejected
odon:8.54903	rejected
ok:8.39746	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.3621
     :13.9499
      :13.8563
 ->:13.6943	rejected
    :13.6197
         :13.4621
        :13.0314
          :12.6187
 when:12.549	rejected
       :12.5486
  :12.5355
   :12.1314
           :12
 _:11.8982	rejected
                :11.867
             :11.7859
 :11.5894
            :11.5101
():11.4795	prefix accepted:(
(_:11.3864	rejected
=>:10.9424

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:16.4125
 (":14.7947	prefix accepted: (

:14.7666
 :13.6914
 add:13.0604
 buffer:12.8055
 Model:12.7175
 let:12.0912
  :12.0688
                :11.8225
 if:11.8224
    :11.5149
 List:11.3308	rejected
 ((:11.3093	prefix accepted: (
      :11.2097
     :11.1637
 (!:11.1598	prefix accepted: (
        :11.0253
         :11.0229
 {:10.9516	rejected
            :10.8608

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:14.9075
 "",:13.8767	prefix accepted: ""

:12.4874
if:12.3659
List:11.9843	rejected
?,:11.9123	rejected
String:11.7753	rejected
action:11.2061
(":11.0324	prefix accepted:(
model:11.0097	rejected
add:10.8666
Model:10.7152
f:10.6896
buf:10.6351
_,:10.2491	rejected
:10.0907	rejected
<:10.057	rejected
[":9.9777	prefix accepted:[
 buffer:9.90732
update:9.82597
&:9.71633	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "Model"); syn = String})))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Model but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.275
 $:13.4289
 @:12.8929
.:12.5634	rejected
 +:11.9298
 "",:11.6092	rejected
 =:11.0929
 ,:10.7457
=":10.6963	prefix accepted:=
@:10.6161
 |:10.5904	rejected
 ^:10.5218	rejected
 &:10.1442
$:9.93176
=:10.6963
 ==:9.63423
,":9.57528	prefix accepted:,
 :=:9.47102	prefix accepted: :
_:9.46017	rejected
',:9.38448	rejected
 ++:9.24697

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 add:18.2382
 List:13.4182	rejected
 [:12.1349
 (:12.0156
 todos:11.9828
 buffer:11.964
  :11.2071
 todo:11.056
    :10.9826
         :10.9541
 :10.8547
     :10.6142
      :10.5486
        :10.4756
 ""):10.4655	prefix accepted: ""
add:10.4318
 if:10.411
 [],:10.3224	prefix accepted: []
 Tod:10.3171
                :10.2619
          :10.018

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ((String, [(String, Bool)]) -> [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn = (Arrow ((Var "Model"), (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  add
Nature of error: Expecting type [Todo] but got inconsistent type (Model -> [Todo])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: add
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: add
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:19.2689
((:17.2952	prefix accepted:(
([:13.1331	prefix accepted:(
 (:12.9909
({:12.4713	prefix accepted:(
):12.4092
 ((:12.3776	prefix accepted: (
()):12.2042	prefix accepted:(
 todos:10.7706	rejected
[(:10.7247	rejected
 buffer:10.6736	rejected
(!:10.6472	prefix accepted:(
(":10.5242	prefix accepted:(
<:10.0876
 todo:10.0729	rejected
!(:9.91692	prefix accepted:!
[:9.85075	rejected
:(:9.75347	prefix accepted::
)(:9.72214	prefix accepted:)
,:9.71113
  :9.61681

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
tod:17.5979
buffer:16.5868
 buffer:10.4555
List:10.4161	rejected
 todos:10.3738
to:10.1556
t:10.1068
td:9.91962	rejected
 (:9.8729
buf:9.55761
Model:9.23718
model:9.23341	rejected
toString:9.14949	rejected
String:9.05704	rejected
add:8.96664
update:8.89689
buff:8.86925
list:8.76736	rejected
0:8.61857
Buffer:8.59013	rejected
(":8.57558	prefix accepted:(

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(tod

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(tod
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tod>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "tod"))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  tod
Nature of error: Variable tod is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: tod
LSP: Generating Completions for prefix: tod
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "os"
root ::= completions

Top 20 Logits:
os:25.3553
ol:11.5082	rejected
om:11.0764	rejected
 os:10.8755	rejected
as:10.01	rejected
oc:9.03154	rejected
ays:8.93978	rejected
ost:8.92885	rejected
ios:8.90773	rejected
ob:8.86219	rejected
od:8.80139	rejected
oid:8.80027	rejected
is:8.70982	rejected
oss:8.66226	rejected
of:8.52352	rejected
:8.46464	rejected
on:8.43569	rejected
oo:8.3894	rejected
_:8.30335	rejected
ot:8.2653	rejected
0:8.25255	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Model"); syn = (List (Var "Todo"))})))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):19.7667
,:15.0241
):13.1788
)),:13.1465	prefix accepted:))
 @:12.7256
));:11.9947	prefix accepted:))
),:11.3281	prefix accepted:)
)(:11.1466	prefix accepted:)
::11.0903
@:11.0512
)::10.946	prefix accepted:)
))::10.9395	prefix accepted:))
 ::10.56
 =:10.2913
))):10.1953	prefix accepted:))
(:10.184
=:9.99216
)).:9.95034	prefix accepted:)
.:9.86463	rejected
);:9.81914	prefix accepted:)
 |:9.68477	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.0628
 :14.4356
    :14.0116
  :13.9769
                :13.5443
 #:13.4162	rejected
      :13.2394
     :12.9448
        :12.4166
 (*:12.1779	prefix accepted: (
         :11.9777
   :11.9601
          :11.8771
            :11.8341
           :11.7522
#:11.6869	rejected
             :11.3998
       :11.2485
              :10.8999
               :10.8194
 end:10.7753

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.9501
    :16.0483

:15.3856
  :14.7039
     :14.6844
#:14.5339	rejected
	:14.151	rejected
        :13.4176
 :13.2212
      :13.0742
                :13.072
       :12.4198
|:12.3689
(*:12.2428	prefix accepted:(
         :11.876
            :11.3888
end:11.1558
          :11.046
           :10.915
               :10.8822
              :10.6255

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.6422
 #:16.2787	rejected
 (*:14.312	prefix accepted: (
 \:13.1397
 end:12.6589
 +:12.4727
 <:12.3967
 //:12.3182	prefix accepted: /
 ||:12.2964	prefix accepted: |
 /*:11.8361	prefix accepted: /
 ##:11.8252	rejected
 ~:11.7926	rejected
 ?:11.7564	rejected
 !:11.7468
 |\:11.7463	prefix accepted: |
 ^:11.7423	rejected
 ...:11.4915	rejected
 *:11.461
 >:11.3805
 /:12.3182
 {:11.2724	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Remove:19.9555
 Update:17.7131
 T:16.8277
 _:13.9959
 Rem:13.1167
 (:11.7856
 Delete:11.4756	rejected
 remove:10.6904
 :10.5601
Remove:10.5552
 Clear:10.3231	rejected
 Add:9.78559
 (_:9.62304	rejected
 Tod:9.52151	rejected
 #:9.51434	rejected
 @:9.49846	rejected
 Re:9.32363
 ?:9.25722	rejected
 Change:9.17145	rejected
 Insert:9.16492	rejected
 Set:9.10704	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | Remove

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | Remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  Remove
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:20.9931
(:12.8636	rejected
 todo:12.7297	rejected
To:11.2498
 Tod:11.1262	rejected
TO:11.0488	rejected
_:10.5419	rejected
Action:10.2116	rejected
Item:10.0374	rejected
 (:9.74235	rejected
 i:9.63281	rejected
 index:9.60727	rejected
Token:9.14518	rejected
 x:8.99423	rejected
Index:8.95831	rejected
((:8.90755	rejected
 :8.90156	rejected
 item:8.75511	rejected
(_:8.68156	rejected
 t:8.5884	rejected
 action:8.47568	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveT"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  RemoveT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveT
LSP: Generating Completions for prefix: RemoveT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:25.6559
odos:17.7275	rejected
oto:15.1336	rejected
od:14.6942
do:14.3836	rejected
odd:14.0006	rejected
o:13.0243
of:12.8721	rejected
udo:12.8067	rejected
oko:12.7287	rejected
omo:12.5758	rejected
DO:12.5275	rejected
ovo:12.3987	rejected
odio:12.1671	rejected
ogo:12.1453	rejected
oda:11.9609	rejected
d:11.7767	rejected
odon:11.2269	rejected
obe:11.186	rejected
oo:11.1586	rejected
odu:11.1442	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (Int -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow (Int, (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  RemoveTodo
Nature of error: Expecting type Action but got inconsistent type (Int -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: RemoveTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:17.4644
 index:17.3869	rejected
 i:15.7226	rejected
 idx:15.126	rejected
 n:14.2348	rejected
 id:13.1463	rejected
 (:12.6382
 todo:12.2236	rejected
 x:12.1081	rejected
 at:11.6045	rejected
 k:11.5178	rejected
(_:11.3709	rejected
 key:10.8041	rejected
 :10.3957
 t:10.3874	rejected
 pos:10.3531	rejected
 remove:10.2054	rejected
($:9.97819	prefix accepted:(
 _:9.96378	rejected
 ind:9.8565	rejected
 p:9.83283	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
index:19.9533
i:18.058
idx:17.7871
n:15.8794
id:15.2355
x:14.3494
t:14.125
ix:13.3624
k:12.5828
key:12.5058
pos:12.1651
 index:11.7859
ind:11.5792
at:11.5776
remove:11.5317
position:11.4899
0:11.3471
int:11.2204
j:11.2122
num:11.1407
a:10.9334

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):19.863
 as:13.835	rejected
)=:12.9451	prefix accepted:)
)->:12.843	prefix accepted:)
 ):12.7512
),:12.2729
,:12.2542
1:11.9291
_:11.748
)::11.4976	prefix accepted:)
0:11.1204
'):10.906	rejected
::10.7243	rejected
_):10.4868	prefix accepted:_
2:10.0432
To:9.82278
 :9.61176
)|:9.56304	prefix accepted:)
T:9.47181
=:9.4127	rejected
n:9.31977

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.7088
  :14.7463
 :14.3211
 ->:13.8354	rejected
 when:12.9019	rejected
    :12.8263
   :12.427
     :12.1713
      :11.658
=>:11.514

:11.3425
       :10.9126
        :10.5359
         :10.4376
 :=:10.3942	rejected
 =:10.2029
 :::10.1538	rejected
 ==>:10.0979	prefix accepted: =
          :9.63121
 ::9.46237	rejected
            :9.14875

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:17.7407
 (":16.1789	prefix accepted: (

:13.207
 :13.0183
 remove:12.9372
(:12.3461
 update:11.8151
 ((:11.8079	prefix accepted: (
 buffer:11.3226
 if:11.1727
 (!:10.9286	prefix accepted: (
 (\:10.917	prefix accepted: (
 todo:10.7806
 let:10.6686
  :10.6119
(":10.4323	prefix accepted:(
 (_:10.4245	rejected
 List:10.3915	rejected
 ":10.1928
 ([:10.1535	prefix accepted: (
 ({:9.99834	prefix accepted: (

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:19.0464
tod:12.4315
?,:12.3949	rejected
 buffer:12.259
buf:11.7954
List:11.5029	rejected
(":11.5	prefix accepted:(
action:11.1272

:10.932
remove:10.7316
if:10.6498
 "",:10.6291	prefix accepted: ""
update:10.483
t:10.4055
String:10.2497	rejected
add:10.2464
f:10.1027
buff:10.0551
_,:9.90547	rejected
description:9.86524	rejected
button:9.81236	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "Model"); syn = String})))
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type Model but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.1714
 ,:13.5125
 @:12.3878
 +:11.2216
.:10.8257	rejected
 todo:10.3676	rejected
,(:10.2802	prefix accepted:,
@:10.1661
:::9.80149
,,:9.71034	prefix accepted:,
 todos:9.55442	rejected
 $:8.81551
,\:8.66195	prefix accepted:,
 (:8.65862
[:8.58957	rejected
),:8.50296	prefix accepted:)
 :::8.49982
):8.50296
_:8.45274	rejected
 =:8.43449
::8.40569

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 remove:20.7265
remove:13.278
 List:13.2032	rejected
 (:12.5689
 :12.5388
 toggle:12.385
 todos:12.1688
 todo:11.8979
 delete:11.4206	rejected
  :11.3817
 rm:10.2804	rejected
 rem:10.1065

:10.0765
 Tod:9.94439
 [:9.8718
 tod:9.79608
 update:9.76565
 Remove:9.7002
    :9.62121
 s:9.39406
 add:9.31778

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ((Int, [(String, Bool)]) -> [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn =
           (Arrow ((Prod [Int; (List (Var "Todo"))]), (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  remove
Nature of error: Expecting type [Todo] but got inconsistent type ((Int, [Todo]) -> [Todo])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: remove
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: remove
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.7148
((:18.3102	prefix accepted:(
([:16.3317	prefix accepted:(
 (:14.6182
({:12.8563	prefix accepted:(
(!:12.6749	prefix accepted:(
(@:12.4842	prefix accepted:(
(?:12.4616	prefix accepted:(
[:12.0266	rejected
 ((:11.9204	prefix accepted: (
 idx:11.7138	rejected
<:11.6105
_:11.38	rejected
(-:11.3227	prefix accepted:(
!(:11.2475	prefix accepted:!
(&:11.0973	prefix accepted:(
):11.0806
 todo:10.9891	rejected
)(:10.9739	prefix accepted:)
()):10.8765	prefix accepted:(
($(:10.7726	prefix accepted:(

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:18.4279
tod:17.1361
index:12.7381	rejected
 idx:11.8728
id:11.4187
td:11.1814	rejected
buffer:11.0761
to:10.7169
t:10.6871
tid:10.6735	rejected
 todos:10.5402
tok:10.2137	rejected
i:10.0009
buf:9.9215
indexOf:9.55755	rejected
xs:9.52426	rejected
0:9.51675
ids:9.43102	rejected
idos:9.31525	rejected
remove:9.24112
int:9.16435

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (List (Var "Todo"))]); syn = Int})))
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  idx
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.6408
 -:13.4823
 ,:13.4062
 +:13.3084
)):13.2268
)(:11.7732	prefix accepted:)
-:11.5982
 @:11.1584
+:11.133
,(:11.0318	prefix accepted:,
.:10.7876	rejected
 todo:10.7071	rejected
:::10.5245
 :::10.369
 *:10.3334
 todos:10.0922	rejected
@:10.0393
),:9.96529	prefix accepted:)
):11.7732
::9.66896
)),:9.6463	prefix accepted:))

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:18.6235
tod:13.1819
 tod:13.0157
 todo:12.4543
 :11.9752
 add:11.6061
 remove:11.0183
  :10.9281
 Tod:10.4299
 toggle:10.2658
 List:10.1574	rejected
 (:9.98395
 to:9.87938
odos:9.6398	rejected
 [:9.5025
 xs:9.44865	rejected
 buffer:9.39808
 td:9.30543	rejected
 list:9.09929	rejected
 action:9.07676
 !:8.72721

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):21.3387
)),:15.6033	prefix accepted:))
):14.9491
));:14.2818	prefix accepted:))
))):13.5224	prefix accepted:))
))::12.6289	prefix accepted:))
 :12.6134
),:11.8633	prefix accepted:)
)).:11.6512	prefix accepted:)
,:11.4856
)::11.3966	prefix accepted:)
())):11.3202	prefix accepted:(
 ):11.1625
)(:11.0692	prefix accepted:)
);:10.8797	prefix accepted:)
)));:10.6067	prefix accepted:))
))$:10.5964	prefix accepted:))
))\:10.5368	prefix accepted:))
)[:10.4782	prefix accepted:)
))]:10.3882	prefix accepted:))
_:10.2257	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.8487
 :15.2756
  :14.7779
    :14.5531
     :13.2789
      :13.2771
#:13.1559	rejected
   :12.6309
        :12.6225
       :12.2685
                :12.1852
 #:11.8815	rejected
            :11.5107
         :11.4701
          :11.115
           :10.89
 in:10.6657	rejected
             :10.3722
	:10.3579	rejected
 end:10.1328
              :10.0344

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :21.3934
#:15.1077	rejected
    :15.0506
  :14.4089
	:14.1667	rejected
     :13.8504

:13.542
       :12.9401
 :12.6781
        :12.0628
      :11.9835
|:11.8381
                :11.6147
(*:11.59	prefix accepted:(
 :11.3547	rejected
:11.1784	rejected
         :10.8052
            :10.4463
\:10.4176
end:10.3129
           :10.1592

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.7427
 #:15.0319	rejected
 (*:13.4041	prefix accepted: (
 ||:13.254	prefix accepted: |
 |\:12.8211	prefix accepted: |
 //:12.2454	prefix accepted: /
 !:12.0433
 \:11.9145
 *:11.6587
 ...:11.1209	rejected
 $:11.115
 /*:11.1024	prefix accepted: /
 /:12.2454
 let:10.8958	rejected
 ?:10.8483	rejected
 ::10.7913
 :10.6823	rejected
 $|:10.6438	prefix accepted: $
 <:10.6076
 <<:10.5597	prefix accepted: <

:10.3826

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 T:23.0223
 Update:18.3801
Toggle:14.1468
 _:14.0008
 Tod:12.7449	rejected
 To:12.6691
 :12.6594
 #:12.5482	rejected
 Remove:12.4178
 Clear:12.2003	rejected
 toggle:12.1246
 Set:11.5666	rejected
 TODO:11.3692	rejected
 Edit:11.1801	rejected
 Change:11.1146	rejected
 Show:11.0209	rejected
:10.9192	rejected
  :10.8506
 Switch:10.8155	rejected
 (:10.7961
 TO:10.6544	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | T

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | T
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <T>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "T"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  T
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: T
LSP: Generating Completions for prefix: T
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "oggleTodo"
root ::= completions

Top 20 Logits:
oggle:25.237
ogle:15.1385	rejected
og:14.0724
oga:9.74964	rejected
ogo:9.72	rejected
toggle:9.62382	rejected
Toggle:9.5044	rejected
gl:9.47546	rejected
one:8.89242	rejected
oto:8.80873	rejected
g:8.72768	rejected
d:8.65769	rejected
ople:8.65009	rejected
utorial:8.47405	rejected
agger:8.31664	rejected
oge:8.23375	rejected
ou:8.15428	rejected
angle:8.09679	rejected
icker:8.0837	rejected
oc:8.07042	rejected
gle:8.02692	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | Toggle

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | Toggle
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Toggle>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Toggle"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  Toggle
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Toggle
LSP: Generating Completions for prefix: Toggle
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:21.5633
TO:14.4064	rejected
To:13.5005
(:12.661	rejected
Done:12.2403	rejected
 todo:12.1761	rejected
 Tod:11.5863	rejected
Item:10.1136	rejected
Toggle:9.98908	rejected
_:9.76441	rejected
t:9.69443	rejected
 (:9.17582	rejected
((:8.90951	rejected
TD:8.86327	rejected
 TODO:8.75249	rejected
Add:8.72118	rejected
D:8.61561	rejected
Entry:8.60636	rejected
All:8.58289	rejected
Task:8.52178	rejected
Do:8.50511	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleT

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleT
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ToggleT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "ToggleT"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  ToggleT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: ToggleT
LSP: Generating Completions for prefix: ToggleT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:24.2109
odd:16.8188	rejected
odos:15.9074	rejected
od:15.7835
odb:14.8024	rejected
oto:14.7969	rejected
oda:14.5226	rejected
olo:14.4139	rejected
ood:14.3913	rejected
ogo:13.9125	rejected
udo:13.8894	rejected
oid:13.6195	rejected
odon:13.4865	rejected
dl:13.4847	rejected
oco:13.4331	rejected
odel:13.1023	rejected
do:13.0881	rejected
ogle:12.971	rejected
oko:12.8132	rejected
odi:12.6683	rejected
odio:12.6434	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <ToggleTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (Int -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow (Int, (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  ToggleTodo
Nature of error: Expecting type Action but got inconsistent type (Int -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: ToggleTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ToggleTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:21.1908
 idx:15.1953	rejected
 (:14.3649
(_:13.1182	rejected
((:12.6578	prefix accepted:(
 index:11.8321	rejected
 i:11.7101	rejected
($:11.0169	prefix accepted:(
 =>:10.7584
 at:10.5862	rejected
():10.1962	prefix accepted:(
 id:9.98892	rejected
{:9.93692	rejected
 :9.81527
({:9.68875	prefix accepted:(
 t:9.61393	rejected
 _:9.58691	rejected
 ->:9.58173	rejected
[:9.5007	rejected
 todo:9.48992	rejected
([:9.41518	prefix accepted:(

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:21.6668
i:16.9557
index:16.8482
id:14.83
t:14.6449
n:14.1454
 idx:14.0028
pos:13.9821
toggle:13.1753
ind:12.9434
x:12.4963
j:12.4705
ix:12.2828
at:11.9355
tid:11.8667
position:11.6958
row:11.3288
td:11.3235
key:11.2088
item:11.1183
num:11.0357

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):21.466
)=:14.8496	prefix accepted:)
 ):14.3728
)->:13.2684	prefix accepted:)
1:12.6121
2:12.077
,:11.9067
 as:11.8234	rejected
 =>:11.7119	rejected
),:11.706
'):11.5853	rejected
)):11.3558
0:11.3556
_:10.9375
)::10.5915	prefix accepted:)
_):10.3514	prefix accepted:_
)>:10.0417	prefix accepted:)
T:9.84394
)(:9.62214	prefix accepted:)
 :9.61479
)':9.60772	prefix accepted:)

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.9291
 :14.4166
 ->:14.0666	rejected
  :12.4767
=>:10.9304
 when:10.4918	rejected
 ==>:10.3221	prefix accepted: =
 =:10.3221
   :10.1713

:10.0888
    :9.9907
 :::9.80973	rejected
	:9.76163	rejected
 >:9.72829	rejected
 :=:9.71475	rejected
 :9.26973	rejected
 ==:9.16333	prefix accepted: =
     :9.11756
 -:9.10216	rejected
 if:8.97629	rejected
 <-:8.95898	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.572
 (":14.4105	prefix accepted: (
 :13.6716
(:13.5262
 ((:13.147	prefix accepted: (
 update:12.8927

:12.8439
 if:12.1199
 let:11.7586
 buffer:11.51
 todo:11.4913
 (\:11.0391	prefix accepted: (
  :10.6914
 List:10.4933	rejected
 (!:10.399	prefix accepted: (
 Tod:10.2554
 toggle:10.145
 (@:10.0896	prefix accepted: (
 print:10.0342	rejected
 (*:10.0267	prefix accepted: (
 ([:10.018	prefix accepted: (

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:20.8188
 buffer:13.1884
buf:11.5642
(":11.4178	prefix accepted:(

:11.1226
button:11.108	rejected
tod:11.0281
List:10.9638	rejected
update:10.9293
buff:10.7562
?,:10.5537	rejected
Buffer:10.3622	rejected
Model:10.3522
t:10.3382
model:10.3291	rejected
String:10.1684	rejected
b:10.1082
if:10.0511
add:9.92997
s:9.92842
action:9.81825

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "Model"); syn = String})))
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  buffer
Nature of error: Expecting type Model but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.5158
 ,:14.1352
,(:12.4736	prefix accepted:,
,[:11.1903	prefix accepted:,
,$:11.1589	prefix accepted:,
,,:10.8843	prefix accepted:,
',:10.3701	rejected
$,:10.3185	prefix accepted:$
.:9.79662	rejected
(:9.69409
[:9.6754	rejected
 +:9.57641
,":9.52295	prefix accepted:,
(),:9.25949	prefix accepted:(
::9.13864
 -:9.10333
 as:9.03943	rejected
",:8.99782	rejected
,\:8.94754	prefix accepted:,
.,:8.87751	rejected
?,:8.80254	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 toggle:21.3213
 todo:14.5514
toggle:13.4833
 List:13.2504	rejected
 update:12.5897
 remove:12.4589
 :12.1081
 (:12.0436
 to:11.272
 f:11.2032
 tog:11.1153
 Tod:10.7937
 todos:10.7329
 add:10.632
 togg:10.4272
  :10.1117
 tod:10.0378
 T:9.70258
 TODO:9.52958	rejected
 s:9.49492

:9.32453

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <toggle>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ((Int, [(String, Bool)]) -> [(String, Bool)])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn =
           (Arrow ((Prod [Int; (List (Var "Todo"))]), (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  toggle
Nature of error: Expecting type [Todo] but got inconsistent type ((Int, [Todo]) -> [Todo])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: toggle
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: toggle
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.6736
((:13.7245	prefix accepted:(
 (:13.4198
 idx:12.1948	rejected
_:11.7597	rejected
[:11.4923	rejected
)(:11.2918	prefix accepted:)
):11.2918
!(:11.1089	prefix accepted:!
T:11.0883	rejected
(!:10.3672	prefix accepted:(
?(:10.3376	rejected
([:10.272	prefix accepted:(
(?:10.2098	prefix accepted:(
_(:10.1364	rejected
.(:10.0949	rejected
()):9.95602	prefix accepted:(
<:9.80625
i:9.4348	rejected
.:9.39574	rejected
 ?:9.24502	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
idx:20.907
tod:14.8161
 idx:13.883
index:12.9276	rejected
i:11.6831
buffer:11.5931
id:11.4956
t:11.1924
toggle:10.8576
to:10.6703
0:10.5708
buf:10.5176
td:10.4406	rejected
tid:10.3889	rejected
List:10.3371	rejected
1:10.0254

:9.92314
ids:9.91882	rejected
int:9.91864
indexOf:9.90594	rejected
T:9.71639

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (List (Var "Todo"))]); syn = Int})))
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  idx
Nature of error: Expecting type (Int, [Todo]) but got inconsistent type Int  
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.3177
 ,:14.0312
 +:12.098
)(:11.8049	prefix accepted:)
 todos:11.0986	rejected
)):10.5325
 -:10.4158
+:10.0615
.:9.9589	rejected
),:9.94069	prefix accepted:)
 to:9.93469	rejected
,(:9.81318	prefix accepted:,
 todo:9.7478	rejected
)),:9.13239	prefix accepted:))
 =:9.12869
):11.8049
(:8.86027
::8.83668
-:8.8076
 :8.68898
tod:8.67907	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:19.6167
 :13.0983
 tod:12.8907
tod:12.6067
 todo:12.1844
 add:11.1274
 remove:10.917
 toggle:10.7441
odos:10.5431	rejected
 Tod:10.294
 to:10.269
  :10.0322
 (:9.72702
 List:9.5048	rejected
 tous:9.45735	rejected
 update:9.3443
 list:9.21243	rejected
 model:9.00907	rejected
 ts:8.93699	rejected
 [:8.87613
 tokens:8.86462	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: idx action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):21.8752
)),:16.1853	prefix accepted:))
):14.8677
));:14.7922	prefix accepted:))
 :14.188
))):14.1568	prefix accepted:))
)).:12.3076	prefix accepted:)
),:12.1317	prefix accepted:)
))\:11.7045	prefix accepted:))
))::11.438	prefix accepted:))
)));:11.4171	prefix accepted:))
)))):11.3313	prefix accepted:))
 ):11.1305
)){:11.0189	prefix accepted:))
))`:10.8686	prefix accepted:))
);:10.8216	prefix accepted:)
,:10.8023
))]:10.7865	prefix accepted:))
())):10.7684	prefix accepted:(
))$:10.6778	prefix accepted:))
)(:10.631	prefix accepted:)

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.5532
 :16.2724
    :14.43
  :14.1303
      :13.2385
     :13.1
#:13.0856	rejected
 end:12.7755
 #:12.7732	rejected
        :12.7163
 in:12.5831	rejected
       :12.1771
                :12.166
   :12.0439
            :11.3669
         :11.0782
          :10.7665
	:10.3981	rejected
           :10.381
             :10.1469
end:9.98297

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.3414
#:14.6842	rejected
 :14.574
    :14.4468
  :13.8224

:13.7845
     :13.5165
	:13.3808	rejected
end:13.3445
       :12.9839
        :12.3978
                :12.1274
|:12.1057
      :11.9795
(*:11.3379	prefix accepted:(
\:11.2555
         :11.0182
 #:10.6694	rejected
 |:10.5782
            :10.5725
          :10.3605

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
   

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: Int, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.2906
 #:16.6438	rejected
 end:14.9005
 //:13.0409	prefix accepted: /
 (*:12.6878	prefix accepted: (
 +:11.9374
 in:11.7147	rejected
 *:11.4898
 !:11.4721
 @:11.2883
 <:11.2611
 ||:11.2528	prefix accepted: |
 else:11.2276	rejected
 |\:11.207	prefix accepted: |
 /*:11.1778	prefix accepted: /
 ~:10.9434	rejected
 $:10.8741
 ^:10.7122	rejected
 \:10.6931
 ...:10.6785	rejected
 /:13.0409

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    |

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Update:21.4353
 _:15.1289
 :12.6882
 #:11.7041	rejected
Update:11.7036
 Action:10.971	rejected
 Set:10.9569	rejected
>:10.7559	rejected
 Change:10.5194	rejected
 update:10.4675
 Edit:10.2956	rejected
 Buffer:10.1733	rejected
 T:10.1247
 ?:10.0537	rejected
_:10.0389
 (:9.94573
 Input:9.94278	rejected
 >:9.83367	rejected
 Clear:9.65634	rejected
  :9.56283
 Up:9.33221

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | Update

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | Update
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Update>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Update"))))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  Update
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Update
LSP: Generating Completions for prefix: Update
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Buffer"
root ::= completions

Top 20 Logits:
Buffer:22.8733
B:15.3739
Bu:12.8435
T:12.6286	rejected
buffer:12.2229	rejected
(:12.2209	rejected
BU:12.1671	rejected
_:11.791	rejected
Description:11.552	rejected
Input:11.4598	rejected
Model:11.2898	rejected
 buffer:11.2875	rejected
Button:11.0951	rejected
Text:11.0476	rejected
Desc:10.8908	rejected
Action:10.6838	rejected
 Buffer:10.4002	rejected
To:9.84217	rejected
Des:9.82993	rejected
Browser:9.64093	rejected
Builder:9.59892	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <UpdateBuffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (String -> (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Action");
           syn = (Arrow (String, (Var "Action")))})))
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  UpdateBuffer
Nature of error: Expecting type Action but got inconsistent type (String -> Action)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: UpdateBuffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: UpdateBuffer
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.4463
 buffer:14.5404	rejected
 buf:13.2398	rejected
(":13.1207	prefix accepted:(
(_:13.0033	rejected
 b:12.6235	rejected
 desc:12.4874	rejected
 txt:12.4766	rejected
 text:12.407	rejected
 s:12.3764	rejected
 str:12.3716	rejected
 new:12.1194	rejected
 value:11.662	rejected
 (:11.4457
($:11.3324	prefix accepted:(
 description:11.0649	rejected
 buff:10.3684	rejected
 input:10.3634	rejected
 content:10.2648	rejected
 t:10.1543	rejected
 x:10.0564	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "RemoveTodo" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buf:17.1672
new:16.6878
buffer:16.3699
txt:16.2495
s:16.2188
b:16.1418
text:15.8824
str:15.6164
description:15.3381
input:14.8862
x:14.6734
value:14.6036
desc:14.5134
content:14.0662
buff:13.9442
t:13.6014
contents:13.4482
d:13.4268
v:12.9934
string:12.9284
next:12.8917

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <s>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: String
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: s
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: s
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):19.0954
'):13.5515	rejected
1:13.4285
 ):12.1868
2:12.1605
)=:12.1375	prefix accepted:)
buffer:11.4914
::11.2977	rejected
),:11.2559
,:11.1063
_:11.0391
0:11.0272
uf:11.0124
)->:10.8896	prefix accepted:)
buf:10.8689
nd:10.357
)::10.0397	prefix accepted:)
':9.94072	rejected
napshot:9.86878
Buffer:9.86517
)):9.80121

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.0767
 :17.6579
 ->:14.7495	rejected
  :13.4465
 when:13.3901	rejected
 =:12.18
 if:11.0618	rejected
 :=:10.7808	rejected

:10.6312
   :10.5623
 :::10.485	rejected
    :10.3458
 ?:9.96656	rejected
=>:9.8031
 ==>:9.64285	prefix accepted: =
	:9.59538	rejected
 ==:9.58383	prefix accepted: =
 >:9.52903	rejected
 {:9.47798	rejected
     :9.33201
 ::9.10191	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) =>

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: s action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "s" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.069
 s:14.6648
 :14.4255
 (":14.0255	prefix accepted: (
 if:13.9259
 ((:13.5791	prefix accepted: (

:13.2091
 let:11.7699
 Model:11.6277
(:11.3136
 buffer:11.138
 {:10.9611	rejected
 List:10.6328	rejected
 update:10.3498
  :10.3406
 match:10.2131	rejected
 [:10.0321
 (!:9.88642	prefix accepted: (
 @:9.83957	rejected
 print:9.8366	rejected
 <:9.80609	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: s action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: s action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "s" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
s:18.8125
buffer:14.2483
update:13.0591
if:12.6336
String:12.4075	rejected
 s:11.8611
action:11.2502
f:11.1963
Update:11.0994
buf:10.8277
Model:10.7724
model:10.6831	rejected
List:10.537	rejected
string:10.4494

:10.1672
S:10.1084	rejected
add:10.105
str:10.0614
(":10.048	prefix accepted:(
Action:9.8562	rejected
t:9.77978

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <s>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "Model"); syn = String})))
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]  
Error in term:
  s
Nature of error: Expecting type Model but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: s
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: s
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: s action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "in" | "qrt" | "tring_compare" | "tring_concat" | "tring_contains" | "tring_length" | "tring_of_bool" | "tring_of_float" | "tring_of_int" | "tring_sub" | "tring_trim"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:18.9829
 ,:13.5417
.:11.3338	rejected
 $:11.2713
:::10.7754
 +:10.6306
,[:10.167	prefix accepted:,
 ::10.1079
     :10.0739
 :10.0654
 @:10.035
      :9.94914
    :9.85201
 ?:9.81015	rejected
 ||:9.78452	rejected
 buffer:9.5872	rejected
):9.45793
  :9.41198
 :::9.40439
 ==:9.3242
       :9.27284

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s,

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: s action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: s action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "add" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "s" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todos" | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:17.8635
    :13.5409
 :13.3455
  :13.0107
     :12.7772
 todo:12.5144
   :12.2755
 List:12.2252	rejected
 tod:12.0354
 [:11.9643
 add:11.4735
      :11.456
 if:11.199
tod:11.0249
       :10.7172
 remove:10.6727
 (:10.5774
 Tod:10.516
 Model:10.4438
odos:10.289	rejected
                :9.92417

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [(String, Bool)]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: s action todos buffer update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):20.4575
 end:14.9476	rejected
 ):14.4991
);:13.8403	prefix accepted:)
),:12.664	prefix accepted:)
 in:12.5484	rejected
)):12.2348
)\:11.9329	prefix accepted:)
 @:11.5916

:11.5038
)$:11.4754	prefix accepted:)
 +:11.3363
 :11.1751
)::11.0907	prefix accepted:)
.:10.8843	rejected
)":10.7437	prefix accepted:)
,:10.7299
));:10.6557	prefix accepted:))
)`:10.5956	prefix accepted:)
).:10.5725	rejected
)|:10.5423	prefix accepted:)

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos)

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {s: String, action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:17.4565
 in:13.8411	rejected

:13.7241
 :13.4416
end:12.0117
  :10.941
 #:10.3197	rejected
    :10.001
                :9.61875
      :9.37402
   :9.27117
     :9.25772
        :8.96671
 (*:8.69204	prefix accepted: (
       :8.57497
 |:8.4111
#:8.33319	rejected
            :8.27301
 ->:7.99669	prefix accepted: -
in:7.81826	rejected
         :7.75599

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos) end

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos) end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [(String, Bool)])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, todos: [Todo], buffer: String, update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.5074
 :14.1757

:13.8511
#:13.736	rejected
 #:12.329	rejected
  :11.5446
in:10.692
 end:10.4501	rejected
    :10.3991
;:10.2601	rejected
   :9.62999
     :9.18845
;;:9.0054	rejected
##:8.91415	rejected
[:8.89881	rejected
 with:8.88712	rejected
      :8.75875
 <:8.71362
 ;;:8.66147	rejected
 +:8.56562
.:8.53098	rejected

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos) end in

LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos) end in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.7081
#:17.0986	rejected
 :15.0187
 #:14.7272	rejected
  :13.4947
    :13.2112
      :11.9233
     :11.8866
                :11.6888
##:11.5596	rejected
   :11.4511
        :11.2069
       :11.1486
            :10.4092
         :10.3954
          :10.3147
	:10.0942	rejected
           :9.93753
}:9.83538	rejected
\:9.80462	rejected
              :9.75535

================
# TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos) end in


LSP: Command: Completions(Context)
LS: New token mode: # TODO MVU: Handle TODO actions to update the app model #

let update: (Model, Action) -> Model =
  fun (buffer, todos), action ->
    case action
    | AddTodo => (buffer, add(todos))
    | RemoveTodo(idx) => (buffer, remove(idx, todos))
    | ToggleTodo(idx) => (buffer, toggle(idx, todos))
    | UpdateBuffer(s) => (s, todos) end in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), toggle: ((Int, [Todo]) -> [Todo]), remove: ((Int, [Todo]) -> [Todo]), add: (Model -> [Todo]), Model.init: Model, Model.eq: ((Model, Model) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Update:: ((Model, Action) -> Model), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  todos
Nature of error: Expecting type Model but got inconsistent type [Todo]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update toggle remove add Model.init Model.eq Todo.eq string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "Model.eq" | "Model.init" | "RemoveTodo" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "[" | "[]" | "abs" | "abs_float" | "acos" | "add" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "remove" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "toggle" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.0733
#:18.2877	rejected
  :16.1296
    :15.5779
 :15.5145
let:15.1835
      :13.899
```:13.3767	rejected
                :13.3747
     :13.2963
   :13.0217
 #:12.9927	rejected
        :12.6688
            :12.4606
       :12.3883
}:12.3269	rejected
type:12.2441
update:12.2082
{:12.1906	rejected
          :12.121
	:12.0035	rejected
