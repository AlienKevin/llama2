

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.556
 :16.1648
 fun:15.1698
  :14.2217
    :12.8526
                :11.997
 function:11.983	rejected
 \:11.6472	rejected
     :11.5326
   :11.5063
 (:11.162
      :11.0561
 #:11.0323	rejected
 {:11.014	rejected
	:10.8333	rejected
        :10.7351
 ?:10.6177	rejected
 (*:10.4737	prefix accepted: (
       :10.3602
fun:10.2928
            :10.0001

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.3208
fun:15.7939
  :15.6944
   :15.1599
 fun:14.5713

:14.5625
	:13.3749	rejected
     :13.1386
#:12.8064	rejected
    :12.695
let:12.5259
 let:11.885
(*:11.8389	prefix accepted:(
       :11.5931
(:11.8389
 (*:10.9111	prefix accepted: (
func:10.9044	rejected
      :10.7859
 #:10.7209	rejected
 func:10.6028	rejected
{:10.4106	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:19.0403
 #:14.2875	rejected
 let:13.9526
 (*:13.4864	prefix accepted: (
 function:12.431	rejected
 (:13.4864
 |:11.4009	rejected
 match:11.1265	rejected
 ~:11.0203	rejected
 ##:10.8097	rejected
 {:10.7758	rejected
 func:10.7657	rejected
 *:10.701	rejected
 ?:10.6097	rejected
 lambda:10.4374	rejected
 f:10.4294
 //:10.4226	rejected
 update:10.1018	rejected
 @:10.0768	rejected
 +:10.0198	rejected
 switch:9.98195	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 play:16.6563
 (:14.9801
 model:14.3386
 pl:13.8151
 old:13.4153
 p:13.3622
 current:13.1788
 state:12.9957
 ((:12.9134	prefix accepted: (
 m:12.8016
 song:12.2337
 [:12.0635
 ({:12.0626	prefix accepted: (
 prev:11.9767
 s:11.9604
 {:11.8412	rejected
(:11.6521
 app:11.6305
 ([:11.2685	prefix accepted: (
 player:11.1753
 a:11.1221

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {play: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: play
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
list:19.1366
List:16.0264
_:14.6636
lists:13.317
,:13.2969
lst:12.8146
ist:12.6533
l:12.519
ls:11.9247
state:11.7578
lis:11.5391
State:11.2002
lit:11.0982
L:10.696
S:10.392
ListView:9.98854
ListItem:9.97659
back:9.75923
ilst:9.43001
 list:9.36994	rejected
lt:9.23932

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:17.7714
_:13.5308
 action:13.2125	rejected
 ->:12.1866
 ,:12.014
0:11.738
 act:10.9529	rejected
1:10.7801
_,:10.3786	prefix accepted:_
 play:10.146	rejected
 state:10.0572	rejected
 a:9.86883	rejected
 actions:9.70636	rejected
->:9.70165
 model:9.56975	rejected
::9.38746	rejected
 x:9.15332	rejected
 p:9.12848	rejected
 current:9.10552	rejected
 pl:9.10196	rejected
 s:8.98048	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)), (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)), (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 action:16.7822
 act:14.2201
 a:13.5701
 play:12.7854
 msg:12.3171
 event:11.6063
 command:11.2702
 cmd:11.1586
 song:11.0877
 actions:11.0011
 x:10.9791
 message:10.9764
 p:10.9128
 new:10.7605
 input:10.6867
 current:10.6718
action:10.6426
 player:10.5438
 pl:10.4808
 next:10.2936
 e:10.2564

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.6677
->:14.4217
 :13.4398
 =>:13.2299	rejected
_:11.717
::11.2792	rejected

:11.1962
 =:10.8974	rejected
 ::10.2872	rejected
 â†’:10.1364	rejected
,:9.95375
 +:9.95251	rejected
?:9.93467	rejected
 -:9.7655
  :9.73637
':9.57884	rejected
 {:9.56118	rejected
0:9.53621
1:9.34315
 ?:9.31195	rejected
 -->:9.28703	prefix accepted: -

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.9545
 :16.6412
  :15.2912
 match:14.8403	rejected
    :13.8811
 case:13.1146
 (*:12.5073	prefix accepted: (
                :12.4102
   :12.409
 {:12.4069	rejected
 ?:12.3292	rejected
 play:12.2104
     :12.1875
      :12.0054
        :11.8296
 begin:11.6369	rejected
 #:11.3267	rejected
       :11.326
	:11.2449	rejected
         :11.0289
 (:12.5073

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :18.6447
    :15.8705
  :15.8421
     :15.6579
 :15.1026

:14.5879
       :13.7371
      :13.0223
case:12.8236
	:12.65	rejected
        :12.1566
         :11.9204
match:11.8769	rejected
#:11.5254	rejected
 case:11.0535
           :10.8084
          :10.7867
 match:10.7373	rejected
switch:10.5969	rejected
let:10.5881
(*:10.2811	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:17.8117
 let:16.9451
 match:16.93	rejected
 switch:14.2	rejected
 #:13.1425	rejected
 (*:12.6472	prefix accepted: (
 print:12.5098	rejected
 play:11.931
 if:11.6925
 (:12.6472
 {:10.8616	rejected
 open:10.8078	rejected
 Play:10.7926
 ?:10.4741	rejected
 printf:10.4506	rejected
 Print:10.2579	rejected
 un:10.1476	rejected
 fun:10.0923
 action:10.0541
 type:10.0138
 begin:9.98803	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:16.5339
 play:15.6082
 get:13.7585
 (:11.3968
 :10.5825

:10.1389
 song:10.0997	rejected
 player:9.76724	rejected
 actions:9.56265	rejected
 act:9.51334
(:9.29784
 state:9.19682	rejected
 let:9.16317
 {:9.10199	rejected
play:9.10054
 [:8.98189
 *:8.94531	rejected
 List:8.90659	rejected
 current:8.82839	rejected
 is:8.57703
 a:8.36751

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.8534
 :16.3532
,:16.1151
  :14.7378
 of:14.1736	rejected
    :13.2166
 with:13.0308	rejected
 {:12.6955	rejected
 |:12.368
::12.3346
     :12.0583
 ::12.0023
      :11.9713
   :11.5895
 in:11.4474	rejected
;:11.3678	rejected
                :11.2334
 //:11.2278	prefix accepted: /
 +:11.17
 ,:11.1255
 #:10.891	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.2901
     :16.0727
    :16.0342

:15.2165
  :14.0305
      :13.5371
       :13.2013
        :13.0705
 :12.8883
#:12.2161	rejected
|:11.7806
	:11.7438	rejected
         :11.5359
          :10.9017
(*:10.7578	prefix accepted:(
 |:10.7461
                :10.519
            :10.3786
           :9.68393
             :9.59912
 #:9.30071	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.0987
 #:16.6908	rejected
 (*:13.5469	prefix accepted: (
 match:12.5004	rejected
 {:12.206	rejected
 +:11.8953
 ||:11.8202	prefix accepted: |
 ##:11.8029	rejected
 #{:11.6921	rejected
 /*:11.3845	prefix accepted: /
 ~:11.3781	rejected
 ,:11.3527
 //:11.1195	prefix accepted: /
 <:10.9481
 when:10.6409	rejected
 *:10.6059
 case:10.6056	rejected
 if:10.4561	rejected
 ###:10.3463	rejected
 let:10.3395	rejected
 --:10.3226	prefix accepted: -

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:16.7188
 Play:16.5822
 P:15.4045
 Remove:14.1899
 No:13.4142
 _:12.5214
 #:11.1126	rejected
Play:10.6512
 :10.6486
 (:10.5297
 Player:10.3557	rejected
 {:9.87149	rejected
 +:9.71342	rejected
 _,:9.59173	prefix accepted: _
Add:9.47798
 Get:9.45149	rejected
>:9.44729	rejected
 Stop:9.4394	rejected
 Song:9.40444	rejected
P:9.31271
 >:9.15172	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
ause:22.5718
aused:15.413
ush:14.9537	rejected
aus:13.6423
LAY:13.4601	rejected
au:12.6439
ure:12.4268	rejected
rep:12.2549	rejected
ull:12.2313	rejected
urchase:11.7845	rejected
lay:11.7429
lain:11.6269	rejected
ulse:11.4894	rejected
refix:11.2045	rejected
aste:11.1736	rejected
alette:11.0104	rejected
uzz:10.9404	rejected
ose:10.8726	rejected
air:10.7935	rejected
ending:10.5456	rejected
aint:10.5107	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | Pause

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | Pause
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Pause>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Pause"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Pause
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Pause
LSP: Generating Completions for prefix: Pause
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "CurrentSong" | "dOn"
root ::= completions

Top 20 Logits:
Current:20.1327
S:14.6473	rejected
 =>:14.1022	rejected
(:12.081	rejected
():11.9274	rejected
On:11.917	rejected
 ->:11.6931	rejected
C:10.9545
_:10.5387	rejected
 if:10.2426	rejected
 Current:10.1479	rejected
 current:9.74315	rejected

:9.46049	rejected
 |:9.38963	rejected
  :9.37772	rejected
 song:9.35856	rejected
 :9.33515	rejected
     :9.32169	rejected
    :9.31786	rejected
 _:9.29343	rejected
        :9.21682	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrent

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrent
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrent"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PauseCurrent
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrent
LSP: Generating Completions for prefix: PauseCurrent
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:22.9456
 =>:12.6796	rejected
Sound:11.7636	rejected
(:11.5434	rejected
ly:11.2358	rejected
 Song:11.2062	rejected
 ->:11.0325	rejected
 song:10.6575	rejected
():10.6253	rejected

:10.0247	rejected
Action:9.89327	rejected
 if:9.60311	rejected
State:9.53315	rejected
Play:9.46346	rejected
song:9.45264	rejected
 :9.44766	rejected
_:9.42561	rejected
 |:9.35767	rejected
SON:9.13376	rejected
 >:8.85376	rejected
  :8.84511	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrentS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PauseCurrentS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrentS
LSP: Generating Completions for prefix: PauseCurrentS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:30.4029
song:17.1537	rejected
ongs:16.4544	rejected
on:16.4307
one:14.4753	rejected
 song:14.1838	rejected
pon:12.9693	rejected
ound:12.8356	rejected
onic:12.7301	rejected
ongo:12.3211	rejected
ONG:12.0374	rejected
oon:11.9786	rejected
son:11.929	rejected
 Song:11.8165	rejected
oup:11.703	rejected
ng:11.4803	rejected
ons:11.2387	rejected
play:11.1657	rejected
ohn:10.8829	rejected
ame:10.8381	rejected
ug:10.7979	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PauseCurrentSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PauseCurrentSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.6042
 ->:14.9449	rejected
 when:13.7183	rejected
  :13.0278
 :12.934

:12.9027
 if:12.7484	rejected
,:12.6859
=>:12.5324
    :11.8539
     :11.8129
      :11.7479
       :11.1756
 as:11.0622	rejected
   :10.994
 |:10.945	rejected
        :10.8907
         :10.7212
():10.6008	prefix accepted:(
                :10.5881
          :10.5542

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.0941
 :15.6575
 match:13.9204	rejected
 ?:13.8914	rejected
  :13.4916
 pause:13.4312	rejected
 (:13.2924
 {:12.6709	rejected
 (*:12.6654	prefix accepted: (
 play:12.6194
 update:12.0084
 case:11.9372
    :11.8993
 let:11.7773
 get:11.731
 [:11.6712
                :11.62
 ...:11.4073	rejected
 if:11.3745
 #:11.3283	rejected
 List:11.2242	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :22.4889
       :20.7627
      :19.565
        :17.3059
    :16.7476
         :16.3897
	:16.14	rejected
   :15.4237
          :14.7691
           :14.4494

:14.2589
            :13.3066
  :13.1882
#:13.1866	rejected
                :13.1818
             :12.5648
               :12.4581
 :12.4203
              :12.3153
(:11.1284
(*:10.7616	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:20.0057
 case:18.3885
 match:17.2869	rejected
 if:16.9764
 begin:16.435	rejected
 (:16.0929
 #:15.4394	rejected
 get:15.1102
 (*:14.5701	prefix accepted: (
 play:14.2083
 {:14.1824	rejected
 Play:13.6098
 switch:13.4401	rejected
 update:13.2163
 ?:13.0236	rejected
 [:12.5324
 f:12.4772
 pause:12.1975	rejected
 do:12.1919	rejected
 ((:12.1798	prefix accepted: (
 change:12.0245	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:17.1932
 current:13.3967
 _,:13.3474	prefix accepted: _
 song:13.1192
 _:13.3474
 ids:12.4397
 state:11.526
 xs:11.4926
 id:11.2427
 play:11.1233
 (:10.8051
 s:10.527
 playing:10.3056
 curr:10.0048
 old:9.98988
 cur:9.91218
 new:9.87803
 all:9.75628
 list:9.57096
 Songs:9.55404	rejected
 is:9.53318

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.1277
 =:17.4147
 ,:14.6346
_:14.5098
 ::13.7543
  :13.3065
=:13.1504
::13.0482
_,:13.0241	prefix accepted:_
    :12.176
 :12.1638
@:11.8777	rejected
   :11.8044
      :11.7696
1:11.7097
',:11.4269	rejected
 @:11.3261	rejected
 :=:11.2527	prefix accepted: :
       :11.2331
 :::11.052
        :10.8273

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:16.6832
 state:15.8533
 _:14.6059
 playing:13.2145
 old:12.3243
 song:11.9457
 s:11.9184
 play:11.9096
 curr:11.3582
 p:10.9956
 status:10.9635
 Play:10.8944
state:10.6683
 cur:10.618
 player:10.3114
 (:10.1616
 id:10.0653
current:10.0486
 c:10.0354
 x:10.0277
 st:9.89427

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:19.1188
_:18.0592
State:16.1344
=:13.8954
 :13.6084
S:13.4289
state:13.2978
  :12.1184
Play:11.721
,:11.4638
 ->:11.1386	rejected
Id:11.1368
 ::11.1351
 as:10.9535	rejected
Status:10.887
song:10.8148
::10.6493
    :10.562
play:10.3383
':10.2318	rejected

:9.93798

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_: ?, songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
state:20.0079
song:18.224
play:16.3004
status:15.5276
id:15.0562
action:13.9012
s:13.8489
 =:13.2933
player:12.8492
st:12.1715
pl:12.0992
track:11.7267
p:11.5924
item:11.5703
index:11.5563
State:11.5215
selection:11.496
idx:11.3061
mode:11.2342
music:11.0654
selected:11.0254

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: ?, songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current_state
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.0753
=:15.791
 :14.7167
_:13.4207
,:13.0686
  :12.79
 as:12.5947	rejected
 ::12.2499
 ->:11.7741	rejected
::11.5229
 =\:11.4084	prefix accepted: =

:11.238
    :11.1979
 ==:10.7935	prefix accepted: =
   :10.7242
':10.6248	rejected
      :10.216
 in:10.1176	rejected
(:10.0898
():10.0311	prefix accepted:(
 =>:9.96395	prefix accepted: =

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:18.9516

:13.533
 :13.3589
 get:13.1277
 match:11.7825	rejected
play:11.5039
 (:10.9246
 List:10.3756	rejected
 action:10.302
 f:10.1919
 current:10.0821	rejected
 !:9.50661
 p:9.45812
 Play:9.44042
  :9.43741
 Tu:9.3894	rejected
 in:9.25326
 split:9.23513	rejected
 update:9.18755
 pl:9.17708
 ?:9.13116	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.242
l:12.3389
ist:11.9106	rejected
List:11.0594	rejected
lst:10.9225	rejected
lists:10.9052	rejected
_:10.8806	rejected
 list:10.8455	rejected

:10.5878	rejected
lista:9.91321	rejected
lis:9.7135
label:9.40483	rejected
listen:9.29248	rejected
ling:9.24677	rejected
link:9.22772	rejected
load:9.22262	rejected
state:9.11175	rejected
ls:9.09564	rejected
last:9.05118	rejected
lit:8.96533	rejected
line:8.91403	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.982

:14.8358
,:14.5891
 :14.2508
;:13.2714	rejected
 and:12.8272	rejected
.:12.4364	rejected
  :12.28
 ,:10.673
    :10.5788
                :10.5505
      :10.2696
 &&:9.93918
   :9.90167
 ;:9.73511	rejected
       :9.52945
 |:9.40085	rejected
?:9.38753	rejected
 #:9.38181	rejected
 ?:9.34404	rejected
        :9.23794

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:20.2808
 :17.7601
  :16.3073
      :15.0527
    :14.9652
 match:13.9876	rejected
        :13.8244
       :13.7971
   :13.4608
     :13.2018
                :13.139
         :13.0449
            :12.8137
          :12.8114
 (:12.7654
 (*:12.7253	prefix accepted: (
 {:12.547	rejected
 begin:12.4374	rejected
	:12.2193	rejected
             :11.8398
           :11.8135

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.664
       :18.4931
      :17.7425

:16.0976
    :15.8424
        :15.7963
         :15.5979
	:15.1014	rejected
   :14.2838
          :13.868
  :13.7928
           :13.3705
 :12.8383
                :12.5791
            :12.4204
#:12.2599	rejected
             :11.7814
(*:11.7711	prefix accepted:(
               :11.3208
              :11.0064
(:11.7711

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:18.0326
 match:17.3886	rejected
 let:16.6047
 begin:16.4846	rejected
 (:15.8462
 if:15.6299
 #:14.3176	rejected
 (*:14.0375	prefix accepted: (
 {:13.3004	rejected
 assert:12.7736	rejected
 play:12.677
 ?:12.3808	rejected
 Play:12.3685
 switch:12.224	rejected
 ((:12.1373	prefix accepted: (
 songs:12.0586
 ([:11.9238	prefix accepted: (
 [:11.8403
 List:11.6183	rejected
 get:11.5119
 ~:11.4993	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:19.41
 get:15.4284
 songs:13.6215
 state:13.2571	rejected
 play:12.4386
 (:12.3529
 List:12.1396	rejected
 :11.9298
 curr:11.8575
 song:11.3802
 pause:11.3452	rejected
 f:10.6748
 Songs:10.6142	rejected
(:10.589
 s:10.4576
 next:10.3259	rejected
 cur:10.2527
 is:10.2467

:10.1855
 match:9.94518	rejected
 p:9.87121

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "current"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  current
Nature of error: Variable current is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: current
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_state"
root ::= completions

Top 20 Logits:
_:21.2369
 state:14.9805	rejected

:13.5631	rejected
 of:12.801	rejected
State:12.7783	rejected
 in:12.2037	rejected
 =:11.7028	rejected
 :11.316	rejected
 _:11.2443	rejected
,:11.1108	rejected
-:10.7332	rejected
.:10.5249	rejected
(:10.4102	rejected
 song:10.3914	rejected
():10.1871	rejected
 with:10.1467	rejected
state:10.1036	rejected
 play:9.90524	rejected
 as:9.88604	rejected
::9.4229	rejected
  :9.26177	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "current_"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  current_
Nature of error: Variable current_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: current_
LSP: Generating Completions for prefix: current_
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "state"
root ::= completions

Top 20 Logits:
state:21.3813
s:14.7075
stage:13.4268	rejected
st:12.9295
status:12.8856	rejected
type:12.6614	rejected
 state:12.3335	rejected
states:12.2644	rejected
stat:12.0763
play:12.0629	rejected

:11.6881	rejected
State:11.5511	rejected
song:11.4793	rejected
of:10.9544	rejected
name:10.9478	rejected
style:10.823	rejected
str:10.699	rejected
start:10.6587	rejected
station:10.5505	rejected
size:10.1918	rejected
step:10.1861	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: current_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: current_state
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.1974
 :17.6313
 of:16.0045	rejected
  :15.5885
 with:15.0928	rejected
    :13.9962
      :13.7545
 in:12.7148	rejected
                :12.5974
   :12.5375
        :12.5286
       :12.3479
,:12.043
     :11.925
         :11.8994
::11.6955
          :11.5933
 {:11.4479	rejected
 //:11.4322	prefix accepted: /
 #:11.4058	rejected
 as:11.3577	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :21.4773
       :19.7115
      :17.7536
         :16.2447
	:16.2437	rejected
        :16.1
    :15.5939
#:14.949	rejected

:14.9375
   :14.7723
          :14.7223
           :14.3491
                :13.7657
            :13.5365
  :13.2035
             :12.8881
               :12.7834
|:12.7563
 :12.5468
              :11.9959
(*:11.402	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.015
 #:17.2379	rejected
 (*:15.1125	prefix accepted: (
 match:12.4849	rejected
 ||:12.3741	prefix accepted: |
 ~:12.2256	rejected
 {:12.1796	rejected
 *:12.1283
 ##:11.8631	rejected
 when:11.7503	rejected
 +:11.7411
 /*:11.7278	prefix accepted: /
 #{:11.6685	rejected
 (**:11.6594	prefix accepted: (
 \:11.4973
 <:11.4038
 P:11.1859	rejected
 (:15.1125
 //:10.8674	prefix accepted: /
 #(:10.8308	rejected
 #[:10.8203	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 No:17.2413
 Play:16.8065
 P:15.5926
 _:11.4894
P:11.1134
 :11.0912
 (:11.053
Play:10.901
 Player:10.697	rejected
 playing:9.96959
No:9.89393
  :9.88548
 Current:9.55702	rejected
 no:9.40633
 Some:9.17477	rejected
 None:9.17427	rejected
 Song:9.0065	rejected
 {:8.89087	rejected
 Id:8.78706	rejected
 #:8.50362	rejected
 Running:8.37313	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song" | "ing"
root ::= completions

Top 20 Logits:
ing:23.9853
S:16.0921
List:13.6124	rejected
(:13.2894	rejected
ed:12.253	rejected
ling:12.1138	rejected
list:12.0735	rejected
State:11.9576	rejected
Sing:11.8292	rejected
L:10.7654	rejected
i:10.6799
ING:10.4568	rejected
ings:10.1644	rejected
P:10.0872	rejected
sing:9.98323	rejected
(_:9.93781	rejected
able:9.79908	rejected
eing:9.68696	rejected
 song:9.6065	rejected
Play:9.57153	rejected
ng:9.51717	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.5708
 id:15.0971	rejected
(_:14.6249	rejected
 song:14.3437	rejected
 i:12.9633	rejected
 current:11.7268	rejected
 _:11.6907	rejected
 s:11.5601	rejected
 (:11.4282
 x:11.3787	rejected
 sid:10.7325	rejected
  :10.1313
 k:10.115	rejected
 selected:10.0847	rejected
 :10.0374
 p:9.91643	rejected
 n:9.84907	rejected
 a:9.65532	rejected
 as:9.63581	rejected
 track:9.5191	rejected
 playing:9.30926	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
id:17.9898
song:17.606
current:16.2517
i:15.0034
x:14.8472
s:14.0177
idx:13.912
play:13.8817
selected:13.5564
curr:13.0732
Id:13.0331	rejected
n:12.7639
index:12.5569
cur:12.1791
p:12.1363
pid:11.7207
a:11.6579
track:11.6063
now:11.5558
k:11.3373
cid:10.9334

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
_:18.2921
):17.6441
Id:16.3356
id:15.9629
ID:14.409
s:13.8544
),:13.8074
)->:13.1952	prefix accepted:)
1:12.3872
)|:12.1846	prefix accepted:)
)=:11.5175	prefix accepted:)
_):11.1486	prefix accepted:_
:::10.985	rejected
Index:10.411
0:10.2179
 as:10.0278	rejected
 ):9.86203
)::9.75108	prefix accepted:)
 :::9.74037	rejected
,:9.70897
->:9.69424	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.0516
  :14.0768
 ->:14.0169	rejected
 :13.3366
    :12.8899
 as:12.7429	rejected
      :12.4096

:12.1664
   :12.1589
 |:11.9146	rejected
       :11.7479
     :11.5981
 when:11.5867	rejected
 +:11.2473	rejected
        :11.1754
         :11.1167
          :10.8676
           :10.4934
 \:10.1064	rejected
            :10.1051
                :10.1047

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.6354

:14.6069
 ([:14.3939	prefix accepted: (
 songs:14.0675
 play:13.6318
 [:13.4452
 :13.2603
 song:11.4861
 Play:11.0469
 ((:10.8745	prefix accepted: (
  :10.6103
 (*:10.5142	prefix accepted: (
 get:10.4382
 _,:10.3622	rejected
 #:10.1851	rejected
 [],:10.1584	prefix accepted: []
 {:10.042	rejected
 let:9.82006
 ?:9.81995	rejected
 List:9.811	rejected
 if:9.48203

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:19.035
play:14.7505
get:13.1318
 songs:12.0769

:11.6954
current:11.1087
List:11.0496	rejected
sing:10.5267	rejected
remove:10.4076	rejected
s:10.0323
p:9.84467
list:9.71137	rejected
f:9.61825
<:9.56918	rejected
[]:9.529
Play:9.43845
plays:9.14386	rejected
P:9.0997
#:9.07724	rejected
same:9.05452	rejected
S:8.97975	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type PlayList but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
s:22.9902
:::16.2376
 :::14.7315
,:13.5014
es:11.6874	rejected
 @:10.6238
 +:9.89593
 ::9.84108
::9.81312
@:9.78764
.:9.2532	rejected
[:9.24107	rejected
),:9.2396	prefix accepted:)
_:9.21399	rejected
sBy:9.0167	rejected
):9.2396
ss:8.85083	rejected
 ,:8.69554
 in:8.64688	rejected
 *:8.58145
 -:8.43936

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.7277
 ,:14.1819
 @:12.831
,(:12.6534	prefix accepted:,
),:12.5977	prefix accepted:)
,[:12.0152	prefix accepted:,
 +:11.5816
@:11.3551
 ::11.0724
::10.7131
.:10.6105	rejected
 ++:9.92063
[:9.77248	rejected
 |:9.66344	rejected
 [:9.32073	rejected
 *:9.28719
+:9.15057
,\:9.08882	prefix accepted:,
):12.5977
 :9.03397
:::8.92769

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 P:18.0941
 No:13.9105
 (:13.3976
P:12.6865
 :12.2195
 paused:11.9373	rejected
 Play:11.9041
  :11.536
 pause:11.0978	rejected
 new:10.9875	rejected
    :10.859
 {:10.6194	rejected
 song:10.3757
 state:10.2596	rejected
 ~:10.221	rejected
 current:10.0636
   :9.87465
 get:9.83441

:9.70761
 @:9.49867	rejected
                :9.47396

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
aused:24.5696
ause:16.2738
aus:12.8268
 paused:12.5789	rejected
ushed:11.8154	rejected
au:11.7018
osed:11.5547	rejected
ased:11.4652	rejected
icked:10.2466	rejected
used:10.1798	rejected
leased:10.0553	rejected
P:9.97617	rejected
ending:9.71446	rejected
p:9.52593	rejected
.:9.15414	rejected
lapsed:9.07665	rejected
uzz:9.06343	rejected
ued:8.88729	rejected
ained:8.60978	rejected
aled:8.509	rejected
rep:8.45903	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, Paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, Paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:23.1941
(:15.2014	rejected
S:12.5084	rejected
on:12.4839	rejected
_:12.1323	rejected
 song:12.0865	rejected
 on:11.8113	rejected
 On:11.4715	rejected
Of:11.1142	rejected
At:11.1112	rejected
):10.9248	rejected
ON:10.8486	rejected
O:10.841
()):10.7326	rejected
One:10.4902	rejected
 (:10.337	rejected
In:10.2703	rejected
Current:10.1615	rejected
State:10.125	rejected
Play:9.99089	rejected
.:9.63429	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.7333
 song:17.0371	rejected
 (:13.1516
()):12.5399	prefix accepted:(
((:12.4205	prefix accepted:(
):11.9009
([:11.49	prefix accepted:(
)(:11.0502	prefix accepted:)
(_:11.0132	rejected
({:11.0003	prefix accepted:(
[:10.9025	rejected
(?:10.8763	prefix accepted:(
(-:10.3221	prefix accepted:(
(!:10.0998	prefix accepted:(
.:9.86161	rejected
song:9.85077	rejected
(@:9.76607	prefix accepted:(
 :9.68043
(":9.62095	prefix accepted:(
?(:9.59355	rejected
.(:9.52717	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:21.6171
current:15.174
0:14.4435
play:14.3079
 song:13.5355
get:13.1652
id:12.8428	rejected
1:12.7496
Int:12.4118	rejected
S:12.0766	rejected
some:12.0719	rejected
s:12.0026
p:11.9269
sing:11.8898	rejected
Play:11.7883
Id:11.5559	rejected
P:11.5556
Some:11.4615	rejected
x:11.4373	rejected
sound:11.4203	rejected
i:11.3809

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)):22.6343
)),:18.2644	prefix accepted:))
):14.7538
));:14.5083	prefix accepted:))
),:14.4968	prefix accepted:)
))::13.5325	prefix accepted:))
s:13.3783
))):12.7471	prefix accepted:))
))\:12.1077	prefix accepted:))
)).:11.9001	prefix accepted:)
 :11.4928
_:11.2054	rejected
)::11.0799	prefix accepted:)
))]:10.9271	prefix accepted:))
 -:10.8908
);:10.6938	prefix accepted:)
 +:10.6201
)));:10.583	prefix accepted:))
)))):10.5147	prefix accepted:))
,:10.3608
))`:10.2737	prefix accepted:))

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.8354
 :15.5324
  :14.5318
 #:13.9887	rejected
 end:13.7392
      :13.4124
    :13.1265
 (*:13.0825	prefix accepted: (
:::12.3091
 :::12.2435
        :12.0893
   :11.7877
                :11.6128
       :11.5186
 |:11.3938
 ::11.2038
          :11.1715
 @:11.1294
 ,:11.1146
     :11.0059
            :10.9904

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :21.4464
      :16.5587
       :16.2915
#:15.3994	rejected
    :15.0544

:15.0213
	:15.0207	rejected
        :14.264
   :14.2287
                :13.9101
         :13.706
          :13.194
           :13.1177
(*:12.8787	prefix accepted:(
  :12.7822
            :12.6394
 :12.1075
|:11.9835
 #:11.7005	rejected
             :11.5102
              :11.4671

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.9955
 #:19.61	rejected
 (*:16.3324	prefix accepted: (
 end:15.7219
 _:14.7947	rejected
 /*:13.1756	prefix accepted: /
 *:13.0313
 //:12.8797	prefix accepted: /
 (_:12.7198	rejected
 \:12.3331
 <:12.3166
 ##:12.2063	rejected
 !:11.925
 (**:11.8473	prefix accepted: (
 ~:11.7884	rejected
 else:11.7712	rejected
 ||:11.7127	prefix accepted: |
 /:13.1756
 ?:11.5313	rejected
 --:11.4908	prefix accepted: -
 (:16.3324

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:16.6979
 P:15.5758
 No:15.3762
 x:12.1631
 state:11.7899
 other:11.7824
 s:11.352
 p:10.7011
 paused:10.5959
 otherwise:10.5331
 Play:10.3016
 current:10.0002
 :9.88354
_:9.86345
 _,:9.421	prefix accepted: _
 song:9.39006
P:8.8461
 c:8.70901
 (:8.68539
 others:8.65533
>:8.63792	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.9645
            :14.3743
=>:13.0223
 :12.2364
 ->:12.1465	rejected
             :11.8072
 :::11.5324	rejected
 as:11.4145	rejected
           :11.0414
:::10.8999	rejected
 else:10.7007	rejected
 :=:10.6729	rejected
  :10.3428
        :10.2581
          :10.1184
 then:9.98445	rejected
    :9.93259
      :9.85472
       :9.77547
              :9.53629
                :9.52721

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:16.1394
 ?:14.9877	rejected
 (:14.5144
 fail:12.306	rejected
 raise:11.834	rejected
 :11.3112
 error:10.754	rejected

:10.4296
 (*:10.0961	prefix accepted: (
 let:9.87273
 (?:9.82435	prefix accepted: (
 no:9.71591	rejected
 ((:9.6259	prefix accepted: (
play:9.46462
 update:9.43552
 #:9.23221	rejected
 print:9.18229	rejected
 !:9.13301
 assert:9.05467	rejected
 {:9.01989	rejected
 pan:8.86762	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.0067
List:13.8283	rejected
ist:13.269	rejected
l:12.4234
lists:12.1954	rejected
lit:12.0102	rejected
lis:11.9134
 list:11.7653	rejected
_:11.7106	rejected
lst:11.7032	rejected
ls:11.2071	rejected
ll:10.1763	rejected
ilst:9.69937	rejected
li:9.65049

:9.45638	rejected
il:9.30692	rejected
let:9.08948	rejected
(:9.01934	rejected
st:8.99798	rejected
state:8.9	rejected
play:8.89006	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:18.3959

:15.7256
 :13.8201
 (*:13.6264	prefix accepted: (
 #:13.3322	rejected
():12.6808	prefix accepted:(
                :12.3961
  :12.0642
(*:12.0617	prefix accepted:(
 in:12.0125	rejected
 ():11.1971	prefix accepted: (
      :10.8029
 |:10.5264
    :10.4818
        :10.2743
#:10.0271	rejected
            :9.96517
          :9.94255
 ::9.86819
       :9.83468
   :9.82867

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.0213
 :17.4237
  :15.5417
 #:15.0231	rejected
      :14.564
    :14.4566
        :13.2639
                :13.2472
   :13.0112
 (*:12.9369	prefix accepted: (
       :12.4504
 in:12.3098	rejected
            :12.3049
	:12.154	rejected
          :12.0501
     :11.9867
         :11.9449
              :11.6089
           :11.2464
;:11.1773	rejected
             :11.136

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.2243
    :16.2995

:16.2284
  :15.2825
      :14.4672
 :14.1218
     :13.1786
#:13.118	rejected
        :13.0053
       :11.9542
                :11.6429
            :11.5117
	:11.4953	rejected
          :11.3783
|:11.2181
         :10.68
              :10.2673
 #:10.1651	rejected
end:10.0523
(*:9.88758	prefix accepted:(
 |:9.55821

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.8334
 #:19.1303	rejected
 (*:15.2323	prefix accepted: (
 <:13.807

:13.7436
 ...:13.2021	rejected
 //:13.1596	prefix accepted: /
 ##:12.7565	rejected
 ||:12.2847	prefix accepted: |
 end:12.1699
 /*:11.7188	prefix accepted: /
 ~:11.6552	rejected
 (**:11.6342	prefix accepted: (
 ,:11.5379
 (:15.2323
 ###:11.2421	rejected
 /:13.1596
 case:11.0516	rejected
 *:10.986
 {:10.9663	rejected
 in:10.9503	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Remove:16.9115
 Play:16.6861
 Add:16.2404
 _:13.0859
 P:12.2867
 No:12.13
 Player:11.1854	rejected
 Res:11.125	rejected
 Rem:10.9861
Play:10.4467
 :10.4235
 #:9.69921	rejected
 Stop:9.68219	rejected
 >:9.41395	rejected
 play:9.22589
 Next:9.21115	rejected
 Rest:9.15494	rejected
 Un:8.97207	rejected
 Start:8.88253	rejected
Remove:8.69364
 remove:8.68215

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | Remove

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | Remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Remove
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:20.6064
(:12.4911	rejected
From:11.8628	rejected
All:11.671	rejected
Current:11.6	rejected
Selected:11.4835	rejected
 Song:11.4467	rejected
 song:11.3419	rejected
Last:10.0398	rejected
_:9.94553	rejected
(_:9.73964	rejected
And:9.40548	rejected
Id:9.39327	rejected
Play:9.25542	rejected
Action:9.216	rejected
First:8.93054	rejected
Sing:8.89151	rejected

:8.76805	rejected
P:8.73867	rejected
T:8.64569	rejected
Item:8.60673	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  RemoveS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveS
LSP: Generating Completions for prefix: RemoveS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:24.6123
ongs:16.5979	rejected
on:13.7398
ongo:12.0148	rejected
song:11.5161	rejected
ond:11.4601	rejected
 song:11.3438	rejected
oon:10.7797	rejected
ng:10.684	rejected
ame:10.5653	rejected
n:10.4308	rejected
ont:10.1396	rejected
ons:9.75185	rejected
one:9.72181	rejected
inger:9.60287	rejected
ang:9.59998	rejected
om:9.57905	rejected
ug:9.49189	rejected
(:9.44539	rejected
old:9.08359	rejected
og:9.04678	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Int -> (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  RemoveSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: RemoveSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.0559
(_:15.1043	rejected
 song:14.5477	rejected
 id:14.2033	rejected
 (:12.504
 ->:11.3091	rejected
 i:11.0108	rejected
((:10.8895	prefix accepted:(
 =>:10.7643
([:10.7395	prefix accepted:(
():10.5717	prefix accepted:(
 s:10.4719	rejected
 :10.0875
 _:10.0342	rejected
 sid:9.96213	rejected
::9.94742	rejected
 x:9.7217	rejected
({:9.4722	prefix accepted:(
 idx:9.38487	rejected
 index:9.33388	rejected
(?:9.24652	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
id:18.3072
song:17.431
idx:14.3606
i:14.2805
to:14.1681
remove:14.101
x:13.9672
index:13.6163
target:13.2655
rem:13.2623
current:12.995
Id:12.778	rejected
n:12.7712
selected:12.7687
s:12.6359
track:12.0376
play:11.9615
new:11.7298
next:11.661
key:11.6444
k:11.3392

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):19.0099
_:18.2663
Id:16.5605
id:16.4521
ID:14.7599
)->:13.009	prefix accepted:)
To:12.9667
1:12.7869
_):12.4462	prefix accepted:_
s:12.3723
)=:12.3286	prefix accepted:)
2:12.0392
),:11.7384
,:11.169
 ):11.0961
'):10.8941	rejected
0:10.748
::10.6866	rejected
 as:10.6803	rejected
)::10.3871	prefix accepted:)
 ->:10.3383	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.5756
 :15.064
 ->:14.7398	rejected
 when:13.5753	rejected
 if:13.0245	rejected

:12.9733
  :11.9499
 as:11.0797	rejected
    :10.4255
=>:10.3836
 #:10.1133	rejected
 :=:10.0223	rejected
   :9.8444
	:9.83011	rejected
      :9.59798
 ==>:9.52309	prefix accepted: =
 |:9.43098	rejected
 in:9.32644	rejected
 {:9.2753	rejected
 =:9.52309
 //:9.00501	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.3034
 :19.0431
 (:15.4911
  :15.2556
 #:13.6655	rejected
    :13.654
 (*:13.6412	prefix accepted: (
 update:13.3117
 remove:13.2611	rejected
      :12.9989
                :12.785
 let:12.7832
        :12.4873
 ((:12.192	prefix accepted: (
 List:12.1481	rejected
   :12.096
       :11.8896
         :11.8591
            :11.7019
     :11.5749
	:11.4622	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :22.2744
      :20.4117
       :20.2874
    :18.6438
        :17.4745
         :17.103
	:16.6118	rejected
   :16.281
#:16.1073	rejected
          :15.5089
           :15.2169

:14.9681
  :14.5522
 :14.474
            :14.4282
                :14.4015
             :13.5972
               :13.3415
              :13.1895
 #:12.2413	rejected
let:11.7218

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:20.9217
 #:18.7083	rejected
 (:17.9562
 if:17.2015
 (*:16.5333	prefix accepted: (
 List:16.1002	rejected
 case:15.7608
 begin:15.3125	rejected
 remove:15.1931	rejected
 ((:15.1443	prefix accepted: (
 match:15.0893	rejected
 get:15.0165
 update:14.8261
 play:14.0303
 {:13.5686	rejected
 filter:13.3481	rejected
 list:13.073	rejected
 fun:12.9215
 #(:12.8922	rejected
 ([:12.73	prefix accepted: (
 <:12.6359	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
List:17.4637	rejected
get:14.2327
filter:14.2266	rejected
 List:13.5873	rejected

:13.1267
let:13.0146
Play:12.7401
play:12.6271
remove:12.102	rejected
#:12.0715	rejected
case:11.7372
fun:11.1181
f:11.0847
Filter:10.8598	rejected
 :10.7751
song:10.5179
if:10.336
 get:10.3343
 #:10.2009	rejected
 filter:10.0378	rejected
s:9.9762
Rejected the highest logit candidate List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :22.3359
      :19.6627
     :18.6595
        :17.3128
         :16.8433
	:16.4229	rejected
    :14.495
          :14.45
#:14.3359	rejected
           :14.1791
   :14.1319

:13.8105
 :13.3039
  :12.3499
            :12.2907
             :12.2136
              :11.8681
                :11.8303
               :11.2541
let:10.2869
(*:10.0665	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:18.1161	rejected
 #:16.606	rejected
 let:15.7611
 get:15.0266
 case:13.6948
 match:13.5685	rejected
 (:13.4823
 if:13.2618
 (*:13.1899	prefix accepted: (
 filter:13.139	rejected
 f:13.0369
 fun:12.0803
 remove:11.6996	rejected
 Play:11.5997
 {:11.5848	rejected
 play:11.5537
 s:11.246
 [:11.1997
 list:10.9035	rejected
 ((:10.6375	prefix accepted: (
 *:10.6152	rejected
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in ) end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:15.2593
 song:12.8669
 filtered:12.1742
 remove:12.0051
 new:11.8009
 xs:11.5966
 go:11.3871
 _,:11.3746	prefix accepted: _
 all:11.1669
 current:11.1523
 filter:11.1264
 not:10.7611
 remaining:10.5948
 rec:10.5441
 ids:10.5423
 f:10.4397
 cur:10.4323
 is:10.3682
 s:10.3401
 (:10.3068
 other:10.222

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in ) end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:18.8295
 =:18.0634
_:15.1211
',:13.4306	rejected
 :13.2302
':13.2223	rejected
::12.8259
_,:12.7559	prefix accepted:_
 ,:12.5611
  :12.4666
=:12.3036
 ::11.8631
      :11.726
1:11.7189
    :11.5408
2:11.4661
        :11.184
0:11.1487
   :11.0263
          :10.6583
         :10.652

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in ) end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in ) end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in ) end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 state:16.6486
 current:16.0132
 _:14.6632
 song:12.8404
 playing:12.1528
 play:11.8214
 curr:11.6886
 old:11.5893
current:10.9371
 selected:10.7605
 s:10.7438
 cur:10.5392
 p:10.5258
_:10.5162
 status:10.4918
 songs:10.2998
 :10.2202
 x:10.1361
 c:10.1061
 rest:10.0803
 new:9.97856

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: ?, songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in ) end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: state
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.1429
 :15.9515
=:14.9918
_:14.2468
':13.1273	rejected
  :12.9334
1:12.8347
,:12.4786
0:12.256
    :12.245
 as:12.1327	rejected
2:11.6919
 in:11.5872	rejected
 ->:11.4875	rejected
   :11.4569
      :11.4153
::11.2671
 ::11.0681
        :10.795
     :10.6033

:10.531

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:19.1928
 :13.8641
 List:13.644	rejected
 get:12.5303

:12.3239
 remove:12.1102	rejected
play:12.0492
 (:12.0292
 list:10.7029	rejected
 f:10.603
 pl:10.2483
 filter:10.2264	rejected
 action:10.1384
 Tu:10.11	rejected
 p:10.0298
 update:10.0146
 current:9.84865	rejected
 Play:9.67241
 pal:9.64647	rejected
 song:9.60093
 songs:9.33516	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in ) end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:24.1412
List:15.0735	rejected
lists:13.0295	rejected
lst:11.8302	rejected
lista:11.7072	rejected
LIST:11.6113	rejected
 list:11.589	rejected
link:11.4968	rejected
line:11.4046	rejected
_:10.8769	rejected
load:10.762	rejected
ist:10.4344	rejected
l:10.3697
listen:10.3379	rejected
lis:10.3172
label:10.0572	rejected
land:9.85775	rejected
lint:9.838	rejected
lit:9.62483	rejected
lib:9.40151	rejected
set:9.34608	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in ) end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.5689
 :14.6814

:14.2859
,:13.1353
 and:12.5339	rejected
;:11.5513	rejected
.:11.0819	rejected
  :10.8789
 &&:10.4017
                :9.8168
 |:9.50881	rejected
 ,:9.40594
    :9.39424
 ?:9.11817	rejected
   :8.99599
():8.98887	prefix accepted:(
      :8.97559
?:8.94889	rejected
 #:8.82461	rejected
in:8.6188
        :8.54396

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.3849
 :18.4657
  :15.101
    :13.9759
      :13.938
 List:13.7612	rejected
        :13.1385
            :12.4574
 (:12.386
   :12.1627
         :12.1354
                :12.0911
     :12.0352
          :11.982
 #:11.8533	rejected
 songs:11.8123
 (*:11.5905	prefix accepted: (
       :11.3045
 [:11.2517
           :11.0654
	:10.9435	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :20.7361
        :17.7571
         :17.7159
      :16.7858

:15.3318
	:15.205	rejected
           :14.8505
     :14.5986
          :14.5386
#:13.6942	rejected
    :13.1215
 :12.7266
  :12.6307
             :12.6281
                :12.5717
            :12.4898
   :12.1659
(*:11.7067	prefix accepted:(
               :11.6936
              :11.4295
 #:10.2143	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:18.8516	rejected
 (:18.1775
 let:18.1323
 match:17.9477	rejected
 if:17.5138
 case:16.7415
 #:16.6757	rejected
 filter:15.7783	rejected
 (*:15.504	prefix accepted: (
 ([:15.2803	prefix accepted: (
 ((:15.0277	prefix accepted: (
 songs:14.8986
 song:14.8323
 [:14.4811
 remove:14.1596	rejected
 get:13.7939
 Filter:13.7812	rejected
 {:13.5808	rejected
 Play:13.0179
 assert:12.9624	rejected
 list:12.9428	rejected
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:16.6702	rejected
 song:13.9687
 get:13.7052
 state:13.5865
 not:13.4504	rejected
 songs:12.7197
 (:12.3623
 !:11.7526
 :11.515
 Songs:10.9294	rejected
 Song:10.88	rejected
 current:10.8601	rejected
 f:10.7466

:10.7185
 is:10.4997
 Play:10.4013
 Id:10.017	rejected
 contains:9.91588	rejected
 list:9.7965	rejected
 s:9.65971
  :9.48791
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type Bool but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:15.0543
 =:14.7757
 \:13.2906
 <>:12.8524	prefix accepted: <
 in:12.5	rejected
 :::12.385
 !=:12.3763
 <:12.8524
 `:12.2771	rejected
 ===:12.0181	prefix accepted: ==
:::11.9739
_:11.6741	rejected
 is:10.8999	rejected
=:10.8252
 not:10.6773	rejected
 >:10.635
 @:10.2471
 |:10.2037	rejected
 :10.1119
 <=:10.1086
 >=:10.0551

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >=<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  song ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)
  LSP: Info: BidiCtx: Cls: Broken expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  song ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)
  LSP: Info: BidiCtx: Cls: Broken expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: =
LSP: Generating Completions for prefix: =
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "=" | "=."
root ::= completions

Top 20 Logits:
 get:13.5744	rejected
 List:13.0045	rejected
 :12.5478	rejected
 Id:11.3959	rejected
 -:10.9676	rejected
 ?:10.8951	rejected
 f:10.5538	rejected
 h:10.5157	rejected
 (:10.5014	rejected
 state:10.2758	rejected
 current:10.1902	rejected
 Option:9.83158	rejected
 None:9.74977	rejected
 Int:9.5313	rejected
 songs:9.36555	rejected
 Song:9.22811	rejected
 song:9.12778	rejected
?:9.12738	rejected
 match:9.12637	rejected
 Play:8.87568	rejected
 ":8.79285	rejected
Rejected the highest logit candidate  get with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 get:13.5215
 List:13.198	rejected
 :12.2011
 ?:11.6994	rejected
 (:10.6131
 state:10.5572
 -:10.54
 Int:10.5052	rejected
 h:10.2545	rejected
 None:9.94884	rejected
 songs:9.78222
 current:9.59744	rejected
 Id:9.59225	rejected
 !:9.58547
 ":9.45913
 f:9.3736
 song:9.17402
 find:8.9419	rejected
 Song:8.82639	rejected

:8.79803
 State:8.50307	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get
Nature of error: Variable get is not bound
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:18.4104
State:12.4674	rejected
Id:11.5892	rejected
(:11.5362	rejected
Play:11.3784	rejected
Current:11.2444	rejected
S:10.8864	rejected
P:10.0702	rejected
state:9.96039	rejected
 state:9.7691	rejected
.:9.52719	rejected
List:9.24285	rejected
 current:9.24075	rejected
Selected:9.15867	rejected
f:9.08861	rejected
_(:9.05876	prefix accepted:_
<:8.97549	rejected
Player:8.96594	rejected

:8.85874	rejected
First:8.83528	rejected
 id:8.81647	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_
Nature of error: Variable get_ is not bound
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:19.8819
current:18.0249	rejected
song:16.5779
id:16.2808	rejected
play:16.1344	rejected
selected:16.1117	rejected
cur:14.1365	rejected
p:13.9362	rejected
first:13.9007	rejected
curr:13.3686	rejected
now:13.172	rejected
last:13.0757	rejected
next:13.0233	rejected
active:12.7409	rejected
index:12.6517	rejected
player:12.6245	rejected
sing:12.4716	rejected
top:12.3972	rejected
status:12.206	rejected
value:11.9442	rejected
maybe:11.9335	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)) -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id");
           syn = (Arrow ((Var "PlayList"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state
Nature of error: Expecting type Id but got inconsistent type (PlayList -> PlayListState)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
(:16.835
 play:13.8933	rejected
():13.1199	prefix accepted:(
 then:12.9847

:11.2126
 songs:11.2044	rejected
_:11.087	rejected
.:10.9248	rejected
 song:10.3362	rejected
 (:10.2328
([:10.0195	prefix accepted:(
 :9.94577
 state:9.87325	rejected
((:9.69917	prefix accepted:(
 current:9.56717	rejected
(*:9.48457	prefix accepted:(
 {:9.43083	rejected
[:9.24062	rejected
.(:9.19518	rejected
 in:9.19085	rejected
::9.05565

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
play:19.7858
song:14.4655
state:13.5719
current:13.2134	rejected
List:11.8794	rejected
Play:11.8608
p:11.8295
No:11.4946
pl:11.4408
get:10.9833
P:10.9597
player:10.5643	rejected
 play:10.5463
Current:10.4178	rejected
sing:10.2307	rejected
action:10.0429
State:9.89616	rejected
s:9.87209

:9.81937
no:9.66896	rejected
remove:9.57266	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(play)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.0742
List:15.5894	rejected
lists:13.7632	rejected
l:13.4335
_:12.8752	rejected
ist:12.5309	rejected
lis:11.9951
lit:11.7662	rejected
ls:11.3344	rejected
):11.3041	rejected
 list:11.0334	rejected
lst:10.831	rejected
Add:10.4612	rejected
,:10.3252	rejected
.:10.2528	rejected
line:9.84082	rejected
li:9.79035
ling:9.7162	rejected
link:9.66962	rejected
ing:9.54764	rejected
state:9.47741	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.236
).:13.5404	rejected
,:13.2336
);:12.649	prefix accepted:)
)::12.6052	prefix accepted:)
),:12.6016	prefix accepted:)
)\:12.3198	prefix accepted:)
)?:11.9517	prefix accepted:)
::11.7868
)(:11.5491	prefix accepted:)
 |:11.4985	rejected
 ):11.3432
)|:11.329	prefix accepted:)
)[:11.0578	prefix accepted:)
.:10.8566	rejected
)!:10.4324	prefix accepted:)
 =:10.3078
)=:10.2024	prefix accepted:)
 ::10.1765
|:10.1018	rejected
 then:10.0284	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:18.7031
 :18.3916

:17.7337
 #:15.2307	rejected
 &&:15.1221
 ||:14.3738	rejected
  :13.9555
 \:13.3275
 (*:12.7708	prefix accepted: (
 //:12.5601	prefix accepted: /
    :12.0117
 -:11.9343
                :11.7591
 --:11.7234	prefix accepted: -
 and:11.6815	rejected
      :11.616
 {:11.5913	rejected
        :11.4308
 &:11.2979
 *:11.2772
 |:11.2253	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
       :20.8517
         :18.8868
        :17.0432
          :16.7766
           :16.3281
      :15.2365
	:15.1589	rejected
            :14.9013
             :14.5167
                :14.2635
     :14.2028

:13.5977
              :13.5366
#:13.5277	rejected
               :13.0221
  :12.9081
    :12.6181
   :12.2109
 :12.2102
(*:10.8226	prefix accepted:(
then:9.63911

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:23.1411
 #:18.5783	rejected
 (*:15.9437	prefix accepted: (
 ||:14.812	rejected
 &&:14.441
 let:14.0094	rejected
 //:13.8875	prefix accepted: /
 (:15.9437
 ?:13.2284	rejected
 [:13.2094	rejected
 List:13.1001	rejected
 and:12.8651	rejected
 |:12.7101	rejected
 #(:12.4389	rejected
 {:12.4219	rejected
 or:12.4086	rejected
 /*:12.3898	prefix accepted: /
 ((:12.2176	prefix accepted: (
 ():12.0416	prefix accepted: (
 else:12.0245	rejected
 the:12.0067

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.9934
 :14.6379

:14.4139
 ([:14.3753	prefix accepted: (
 List:14.3382	rejected
 let:13.2299
 No:13.1195
 ((:13.1169	prefix accepted: (
 match:12.9341	rejected
 case:12.8647
 [:12.6847
 songs:12.33
 remove:12.0734	rejected
 play:12.012
 (*:11.8137	prefix accepted: (
 get:11.6571
 no:11.4394	rejected
 {:11.2598	rejected
 if:11.0899
 #:10.9146	rejected
 []:10.8577

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
List:16.2762	rejected
song:14.4036
filter:14.261	rejected
get:13.3812
remove:12.9958	rejected

:12.8903
Filter:11.4274	rejected
play:11.3011
Play:11.288
 List:10.907	rejected
state:10.4325
 songs:9.74848
[]:9.46649
list:9.45668	rejected
set:9.39072	rejected
if:9.28613
delete:9.24724	rejected
([:8.93257	prefix accepted:(
f:8.88142
 :8.83429
fil:8.7176	rejected
Rejected the highest logit candidate List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type PlayList but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
s:18.3686
:::15.2624
 :::13.1137
,:13.066
 -:12.8084
 @:11.8264
.:10.7593	rejected
@:10.347
_:10.2929	rejected
 |:9.77718	rejected
-:9.7463
 ~:9.71467	rejected
 --:9.58526	prefix accepted: -
 \:9.42353
--:9.20469	prefix accepted:-
[:9.17074	rejected
 //:9.14091	prefix accepted: /
::8.96815
 /:9.14091
 in:8.92399	rejected
~:8.87335	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:16.0624
 @:15.5766
 -:15.156
 \:13.2617
@:11.9355
 |:11.7936	rejected
 \\:11.4905	prefix accepted: \
 --:11.2947	prefix accepted: -
.:10.9226	rejected
 ,:10.3544
-:10.3314
 ^:10.0715	rejected
 &:10.0512
 /:9.84006
\:9.78411
[:9.59152	rejected
 =:9.29068
 #:9.25019	rejected
 +:9.17029
,\:9.10067	prefix accepted:,
 //:9.03005	prefix accepted: /

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 No:18.6998
 P:12.9244
 Play:12.1819
 get:12.1471
 :12.0428
 remove:11.9002	rejected
 no:11.3371	rejected
 state:11.2867
 (:11.2775
No:11.2314
 if:11.1811
 play:10.0879
 current:10.0723	rejected
 match:9.90317	rejected
 List:9.80076	rejected

:9.69987
 None:9.69192	rejected
 [:9.58445
 ?:9.5818	rejected
 Next:9.44766	rejected
 Remove:9.33428

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  No
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:21.6856
Current:14.1175	rejected
Selected:13.9846	rejected
State:13.8465	rejected
Play:12.5601	rejected
Selection:11.9256	rejected
Sound:11.8545	rejected
_:11.8102	rejected
P:11.5965	rejected
SON:11.466	rejected
Sing:11.2332	rejected
 Song:10.8103	rejected
C:10.6487	rejected
Action:10.4322	rejected
Select:10.3758	rejected
SS:10.3255	rejected
Music:10.242	rejected
Sh:10.2132	rejected
New:10.2123	rejected
Se:10.1673	rejected
Player:9.94578	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:22.704
on:15.5973
ongs:15.3471	rejected
ung:13.4485	rejected
ng:13.1208	rejected
song:12.8686	rejected
ing:12.8483	rejected
one:12.4734	rejected
ig:11.4453	rejected
ug:11.4113	rejected
oon:11.4095	rejected
ame:11.1805	rejected
son:11.0927	rejected
ang:11.076	rejected
ongo:10.7841	rejected
onic:10.6721	rejected
ons:10.4273	rejected
n:10.3485	rejected
un:10.2244	rejected
om:10.1764	rejected
oud:10.1575	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:24.085
Select:16.0037
Se:15.104
selected:14.5369	rejected
Play:14.0155	rejected
Selection:13.5875	rejected
S:13.1647
):13.1371	rejected
Selector:12.9523	rejected
Available:12.6645	rejected
P:12.5598	rejected
Start:12.3752	rejected
Is:12.0291	rejected
SELECT:11.9253	rejected
Current:11.7665	rejected
 Selected:11.749	rejected
To:11.6142	rejected
Set:11.1812	rejected
Id:11.0923	rejected
Sec:11.0561	rejected
()):10.9653	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.0775
),:14.7971	prefix accepted:)
 ):14.4281
()):13.8422	prefix accepted:(
);:12.4056	prefix accepted:)
)\:12.2486	prefix accepted:)
,:11.8976
(:13.8422
(*:11.6325	prefix accepted:(
::11.3419
)::11.2541	prefix accepted:)
 :11.1301
)):10.9115
 ::10.8876
:::10.319
(\:10.2893	prefix accepted:(
 @:10.2759
)(:10.1665	prefix accepted:)
(@:10.1172	prefix accepted:(
():9.88325	prefix accepted:(

:9.78833

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:19.2193
 :17.9126
 else:17.744
 #:15.4266	rejected
  :15.0691
    :13.8268
 (*:13.3311	prefix accepted: (
        :13.2501
 @:13.2247
   :12.9794
      :12.8635
 \:12.356
                :12.1357
 end:11.8279	rejected
          :11.5785
     :11.5465
         :11.4803
            :11.4144
       :11.3612
 //:11.2891	prefix accepted: /
#:11.2047	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :21.5925
        :16.6966
         :15.9388
      :15.7453
	:15.6853	rejected
          :14.862
     :14.7189
           :14.6102
            :13.8874
                :13.7572
             :13.7055

:13.6653
    :13.4571
#:13.4206	rejected
              :13.2014
else:13.1412
               :12.7258
 :12.603
  :12.4199
   :12.3168
(*:10.8956	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:22.6846
 #:18.1678	rejected
 elif:15.8907	rejected
 (*:14.6656	prefix accepted: (
 els:14.5424
 let:13.8597	rejected
 List:13.5777	rejected
 (:14.6656
 el:13.2931
 if:12.6105	rejected
 //:12.4211	prefix accepted: /
 {:12.321	rejected
 [:12.1257	rejected
 ~:11.9592	rejected
 \:11.8281
 (\:11.5706	prefix accepted: (
 ,:11.3941
 case:11.3178	rejected
 match:11.2609	rejected
 Else:11.2299	rejected
 <:11.2076

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:16.6968
 :15.0915
 List:14.9322	rejected

:14.6326
 ([:14.3034	prefix accepted: (
 songs:14.1407
 ((:13.5125	prefix accepted: (
 if:13.1157
 let:12.7011
 [:12.14
 filter:12.0296	rejected
 remove:11.8587	rejected
 {:11.7451	rejected
 play:11.7309
 match:11.6464	rejected
 ():11.4992
 []:11.3295
 ({:11.1948	prefix accepted: (
 case:11.1862
 song:10.9621
(:10.935

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 @:15.4184

:15.0563
 -:14.8753
,:14.4247
 :13.6948
 |:12.6054	rejected
:::12.1484
.:12.1419	rejected
),:12.1201	prefix accepted:)
@:12.0161
):12.1201
 \:11.7851
 end:11.5867	rejected
 in:11.4894	rejected
[:11.3733	rejected
 --:11.324	prefix accepted: -
 =:11.3068
 :=:11.0335	prefix accepted: :
 ):10.9656
 //:10.8868	prefix accepted: /
 :::10.8656

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:14.9823
 List:13.3938	rejected
 filter:11.762	rejected
 (:11.5949
@:11.2745	rejected
 song:10.9128
 get:10.9121
-:10.7422
 remove:10.3436	rejected
>:10.0544	rejected
 [],:9.9705	prefix accepted: []
 [(:9.82354	prefix accepted: [
 songs:9.70041
 :9.6482
 -:9.38174
[:9.37898

:9.22658
?:9.13272	rejected
--:9.02841	prefix accepted:-
 ((:8.91794	prefix accepted: (
 Song:8.88767	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:16.4698
get:13.2568
 song:11.9049
List:11.1402	rejected
remove:11.0668	rejected
x:10.8029	rejected
Remove:10.5305
Play:9.93093
play:9.70478
id:9.63687	rejected
@:9.58365	rejected

:9.3794
P:9.35629
state:9.3233
i:9.31451
~:9.23439	rejected
if:9.16728
s:9.15605
1:9.14107
Id:9.08249	rejected
not:9.07863	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= completions | new-tokens

Top 20 Logits:
],:17.7433	prefix accepted:]
]:17.7433
]):14.5762	prefix accepted:]
]),:12.7607	prefix accepted:]
s:12.1152
:::11.9855
,:11.665
])):11.3081	prefix accepted:]
]\:10.636	prefix accepted:]
 :::10.3179
].:10.1529	rejected
]]:10.1332	prefix accepted:]
 -:10.0761
];:9.99936	prefix accepted:]
 |:9.99723	rejected
](:9.89251	prefix accepted:]
]);:9.41085	prefix accepted:]
 @:9.39705
 \:9.23159
 :=:9.1117	prefix accepted: :
|:9.07131	rejected
Rejected the highest logit candidate ], with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song]

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:15.1196
 |:13.5726	rejected
 -:13.4901
 :13.3943
 @:12.8653
 ,:12.7384
 end:12.1957	rejected
 #:12.0303	rejected
 \:11.6484
 ):11.4395
 =:10.7604
  :10.6532
 <:10.5416
 ==:10.5328
 //:10.4677	prefix accepted: /
 in:10.4385	rejected
 *:10.3259
 ===:10.0729	prefix accepted: ==
 --:9.9642	prefix accepted: -
 ||:9.90815	rejected
 ->:9.90646	prefix accepted: -

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:

:17.6176
 #:14.8582	rejected
 ,:13.7969
 @:13.5485
 ):13.5299
 (*:13.1623	prefix accepted: (
)):13.118
 |:12.8375	rejected
 -:12.7378
 //:12.536	prefix accepted: /
 \:12.3379
 end:12.2384	rejected
 <:12.066
 ),:11.6904	prefix accepted: )
 *:11.6122
 --:11.4652	prefix accepted: -
 ~:11.3874	rejected
1:10.9709	rejected
 in:10.9514	rejected
 /:12.536
0:10.5102	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
     :18.6468
         :18.0506
       :17.6883
           :16.3281
      :16.2118
        :16.0107
          :15.6451
            :14.6972
             :14.531
    :14.5309
               :13.9515
              :13.8015
	:13.6575	rejected
                :13.622
   :13.2057

:12.7212
#:12.4886	rejected
  :11.9541
 :11.4841
,:9.92141
 ,:9.21655

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ,:18.5062
 ):18.2962
 ),:16.2027	prefix accepted: )
 |:14.2033	rejected
 #:12.8241	rejected
 -:12.3148
 @:12.2218
 ).:12.0547	rejected
 end:11.6822	rejected
 (:11.19
 (*:11.164	prefix accepted: (
 );:10.9715	prefix accepted: )
 ::10.9625
 in:10.9258	rejected
 --:10.8852	prefix accepted: -
 List:10.7908	rejected
 //:10.7455	prefix accepted: /
 ||:10.6454	rejected
 (@:10.6452	prefix accepted: (

:10.1658
 \:10.1487

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:16.4455
 @:14.3402
 :13.9402
 |:13.6521
 ,:13.1478
 -:12.9717
:::12.959
  :12.8215
 in:12.3963	rejected
@:12.228
 =>:11.9207	prefix accepted: =
 ->:11.864	prefix accepted: -
 \:11.8012
    :11.6411
      :11.3356
 :::11.2941
        :11.18
 <:11.059
 end:10.9199
|:10.85
 ::10.7844

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :17.6665
     :16.7332
    :14.3764
      :14.3318

:13.9557
       :13.9054
#:13.2122	rejected
        :13.0663
  :13.0551
         :12.5417
 :12.0829
	:11.4864	rejected
end:11.4465
|:10.9635
          :10.7906
           :10.6765
(*:10.597	prefix accepted:(
                :10.4229
             :9.86881
            :9.77601
 #:9.77587	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:18.5067
 #:17.3429	rejected
 ,:13.1504
 end:12.7239
 (*:12.5696	prefix accepted: (
 <:12.2847
 in:11.5469	rejected
 case:11.371	rejected
 _:11.3347	rejected
 .:10.9659	rejected
 ...:10.8473	rejected
 ##:10.8348	rejected
 (:12.5696
 //:10.5783	prefix accepted: /
 ~:10.4084	rejected
 else:10.4011	rejected
 {:10.335	rejected
 =:10.3052
 -:10.2777
 +:10.2609
 }:10.2523	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Play:17.6919
 Add:17.1841
 _:14.9694
 P:11.9583
 Player:10.6878	rejected
Play:10.1053
 Remove:9.77699
 :9.74693
 #:9.59442	rejected
 add:9.03945
 Other:8.96355	rejected
 x:8.8848
 >:8.88252	rejected
 play:8.77061
 Update:8.76172	rejected
 (:8.63617
 Rest:8.58586	rejected
Add:8.56761
 Next:8.48256	rejected
_:8.45846
 Song:8.45095	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | Play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | Play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song" | "ing"
root ::= completions

Top 20 Logits:
S:20.4375
List:13.6662	rejected
ing:13.3413
Current:12.5827	rejected
list:11.1945	rejected
(:11.0717	rejected
Action:10.63	rejected
_:10.4952	rejected
Sound:10.4709	rejected
Or:10.1862	rejected
Play:10.1329	rejected
 Song:9.64809	rejected
 song:9.63861	rejected
song:9.63069	rejected

:9.61161	rejected
All:9.58437	rejected
Sing:9.45204	rejected
Music:9.43306	rejected
On:9.39864	rejected
Next:9.14533	rejected
ed:9.01907	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlayS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlayS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlayS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PlayS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  PlayS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PlayS
LSP: Generating Completions for prefix: PlayS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:24.0645
ongs:16.5151	rejected
on:12.367
song:11.5257	rejected
 song:11.2301	rejected
ongo:11.0831	rejected
oon:9.7827	rejected
ug:9.76714	rejected
n:9.67973	rejected
ng:9.6629	rejected
one:9.59602	rejected
oup:9.51752	rejected
ond:9.50907	rejected
(:9.37113	rejected
onic:9.35744	rejected
ame:9.25725	rejected
ound:9.22363	rejected
ang:8.88301	rejected
inger:8.80983	rejected
ou:8.64439	rejected
ONG:8.52174	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlaySong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Int -> (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  PlaySong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PlaySong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PlaySong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:17.9197
(_:14.8226	rejected
 song:13.0105	rejected
 id:12.2598	rejected
 _:11.2785	rejected
 (:10.7626
(?:10.7076	prefix accepted:(
(-:10.5744	prefix accepted:(
():10.3376	prefix accepted:(
((:10.2545	prefix accepted:(
 s:10.1094	rejected
 =>:10.0937
([:10.0519	prefix accepted:(
 ->:10.0036	rejected
 new:9.4493	rejected
 next:9.28455	rejected
 x:9.25375	rejected
 None:9.13441	rejected
 current:9.05629	rejected
 i:8.8237	rejected
(":8.81254	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:18.3043
id:16.1564
new:15.0633
next:14.2457
selected:14.0122
current:13.6348
x:13.1609
idx:12.4425
i:12.4296
Id:12.4018	rejected
0:12.3503
None:12.1967	rejected
target:12.1665
play:12.0498
n:11.8907
s:11.74
index:11.7051
?):11.6336	rejected
to:11.5021
sound:11.3855
maybe:11.3748

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):18.0135
)=:13.3574	prefix accepted:)
_:13.2519
'):12.4989	rejected
1:12.3871
_):12.3797	prefix accepted:_
),:12.361
 as:12.3508	rejected
)->:11.9267	prefix accepted:)
::11.8214	rejected
,:11.6291
k:10.8018
0:10.685
:::10.6742	rejected
2:10.5636
)::10.314	prefix accepted:)
 =:10.2975	rejected
__:10.0749
)|:10.0233	prefix accepted:)
To:9.9674
 ):9.61997

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.2573
 ->:15.5454	rejected
 when:13.8255	rejected
 :12.9061

:12.3171
  :12.2132
 if:11.8726	rejected
    :11.4272
 as:11.0796	rejected
 |:10.9719	rejected
   :10.7949
 :::10.0024	rejected
      :9.93506
 ||:9.77653	rejected
 =:9.50471
=>:9.45003
 :=:9.43363	rejected
     :9.40999
 ==>:9.05063	prefix accepted: =
 ?:8.97291	rejected
        :8.91653

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.845
 (:16.2292
 :15.9417
 play:14.1093
  :13.9004
 ([:13.6297	prefix accepted: (
 ((:12.9165	prefix accepted: (
 #:12.7664	rejected
 ?:12.7617	rejected
 (*:12.7039	prefix accepted: (
 id:12.3465
 update:12.27
    :12.2466
 ():12.069
 if:11.9808
 let:11.9185
 List:11.9117	rejected
 [:11.4797
 get:11.4384
        :11.2697
 [(:11.121	prefix accepted: [

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.9057
      :18.9193
    :17.4514
       :17.2863
        :16.0021
   :15.8529
         :15.6285
#:14.8311	rejected
	:14.635	rejected

:14.4871
           :14.045
          :13.8829
  :13.7068
            :12.9982
                :12.705
 :12.5835
             :12.3633
               :11.9479
              :11.7605
let:11.4965
 #:11.218	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:19.8082
 (:19.445
 case:19.3166
 #:17.9831	rejected
 if:17.7151
 ([:16.6679	prefix accepted: (
 match:16.5035	rejected
 (*:16.1046	prefix accepted: (
 ((:16.0625	prefix accepted: (
 play:15.7511
 List:15.6918	rejected
 begin:15.2277	rejected
 get:15.0217
 {:14.469	rejected
 update:14.3287
 [:14.2456
 id:14.1112
 ?:14.0811	rejected
 [(:14.0125	prefix accepted: [
 []:13.8276
 ():13.6628

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:16.1547
 current:12.1648
 _,:12.1188	prefix accepted: _
 new:12.0049
 song:11.9562
 ids:11.8993
 all:11.8084
 _:12.1188
 id:11.4984
 play:11.0561
 (:11.0237
 xs:10.7135
 state:10.6145
 s:10.5537
 is:10.4536
 remove:10.3822
 filtered:10.2254
 list:10.1538
 valid:9.91909
 un:9.87832
 cur:9.83119

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.0527
 =:17.5397
 ,:14.4963
_:14.4232
_,:12.7476	prefix accepted:_
::12.4698
1:12.2011
@:11.9469	rejected
 :11.5175
 ::11.4973
 @:11.2351	rejected
',:11.1775	rejected
=:11.0903
0:10.8936
  :10.8208
2:10.6326
 in:10.3743	rejected
':10.1945	rejected
 _,:10.062	rejected
In:9.82834
 :=:9.71155	prefix accepted: :

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:16.7532
 state:16.0047
 _:15.6662
 old:12.027
 song:11.8433
 playing:11.8169
 play:11.6327
 s:11.2932
 curr:11.2116
 prev:10.889
 id:10.8517
 selected:10.8457
 previous:10.7239
 p:10.547
 status:10.3623
 cur:10.3336
 x:9.98693
 songs:9.94475
 c:9.84013
 st:9.77371
 player:9.77353

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: ?, songs: ?, id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: state
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.1432
 :14.4182
=:13.7181
_:13.6154
,:12.5364
  :12.2759
 ->:12.1634	rejected
':12.1356	rejected
1:11.8595
0:11.4403
 in:11.0968	rejected
    :11.0809
 as:10.9212	rejected
2:10.8988
::10.8493
 ==:10.5866	prefix accepted: =
   :10.5057
 ::10.344

:10.06
      :9.93324
@:9.7029	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:18.8917
 :12.6828

:12.6604
 (:12.59
 List:12.2861	rejected
 get:11.8599
 action:11.5895
 update:11.2461
play:10.9511
 remove:10.7021	rejected
 current:10.4679	rejected
 pl:10.2531
 list:10.2323	rejected
 p:10.2119
 songs:10.1751	rejected
 Play:10.0233
 pal:9.74959	rejected
 song:9.66446	rejected
 add:9.60191	rejected
 id:9.53629
 f:9.39965

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:20.2529
let:12.9397	rejected
List:12.7056	rejected
view:12.1312	rejected
l:11.6087
 list:11.393	rejected
ist:11.3672	rejected
link:11.2217	rejected
load:10.8604	rejected
lst:10.4973	rejected
lis:10.4587
li:9.9161
lit:9.88737	rejected
_:9.73224	rejected
land:9.59424	rejected
label:9.32199	rejected
lt:9.32125	rejected
,:9.31134	rejected
last:9.18164	rejected
log:9.15025	rejected
lists:9.09465	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.3079
,:15.0439

:14.5891
 :14.2074
;:12.7376	rejected
  :12.0237
.:11.98	rejected
 and:11.5819	rejected
 ,:10.965
in:10.9136
    :9.95173
 |:9.78009	rejected
 #:9.77205	rejected
 ;:9.47633	rejected
   :9.43853
                :9.42127
 ?:9.29118	rejected
      :9.22231
 where:9.118	rejected
 @:9.1144
	:9.06211	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.2414
 :16.0268
  :14.8307
      :13.9308
    :13.6374
 List:12.585	rejected
        :12.4311
 (:12.3143
   :11.8774
 case:11.8115
     :11.7175
          :11.6577
            :11.5295
                :11.5275
         :11.4693
 songs:11.2635
       :11.046
 (*:10.7813	prefix accepted: (
	:10.5343	rejected
           :10.5025
 #:10.4467	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.3367
      :16.8664
       :16.226
    :15.5799
         :15.0201
        :14.9342

:14.9084
   :14.375
	:13.527	rejected
  :13.208
          :13.1205
           :13.0703
#:12.9861	rejected
 :12.211
                :11.7967
(*:11.5823	prefix accepted:(
            :11.475
             :11.3604
case:11.1152
               :10.9157
              :10.2921

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:20.464
 match:18.8411	rejected
 (:18.7644
 if:18.3119
 let:17.2001
 #:16.7245	rejected
 List:16.0671	rejected
 ([:15.7494	prefix accepted: (
 (*:15.385	prefix accepted: (
 ((:15.359	prefix accepted: (
 songs:15.2903
 begin:14.0824	rejected
 assert:13.9773	rejected
 play:13.9744
 state:13.9298
 Play:13.72
 {:13.611	rejected
 id:13.3132
 Songs:13.232	rejected
 song:13.1116
 [:12.7894

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 state:16.9505
 List:15.139	rejected
 songs:14.2883
 id:13.9802
 get:13.9403
 current:13.7256	rejected
 (:12.5717
 find:11.7936	rejected
 Songs:11.7446	rejected
 is:10.7375
 s:10.729
 song:10.642
 play:10.6216
 :10.453
 list:10.3162	rejected
 f:10.2258

:10.1107
 index:9.9438	rejected
 ids:9.84283	rejected
 not:9.82222	rejected
 ():9.79602

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: state
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.2982
 :17.4037
 of:16.9676	rejected
  :15.0745
,:15.0094
 in:13.8407	rejected
    :13.3675
      :13.0307
 #:12.5076	rejected
 =:12.305
 ==:12.2484
 with:12.1364	rejected
                :12.1313
   :12.0836
        :11.9385
::11.6324
 end:11.4513
 is:11.4473	rejected
         :11.3839
     :11.3492
          :11.3059

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :22.5302
      :18.4911
       :17.7407
    :16.4873
        :16.421
         :16.3537
#:15.8471	rejected

:15.7871
	:15.5119	rejected
   :15.2108
          :14.846
           :14.517
                :13.9759
|:13.8499
            :13.6248
  :13.6071
 :12.9511
             :12.9301
               :12.6744
              :12.0401
(*:11.836	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.3847
 #:18.065	rejected
 (*:14.6406	prefix accepted: (
 ||:12.145	prefix accepted: |
 *:11.9225
 (:14.6406
 P:11.6766	rejected
 <:11.516
 #(:11.2246	rejected
 ##:11.0895	rejected
 \:11.0577
 {:11.0236	rejected
 (**:10.9154	prefix accepted: (
 -:10.8011
 case:10.7757	rejected
 #{:10.7753	rejected
 ~:10.5963	rejected
 ((:10.4536	prefix accepted: (
 |\:10.4304	prefix accepted: |
 end:10.324
 ?:10.2107	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 P:17.3474
 Play:16.3449
 No:15.7204
 _:14.0529
Play:11.6349
 :10.7638
P:10.6839
 (:10.4517
 Player:10.2356	rejected
 None:10.0082	rejected
No:9.92904
 no:9.28631
 N:9.07182
 Remove:9.05787
 Not:9.0001	rejected
 Some:8.95328	rejected
 Next:8.84109	rejected
 playing:8.79355
 #:8.59475	rejected
 _,:8.54281	prefix accepted: _
 Current:8.47419	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
aused:23.6881
ause:16.2346
aus:13.3515
ending:12.7339	rejected
ushed:12.2008	rejected
au:11.5698
LAY:11.1115	rejected
osed:10.8588	rejected
icked:10.5316	rejected
 paused:10.4571	rejected
ued:10.4012	rejected
ased:10.0391	rejected
uzz:9.7824	rejected
lain:9.77383	rejected
leased:9.75615	rejected
ared:9.62285	rejected
lapsed:9.41225	rejected
rep:9.34947	rejected
ained:9.18646	rejected
aged:8.996	rejected
ended:8.97371	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | Paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | Paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:21.0815
 =>:13.4709	rejected
(:13.0015	rejected
 on:11.9913	rejected
on:11.9596	rejected
S:11.9212	rejected
 ->:11.2548	rejected
(_:11.1996	rejected
 On:11.0982	rejected
Current:10.8089	rejected
O:10.7158
():10.4498	rejected
One:10.2765	rejected
 _:9.8989	rejected
_:9.80298	rejected
State:9.75883	rejected
ON:9.63251	rejected
In:9.61612	rejected
Of:9.43171	rejected
 song:9.20599	rejected
Off:9.13795	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:17.1454
(_:16.7006	rejected
 _:12.707	rejected
 song:12.1167	rejected
 id:11.8557	rejected
 s:11.7868	rejected
():10.8076	prefix accepted:(
 x:10.6189	rejected
 (:10.3473
 p:10.0796	rejected
 i:10.0192	rejected
 current:9.8846	rejected
((:9.43799	prefix accepted:(
(`:9.31363	prefix accepted:(
 ->:9.09503	rejected
(*):8.92937	prefix accepted:(
(?:8.8674	prefix accepted:(
 =>:8.82637
 (_:8.79268	rejected
 a:8.63261	rejected
 old:8.62889	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:16.5695
current:15.4794
id:15.1527
p:14.651
x:14.1409
old:13.8222
i:13.6281
prev:13.4804
s:13.4782
last:13.2151
previous:12.9009
curr:12.711
play:12.6873
selected:12.4248
cur:12.2618
other:12.1718
pid:11.5355
some:11.3566
n:11.3196
same:11.3078
idx:10.993

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(p

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(p
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
aused:16.0219
ause:14.825
):14.313
aus:13.1678
_:12.397
ending:11.0628
au:10.957
Id:10.9165
rior:10.0999
ast:10.0074
ID:9.11323
icked:9.10095
S:9.06069
asted:8.74376
id:8.741
)->:8.4499	prefix accepted:)
),:8.42229
ong:8.38041
ref:8.29394
)=:8.28084	prefix accepted:)
1:8.26752

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: paused
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: paused
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
_:18.3002
):17.1887
Id:15.9231
S:15.1432
On:14.196
ID:12.8332
_):11.7255	prefix accepted:_
id:11.714
on:11.7051
song:11.2653
)->:11.2494	prefix accepted:)
)=:10.948	prefix accepted:)
At:10.4705
),:10.2316
__:10.2253
Play:10.19
-:10.1644	rejected
 song:9.94748	rejected
State:9.85695
 ->:9.58568	rejected
One:9.45941

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.3805
 when:16.5891	rejected
 if:14.3845	rejected
 ->:14.0807	rejected

:12.1827
 :12.1671
 as:10.7361	rejected
 \:10.6521	rejected
  :10.3942
 |:10.1816	rejected
 &&:10.0379	rejected
 and:9.62801	rejected
 where:9.4134	rejected
 ==:9.27283	prefix accepted: =
 ?:9.22286	rejected
=>:9.2103
when:9.20955	rejected
 ::9.18046	rejected
 =:9.27283
 ||:9.03877	rejected
    :8.80912

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:17.7691

:17.3488
 (:16.6834
 :15.7419
 songs:13.971
 ((:13.8547	prefix accepted: (
 ([:13.6121	prefix accepted: (
 play:13.2577
  :13.1179
 List:12.0789	rejected
 [:11.891
 [(:11.6378	prefix accepted: [
 ():11.5309
 (*:11.394	prefix accepted: (
 #:10.9353	rejected
 song:10.7773
 assert:10.7515	rejected
    :10.707
 ?:10.697	rejected
if:10.5722
 id:10.4264

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 id:17.9172
 paused:15.853
 song:14.1582
 (:12.3344
 not:12.0628	rejected
 songs:11.4677
 p:11.2149
 List:10.6914	rejected
(:10.5878
 :10.4845
 !:10.2028
 Id:9.96768	rejected
 same:9.93107	rejected
 pause:9.88342
 ids:9.88059	rejected
 i:9.85937
 Song:9.85033	rejected
 ?:9.69153	rejected
 Songs:9.52341	rejected
 is:9.49234
 state:9.32673

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type Bool but got inconsistent type Id  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 ===:18.4549	prefix accepted: ==
 =:17.4305
 ==:18.4549
 \:13.3742
 <:13.3485
 >:12.6452
=:12.6449
==:12.548
 !=:12.4975
===:12.2796	prefix accepted:==
 &&:11.9558
 !==:11.8861	prefix accepted: !=
 is:11.6938	rejected
 =~:11.6674	prefix accepted: =
 :11.3866
 =\:11.2099	prefix accepted: =
 <>:11.201	prefix accepted: <
 ?:10.9463	rejected
 ~:10.5925	rejected
 @:10.4807
 >=:10.4716
Rejected the highest logit candidate  === with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 paused:16.9219
?:11.6927	rejected
#:11.6205	rejected
==:11.0029	rejected
 stopped:10.4956	rejected
@:10.46	rejected
::10.3018	rejected
===:10.2557	rejected
 song:10.2305
~:10.0465	rejected
 :9.7097
 pause:9.68423
$:9.43536	rejected
*:9.19214	rejected
%:9.15747	rejected
<:9.05301	rejected
====:9.04194	rejected
.:8.83726
 played:8.77424	rejected
??:8.70706	rejected
!:8.64448

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: paused
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: paused
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:17.4317

:14.91
 :14.487
 (:12.9714
 ((:11.8671	prefix accepted: (
 (*:11.5758	prefix accepted: (
 ?:11.5744	rejected
,:11.545
 \:11.2573
  :11.25
 [:11.0127	rejected
 [(:10.9254	rejected
 ([:10.8336	prefix accepted: (
 &&:10.5506
 ->:10.5113	prefix accepted: -
 ||:10.4078	rejected
 #:10.3849	rejected
 the:10.3276
(:10.0226
 play:9.72146	rejected
 //:9.65686	prefix accepted: /

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:16.9452
 play:14.8808
 ([:14.2381	prefix accepted: (

:13.7802
 :13.015
 songs:13.0055
 ((:11.8064	prefix accepted: (
 [:11.5439
 [(:11.4222	prefix accepted: [
(:10.6618
 Play:10.6017
 List:10.5679	rejected
 song:10.334
 []:10.3086
  :10.2253
 [],:10.0837	prefix accepted: []
 (*:10.067	prefix accepted: (
 ?:9.9904	rejected
 Songs:9.89855	rejected
 ():9.44974
 get:9.4321

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:18.9483
play:14.1083
List:13.6974	rejected
get:13.1363
state:12.5282
p:12.5012
id:12.0402
remove:12.0163	rejected

:11.8785
sing:11.5117	rejected
 songs:11.3875
ids:10.6795	rejected
list:10.3217	rejected
P:10.1375
Play:10.0858
s:10.0549
x:9.91681	rejected
?,:9.8908	rejected
[]:9.82254
f:9.6027
_,:9.56928	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:20.9426
,:14.7105	rejected
:::12.3733	rejected
 @:11.1073	rejected
@:11.0628	rejected
 :::11.0545	rejected
 //:10.053	rejected
 ,:10.0476	rejected
es:9.37605	rejected
_:9.36989	rejected
.:9.31039	rejected
//:8.91636	rejected
ss:8.85755	rejected
[:8.73002	rejected
ns:8.58714	rejected
 ||:8.36749	rejected
///:8.28901	rejected
z:8.24244	rejected
,(:8.23836	rejected
 -:8.23038	rejected
st:8.1374	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.5653
 @:14.451
 ,:14.3358
@:12.0325
 -:11.6918
 +:10.659
 \:10.4172
::10.2373
.:10.1291	rejected
,(:10.0864	prefix accepted:,
 ::9.80946
,[:9.73691	prefix accepted:,
 ++:9.70713
@@:9.47547	prefix accepted:@
,,:9.47325	prefix accepted:,
 :9.37345
),:9.19198	prefix accepted:)
,\:9.18828	prefix accepted:,
 |:9.15042	rejected
:::9.064
 //:9.02466	prefix accepted: /

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 Play:17.671
 P:14.8936
 state:13.4795
Play:13.0688
 playing:13.0576	rejected
 current:12.5969	rejected
 No:12.4789
 (:11.3832
 :11.273
 get:11.2128
 play:10.931
 Player:10.603	rejected
P:10.2103
 song:10.1285
  :9.61339
 Current:9.52462	rejected
 songs:9.49429
 Songs:9.45182	rejected
 id:9.38014
 paused:9.34146

:9.2944

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  Play
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song" | "ing"
root ::= completions

Top 20 Logits:
ing:24.2735
S:15.8429
List:15.2943	rejected
(:13.7166	rejected
ed:13.6789	rejected
ling:13.6383	rejected
i:12.523
State:12.2475	rejected
P:12.1608	rejected
in:12.1237
ng:11.6483	rejected
eing:11.374	rejected
sing:11.3623	rejected
L:11.1977	rejected
Play:11.1152	rejected
Sing:10.9531	rejected
):10.887	rejected
ning:10.8339	rejected
ings:10.829	rejected
ING:10.8091	rejected
ig:10.7949	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end in
  LSP: Info: ALL errors:
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.1148
 paused:13.7475	rejected
 id:13.2454	rejected
 (:12.7354
()):12.5149	prefix accepted:(
):11.9701
((:11.7347	prefix accepted:(
 song:10.5526	rejected
([:10.4673	prefix accepted:(
 p:10.3656	rejected
 pause:10.113	rejected
)(:10.0398	prefix accepted:)
[:9.95115	rejected
(_:9.76748	rejected
(?:9.61953	prefix accepted:(
({:9.31079	prefix accepted:(
(-:9.03195	prefix accepted:(
(...:8.9386	rejected
(":8.83732	prefix accepted:(
(*:8.81666	prefix accepted:(
Id:8.78441	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
id:19.1395
p:19.0655
song:16.4879
play:13.5065
sing:13.0613	rejected
P:11.8951
state:11.4549
i:11.265
0:11.0627
current:10.4479	rejected
ids:10.4372	rejected
s:10.3786
pid:10.3538	rejected
Id:10.3333	rejected
 paused:10.1759
get:10.0762
 song:10.0443
x:9.934	rejected
f:9.87617
1:9.86102
music:9.85259	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)):22.2426
)),:15.5711	prefix accepted:))
):15.1921
));:14.7469	prefix accepted:))
),:14.5568	prefix accepted:)
))\:14.2199	prefix accepted:))
))::12.6327	prefix accepted:))
)\:11.8629	prefix accepted:)
,:11.5424
 :11.411
)).:11.3299	prefix accepted:)
))):11.0963	prefix accepted:))
))`:10.8829	prefix accepted:))
)::10.7261	prefix accepted:)
 +:10.6962
::10.4669
)))):10.4333	prefix accepted:))
 -:10.3045
)));:10.0961	prefix accepted:))
)){:9.92451	prefix accepted:))
))]:9.80724	prefix accepted:))

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id))

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:16.8841

:14.9187
 :13.4546
 \:11.3844
  :11.3227
 end:11.0416	rejected
 el:10.6885
 #:10.4211	rejected
    :10.2893
else:10.2236
 elif:10.1952	rejected
 els:9.46536
   :9.14384
      :9.06275
 otherwise:8.52234	rejected
     :8.399
        :8.33711
 ,:8.1272
                :7.8806
 ?:7.7859	rejected
 play:7.71718	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:16.0543
 (:15.5896
 ?:13.2664	rejected

:12.1823
 ([:11.7316	prefix accepted: (
 :11.6962
 ((:11.2864	prefix accepted: (
 [(:10.6863	prefix accepted: [
 []:10.4849
 update:10.4531
 [:10.6863
 fail:10.1529	rejected
 raise:9.72384	rejected
(:9.66682
 error:9.5822	rejected
 (?:9.48612	prefix accepted: (
 song:9.32716
 List:9.22079	rejected
 add:9.18115	rejected
 ():8.98657
 Play:8.91141

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:18.3521
play:13.9203
List:13.4816	rejected
id:13.0996
get:12.1259
state:12.0949
p:11.8566
sing:11.6373	rejected

:11.5916
?,:11.3564	rejected
remove:11.0662	rejected
Play:10.7883
ids:10.3937	rejected
(),:10.3813	prefix accepted:()
[]:10.331
 songs:10.3215
if:10.2721
print:10.2356	rejected
P:10.1968
0:10.0994
add:10.082	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:19.1121
,:13.2282	rejected
es:11.3994	rejected
):10.3176	rejected
S:9.94807	rejected
=:9.00783	rejected
song:8.75551	rejected
[:8.71658	rejected
),:8.46167	rejected
 ,:8.45203	rejected
 +:8.17779	rejected
::8.13036	rejected
 =:8.0061	rejected
 -:7.82027	rejected
eds:7.76821	rejected
1:7.75189	rejected
@:7.67359	rejected
 Songs:7.64455	rejected
 :7.61068	rejected
:::7.60285	rejected
Ids:7.54224	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.1181
 @:15.0151
 ,:13.6145
@:12.6433
 \:11.6376
 -:11.513
,[:10.8402	prefix accepted:,
 +:10.6942
,(:10.3914	prefix accepted:,
):10.2503
),:9.762	prefix accepted:)
.:9.75861	rejected
::9.56837
,\:9.50573	prefix accepted:,
[:9.41319	rejected
\:9.39491
,,:9.32254	prefix accepted:,
 [:9.30194	rejected
[@:9.20896	rejected
 ++:9.15709
:::9.07576

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "paused" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 No:17.0178
 state:15.9082
 P:15.1942
 Play:14.0774
 current:12.4398	rejected
state:11.8693
 paused:11.2738
P:11.0494
 play:10.903
No:10.7829
 get:10.7558
 playing:10.3607	rejected
 :10.3424
Play:9.90253
 (:9.88589
 pause:9.77383
 State:9.59211	rejected
 p:9.39676
 no:9.32171	rejected
 song:9.23964
 Current:9.21766	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:20.452
Play:12.6914	rejected
P:12.6535	rejected
Selected:12.2403	rejected
Selection:12.0394	rejected
Sound:11.9341	rejected
State:11.9141	rejected
_:11.8435	rejected
Current:11.3052	rejected
Action:10.9364	rejected
SON:10.7775	rejected
New:10.3573	rejected
Sing:10.2893	rejected
 song:10.2769	rejected
C:10.25	rejected
Sh:10.0676	rejected
 Song:10.0359	rejected
Id:9.98577	rejected
Se:9.93115	rejected
Error:9.83511	rejected
M:9.80242	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:22.2798
on:16.3593
ongs:14.9635	rejected
ung:13.2237	rejected
ng:12.7896	rejected
ug:12.3527	rejected
uch:11.7949	rejected
oup:11.4673	rejected
ons:11.4464	rejected
ongo:11.4053	rejected
onic:11.1793	rejected
om:11.1134	rejected
now:10.6446	rejected
ang:10.5609	rejected
ig:10.5318	rejected
word:10.3899	rejected
oon:10.2585	rejected
lot:10.2167	rejected
one:10.1893	rejected
ond:9.97331	rejected
ink:9.94566	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:23.2189
Select:15.5704
Se:14.9108
Selection:14.5318	rejected
selected:14.1238	rejected
P:13.5649	rejected
Play:13.3663	rejected
S:13.1354
Current:12.6864	rejected
Selector:12.6234	rejected
):12.2263	rejected
State:12.1531	rejected
Available:11.7594	rejected
Start:11.7395	rejected
SELECT:11.4527	rejected
Pressed:11.4233	rejected
Is:11.2817	rejected
Pres:10.9848	rejected
Status:10.7558	rejected
Not:10.747	rejected
 Selected:10.6701	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.1104
),:13.5159	prefix accepted:)
 ):13.0771
);:13.052	prefix accepted:)
 end:11.2652	rejected
)\:10.6668	prefix accepted:)
)(:10.6259	prefix accepted:)
)):10.5857
(:10.5351
,:10.5346
)::10.3747	prefix accepted:)
 :10.22

:9.93947
(*:9.8834	prefix accepted:(
 +:9.88331
)|:9.72356	prefix accepted:)
()):9.56897	prefix accepted:(
::9.54025
 ::9.245
 |:9.0784	rejected
 \:9.06972

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.3344
 end:17.0647
 :16.2634
  :15.9842
 #:14.5178	rejected
      :14.4995
    :14.0147
 else:13.2349	rejected
        :13.0765
   :13.0536
 |:12.8377
 (*:12.7471	prefix accepted: (
       :12.681
                :12.5208
            :12.371
     :12.318
          :12.1709
#:12.1225	rejected
         :11.7433
 \:11.7204
           :11.4672

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.7288
       :15.9447
      :15.6819
                :15.2451
#:14.5332	rejected
   :14.4883
    :14.3845
	:14.0661	rejected

:13.9828
        :13.626
           :13.4461
         :13.4109
          :13.0509
            :13.0136
|:12.7902
  :12.4601
             :12.3013
(*:12.2157	prefix accepted:(
 :12.1356
               :12.099
              :12.0945

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.9581
 #:18.2331	rejected
 end:15.452
 (*:15.1916	prefix accepted: (
 _:13.6709	rejected
 else:13.1644	rejected
 (_:12.6992	rejected
 //:12.326	prefix accepted: /
 if:12.1977	rejected
 (:15.1916
 case:12.0246	rejected
 <:11.5447
 (**:11.5234	prefix accepted: (
 ##:11.461	rejected
 *:11.4562
 /*:11.2059	prefix accepted: /
 !:11.1548
 ||:11.1256	prefix accepted: |
 {:10.899	rejected
 elif:10.8925	rejected
 \:10.8507

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:18.2818
 No:15.3791
 Play:15.3384
 :12.1181
_:11.7756
 x:10.6796
 P:10.5218
 other:10.4769
Play:10.0446
 Other:10.0291	rejected
 Player:9.82487	rejected
 otherwise:9.73086
 playing:9.70445
 others:9.21507
 no:9.04221
 Not:9.04103	rejected
 (:9.01418
 None:8.8753	rejected
  :8.873
 N:8.85402
 _,:8.75092	prefix accepted: _

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.9237
               :14.5106
 ->:14.4377	rejected
 :13.6338
=>:13.0144
 :::12.2577	rejected
 if:11.5562	rejected
 :=:11.2269	rejected
                :11.1601
 else:11.043	rejected
:::11.0252	rejected
              :10.9539
  :10.6709
 when:10.3104	rejected
 |:10.2491	rejected
       :10.0955
 then:9.92833	rejected
    :9.91672
           :9.69779
             :9.6962
   :9.54331

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:16.7646
 :15.0484
 play:14.775
 if:14.7361
 ?:13.7255	rejected

:13.6696
 songs:12.4405
 let:12.1012
 ((:12.0858	prefix accepted: (
 [:11.5469
 List:11.3676	rejected
  :11.0113
 get:10.9356
(:10.6217
 ([:10.5805	prefix accepted: (
 song:10.1379
 (?:9.94945	prefix accepted: (
 match:9.91858	rejected
 (*:9.85123	prefix accepted: (
                :9.79612
 []:9.73977

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:18.9013
List:14.4239	rejected
get:13.48

:13.4791
if:13.3235
play:13.185
id:12.7117
sing:12.0161	rejected
 songs:11.318
remove:11.2965	rejected
state:10.944
let:10.9295
filter:10.9132	rejected
ids:10.7792	rejected
print:10.1596	rejected
[]:10.1376
Play:9.84567
add:9.84438	rejected
p:9.7771
s:9.70433
f:9.65418

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:20.7392
,:13.6591	rejected
 -:12.3182	rejected
 @:11.2853	rejected
es:10.9634	rejected
S:10.7375	rejected
@:10.6441	rejected
):10.2134	rejected
song:10.179	rejected
:::9.51517	rejected
.:9.50158	rejected
=:9.44773	rejected
 :9.22748	rejected
 =:9.18719	rejected
 :::9.13821	rejected
_:9.09947	rejected
 ,:9.05396	rejected
 +:8.96736	rejected
-:8.93713	rejected
[:8.87031	rejected
),:8.81169	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.3273
 @:17.5273
 ,:14.6393
 -:12.748
 \:12.0822
 +:11.9699
@:11.6228
 [:10.7871	rejected
 :10.7298
 ++:10.4324
,[:10.3057	prefix accepted:,
::9.91533
 \\:9.91175	prefix accepted: \
.:9.82596	rejected
 --:9.76191	prefix accepted: -
,,:9.64958	prefix accepted:,
 |:9.50179	rejected
 [],:9.43264	rejected
 ::9.40289
,\:9.25394	prefix accepted:,
[@:9.20201	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 No:16.9593
 Play:16.4331
 P:13.1765
 :12.5882
Play:12.0283
No:11.9384
 if:11.6703
 state:11.3133
 (:10.5454
 playing:10.4645	rejected
 get:10.3887
 play:10.3132
 current:10.2367	rejected
 no:10.1125	rejected
 Player:10.0502	rejected
P:9.22445
 ?:9.16666	rejected
  :9.15816
 Current:9.12794	rejected
 None:9.05961	rejected
 State:8.67265	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:21.0329
State:12.519	rejected
Play:12.0726	rejected
_:11.8343	rejected
SON:11.3815	rejected
Selection:11.377	rejected
Sound:11.2952	rejected
Current:11.294	rejected
Sh:11.1864	rejected
Selected:11.1032	rejected
 Song:10.9361	rejected
Sing:10.6997	rejected
Se:10.6431	rejected
 song:10.621	rejected
So:10.3324
P:10.2206	rejected
New:9.97533	rejected
St:9.85075	rejected
Player:9.57686	rejected
Action:9.53499	rejected
SS:9.51846	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:22.7577
on:15.0315
ongs:14.5137	rejected
ung:12.9572	rejected
om:12.2604	rejected
song:11.8594	rejected
ound:11.7557	rejected
ng:11.6831	rejected
oon:11.1824	rejected
ons:11.1605	rejected
ing:11.0475	rejected
og:10.9136	rejected
ond:10.6344	rejected
ony:10.5538	rejected
 song:10.4712	rejected
ang:10.2927	rejected
ug:10.2383	rejected
ou:10.1248	rejected
ongo:9.99106	rejected
ONG:9.98108	rejected
one:9.9426	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:21.9357
selected:14.4054	rejected
Select:14.0557
Se:13.5296
S:12.7233
Current:12.3624	rejected
Selection:12.1369	rejected
SELECT:11.987	rejected
Start:11.664	rejected
 Selected:11.1371	rejected
Selector:10.9062	rejected
Play:10.8619	rejected
Available:10.7479	rejected
State:10.6214	rejected
):10.4755	rejected
 selected:10.2868	rejected
P:10.2323	rejected
Loaded:10.2304	rejected
_:10.008	rejected
SE:9.88396	rejected
ed:9.57478	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs id action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.9189
 end:14.53	rejected
 ):14.4542
)):14.197
),:13.9905	prefix accepted:)
);:13.2338	prefix accepted:)
 :11.821
 +:11.3543
)),:11.1648	prefix accepted:))
(:11.0931

:11.053
,:10.6916
(*:10.6453	prefix accepted:(
 (*:10.593	prefix accepted: (
));:10.5375	prefix accepted:))
()):10.4056	prefix accepted:(
))):10.2216	prefix accepted:))
 @:10.1765
)(:10.1113	prefix accepted:)
)]:9.97792	prefix accepted:)
)}:9.92729	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:18.5692

:15.5047
 :15.2411
end:12.9903
  :12.3195
 #:10.9569	rejected
      :10.9135
   :10.8672
 in:10.6392	rejected
                :10.4885
 (*:10.4094	prefix accepted: (
    :10.3441
        :9.86522
       :9.44268
          :9.28985
     :9.14931
            :9.12453
         :8.90309
 if:8.85085	rejected
	:8.64151	rejected
              :8.19542

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.2915
 :16.9223
 in:15.0925	rejected
  :14.5874
      :13.2786
    :13.2702
 end:13.1942
   :13.037
 #:12.7383	rejected
        :11.8257
                :11.3292
       :11.145
	:10.9056	rejected
     :10.8898
          :10.651
 (*:10.6036	prefix accepted: (
            :10.5292
         :10.0733
,:9.90867
;:9.85897	rejected
           :9.56732

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.0856
    :14.9934
  :14.642
 :14.4554

:14.3094
end:14.1407
     :13.9167
#:13.8136	rejected
      :13.7759
in:13.2272	rejected
       :12.6
        :12.0534
         :10.9592
	:10.9482	rejected
|:10.8973
(*:10.8548	prefix accepted:(
                :10.7309
          :10.6707
            :10.3811
 #:10.3202	rejected
and:10.1709	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], id: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:19.791
 #:18.5347	rejected
 (*:14.6781	prefix accepted: (
 end:13.9078
 in:12.8322	rejected
 //:11.9448	prefix accepted: /
 ~:11.7096	rejected
 <:11.6575
 @:11.6306
 /*:11.1592	prefix accepted: /

:10.9853
 ##:10.9306	rejected
 *:10.8934
 +:10.8646
 (:14.6781
 case:10.7917	rejected
 {:10.7491	rejected
 -:10.5213
 _:10.5065	rejected
 }:10.3815	rejected
 else:10.3069	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:20.2185
 _:14.3137
 :12.8609
Add:12.7152
 Remove:11.2407
_:11.2087
 #:10.7492	rejected
Â :10.7472	rejected
 song:10.61
 P:10.5194
 Play:10.507
 add:10.4205
 x:10.3035
>:10.2814	rejected
 otherwise:10.0595
 (:9.69546
 No:9.59685
 >:9.40954	rejected
 ~:8.92319	rejected
  :8.89995
	:8.83401	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | Add

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | Add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:21.0365
song:13.1116	rejected
_:11.957	rejected
To:11.7848	rejected
(:11.5413	rejected
 Song:10.7961	rejected
SON:10.7613	rejected
 song:10.7301	rejected
s:10.6205	rejected
New:10.1103	rejected
Sing:10.0509	rejected
Current:9.98733	rejected
Play:9.72826	rejected
On:9.64042	rejected
Sound:9.27491	rejected
T:9.26485	rejected
Music:8.82145	rejected
P:8.75798	rejected
All:8.74925	rejected
Remove:8.65702	rejected
Art:8.53327	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  AddS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddS
LSP: Generating Completions for prefix: AddS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:24.2147
ongs:16.9433	rejected
on:13.8251
ongo:12.5867	rejected
song:12.4246	rejected
ang:12.043	rejected
ond:11.6038	rejected
ng:11.5415	rejected
 song:11.2943	rejected
n:11.0508	rejected
ug:10.9336	rejected
ame:10.9171	rejected
oon:10.8376	rejected
og:10.6619	rejected
om:10.6368	rejected
ung:10.1904	rejected
ig:10.1789	rejected
one:10.0088	rejected
ons:9.99115	rejected
ogn:9.71134	rejected
g:9.60516	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Int -> (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  AddSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.2579
(_:15.4481	rejected
 song:13.6927	rejected
 id:12.0952	rejected
 (:12.0823
 =>:11.5196
():11.2775	prefix accepted:(
((:11.1713	prefix accepted:(
([:10.7309	prefix accepted:(
 ->:10.4661	rejected
 _:10.2295	rejected
(?:9.80307	prefix accepted:(
 :9.7222
(...):9.65061	rejected
 new:9.63543	rejected
 s:9.4298	rejected

:9.22351
 songs:9.1839	rejected
 x:8.93666	rejected
({:8.86232	prefix accepted:(
 to:8.83701	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:17.3165
id:17.1459
new:15.3431
x:13.8723
i:12.6985
Id:12.2719	rejected
s:12.1872
add:12.1698
track:11.9671
added:11.9528
next:11.8635
current:11.8052
idx:11.6434
n:11.6284
to:11.5419
a:11.3361
item:11.3333
play:11.227
ids:11.056
name:11.0308
sound:10.946

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: new
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
_:20.096
):16.5445
Id:14.8606
S:14.8447
song:13.3187
id:12.9515
_):12.1797	prefix accepted:_
one:12.133
ID:11.6783
ly:11.6251
)->:10.8542	prefix accepted:)
est:10.6646
One:10.6086
 song:10.5221	rejected
-:10.5002	rejected
bie:9.86709
Item:9.55491
 ):9.46691
::9.45386	rejected
)=:9.39277	prefix accepted:)
 Song:9.27652	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: new_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
song:20.598
id:18.4295
one:15.9013
track:15.2424
item:14.7262
entry:13.9559
music:13.733
play:13.6271
add:13.3177
ids:13.1512
element:12.9802
sound:12.8797
s:12.8655
son:12.6761
elem:12.6256
idx:12.4801
index:12.3031
Id:12.2586
value:12.229
sing:12.2116
state:12.178

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: new_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.956
_:17.9799
)=:15.8866	prefix accepted:)
)->:15.533	prefix accepted:)
s:15.436
 ):14.2005
,:13.8964
)::13.6849	prefix accepted:)
 as:13.2598	rejected
)|:13.2494	prefix accepted:)
),:13.0828
::13.0465	rejected
_):12.3476	prefix accepted:_
 =:12.2484	rejected
ID:12.2351
Id:12.2302
id:12.1418
){:12.0663	prefix accepted:)
 =>:12.0253	rejected
 ->:11.9963	rejected
 ::11.3579	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.9548
 ->:14.9656	rejected
 :14.8008

:13.1525
 when:13.0366	rejected
 if:12.1709	rejected
 as:11.9718	rejected
 in:11.8895	rejected
  :11.6369
 =:11.5873
 :::10.7002	rejected
:::9.75245	rejected
    :9.72363
 #:9.60048	rejected
 :=:9.48415	rejected
 {:9.42683	rejected
   :9.29241
	:9.12949	rejected
 |:9.12783	rejected
 ==>:9.10975	prefix accepted: =
 //:9.07609	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.8541
 :17.9908
  :14.9618
 (:14.6569
 play:14.2341
 #:13.6734	rejected
    :13.4958
 get:13.0669
 let:13.0068
 if:12.9775
      :12.7625
 (*:12.7517	prefix accepted: (
        :12.281
 add:12.1905	rejected
 List:12.0652	rejected
                :11.9587
   :11.7673
       :11.7561
 {:11.7455	rejected
         :11.4091
 [:11.4088

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :19.9242
       :17.7319
      :17.1959
    :16.2202
   :14.8285
         :14.183
        :14.1695
#:13.825	rejected

:13.6774
 :13.5596
	:13.4747	rejected
  :13.2981
           :12.612
          :12.4205
let:11.6873
                :11.4979
            :11.4018
             :10.9962
               :10.6464
if:10.4901
              :10.4316

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:22.0433
 case:18.6271
 #:18.4263	rejected
 (:18.3723
 if:18.0364
 play:16.899
 get:16.7779
 List:16.455	rejected
 (*:16.0877	prefix accepted: (
 match:15.2516	rejected
 add:14.8638	rejected
 begin:14.6526	rejected
 ((:14.6516	prefix accepted: (
 [:14.0194
 {:13.7854	rejected
 update:13.7027
 fun:13.5117
 ([:13.4707	prefix accepted: (
 print:13.352	rejected
 Play:13.2583
 list:13.1987	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:17.6238
 song:12.8363
 new:12.7917
 current:12.4376
 old:12.064
 all:11.9332
 existing:11.7888
 add:11.3393
 ids:11.3099
 play:11.2668
 _,:11.0947	prefix accepted: _
 rec:10.8916
 already:10.7592
 is:10.6948
 cur:10.619
 not:10.5822
 remove:10.4188
 filtered:10.3738
 no:10.2276
 unique:10.2269
 (:10.1534

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.1382
 =:19.6364
_:15.158
 ,:14.2873
_,:12.9963	prefix accepted:_
 :12.7276
::12.4262
=:12.0332
1:12.025
 in:11.9837	rejected
 ::11.7482
',:11.5945	rejected
0:11.336
2:11.1586
@:11.0558	rejected
 @:10.9954	rejected
  :10.8973
':10.4572	rejected
 already:10.3415	rejected
 _,:9.97367	rejected
    :9.83016

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 state:18.7114
 current:16.5369
 _:14.7332
 play:13.3022
 song:12.7993
 old:12.6576
 playing:11.9555
 curr:11.9032
 new:11.879
 s:11.671
state:11.3614
 status:10.9332
 p:10.9157
 selected:10.7286
 cur:10.7025
 :10.6797
 st:10.57
 x:10.4881
 states:10.4482
 songs:10.3351
_:10.1378

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: ?, songs: ?, new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: state
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:22.4214
 :15.7302
=:14.9125
_:13.1987
 in:12.9329	rejected
  :12.5815
 ->:11.877	rejected
    :11.8472
,:11.6401
 as:11.5431	rejected
1:11.4106
   :11.2472
0:10.8848
      :10.7113
::10.5008
 ==:10.4872	prefix accepted: =
':10.2907	rejected
2:10.2623
       :10.1468
     :9.94238
 ::9.88153

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:20.8629
 :13.7616
 List:13.3801	rejected
 get:12.9345

:12.3364
 (:11.9062
play:11.6808
 add:11.3387	rejected
 remove:11.1377	rejected
 songs:10.9661	rejected
 list:10.5463	rejected
 song:10.4431	rejected
 filter:10.3458	rejected
 update:10.2106
 in:9.96984
 Play:9.71216
 new:9.69643
 insert:9.66213	rejected
 if:9.5734
 p:9.57293
 pl:9.47469

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:23.8577
List:14.5247	rejected
ist:13.2459	rejected
lists:12.7206	rejected
_:12.0875	rejected
lis:11.8606
lst:11.7599	rejected
l:11.755
 list:11.4449	rejected
lit:10.8376	rejected
ls:10.7834	rejected
 in:10.5765	rejected
ll:9.66822	rejected
li:9.4581

:9.45433	rejected
lista:8.99897	rejected
L:8.87488	rejected
state:8.7944	rejected
line:8.75449	rejected
 :8.65671	rejected
play:8.60471	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.9693
 :15.1473

:14.1719
,:13.4296
;:12.4255	rejected
  :11.4652
 and:11.3155	rejected
.:11.2721	rejected
in:10.1631
    :9.86171
 ,:9.71061
 |:9.69114	rejected
                :9.60109
 ?:9.48115	rejected
 @:9.31181
   :9.15119
      :9.09901
 ;:9.08174	rejected
 &&:9.00802
	:8.7513	rejected
 where:8.75108	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.0571
 :17.2881
  :14.6037
      :13.9724
    :13.3669
        :12.401
       :11.8184
 #:11.6309	rejected
   :11.5311
     :11.5136
          :11.436
                :11.3575
 List:11.2752	rejected
            :11.2099
         :11.2098
	:10.6779	rejected
 (:10.3078
 (*:10.2879	prefix accepted: (
              :10.0455
           :10.026
 if:9.81162

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :19.8432
       :16.7847
      :16.2803
    :14.9944

:14.5161
         :13.7409
   :13.6901
        :13.6138
#:13.317	rejected
 :13.2119
  :13.1617
	:13.0966	rejected
           :12.1013
          :12.0637
(*:11.3416	prefix accepted:(
                :11.0477
            :10.6816
if:10.4919
 #:10.3894	rejected
             :10.3207
let:10.0845

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:19.8159
 if:19.1529
 (:18.3875
 let:18.102
 #:18.0984	rejected
 match:17.2466	rejected
 List:17.1617	rejected
 (*:16.21	prefix accepted: (
 songs:15.6251
 ((:15.4252	prefix accepted: (
 ([:15.0496	prefix accepted: (
 get:14.6505
 [:14.6162
 song:14.4837
 {:14.4286	rejected
 play:13.8265
 new:13.7039
 add:13.6605	rejected
 remove:13.4902	rejected
 filter:13.4651	rejected
 !:13.2914

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:16.0907	rejected
 state:15.1816
 get:14.5698
 songs:14.4641
 (:12.3743
 new:11.773
 find:11.6199	rejected
 song:11.3485
 :11.1469
 not:11.0916	rejected
 [:11.085
 play:10.4664
 f:10.3941
 !:10.358
 Songs:10.3112	rejected
 list:10.2482	rejected

:10.1427
 current:10.1216	rejected
 filter:10.1122	rejected
 is:9.82132
 lists:9.24242	rejected
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get
Nature of error: Variable get is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:19.5016
State:12.5752	rejected
Id:12.4537	rejected
List:12.2977	rejected
(:12.1485	rejected
S:12.064	rejected
Play:11.0686	rejected
state:10.8574	rejected
Index:10.7295	rejected
ById:10.7233	rejected
_(:10.3837	prefix accepted:_
All:10.3832	rejected
 songs:10.0868	rejected
i:9.92355	rejected
Ids:9.78823	rejected
f:9.574	rejected
 state:9.53474	rejected
__:9.41263	rejected
.:9.36514	rejected
<:9.22285	rejected
Current:9.18853	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_
Nature of error: Variable get_ is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:22.285
song:19.7062
index:16.8974	rejected
play:15.8295	rejected
current:15.5506	rejected
all:14.5399	rejected
status:14.2424	rejected
id:14.2061	rejected
ids:14.2059	rejected
sing:14.173	rejected
states:13.8127	rejected
first:13.7485	rejected
idx:13.6854	rejected
by:13.5533	rejected
son:13.1376
position:13.1366	rejected
mem:13.1064	rejected
list:13.0068	rejected
action:12.9036	rejected
length:12.8111	rejected
pos:12.6597	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)) -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:19.2648
 play:14.2804	rejected
((:13.7814	prefix accepted:(
():13.2663	prefix accepted:(
([:13.2153	prefix accepted:(

:13.0263
 (:12.0951
_:11.7815	rejected
({:11.3022	prefix accepted:(
,:11.1145
 :10.5979
 in:10.5856	rejected
 =:10.2893
 song:10.2307	rejected
.(:9.95285	rejected
 songs:9.93884	rejected
[:9.8566	rejected
 state:9.7229	rejected
.:9.64025	rejected
(*:9.51144	prefix accepted:(
 ==:9.50374

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
play:20.6912
song:13.9571
List:13.1772	rejected
state:12.982
new:12.4516
 play:11.7542
add:11.5987	rejected
Play:11.5911
 (:11.4843

:11.2826
sing:11.1472	rejected
p:11.0871
get:10.9524
current:10.9408	rejected
update:10.883
<:10.3939	rejected
pl:10.2428
plays:10.0494	rejected
player:10.0444	rejected
list:9.78427	rejected
s:9.73401

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.0062
List:17.1635	rejected
lists:14.4709	rejected
ist:13.8015	rejected
_:13.2989	rejected
lis:12.6656
l:12.0468
lit:11.9638	rejected
lst:11.8582	rejected
ls:11.5797	rejected
 list:11.3645	rejected
):11.2796	rejected
ing:10.2415	rejected
li:10.064
state:9.95748	rejected
,:9.91071	rejected
ed:9.68047	rejected
link:9.65565	rejected
ilst:9.64274	rejected
ers:9.63451	rejected
L:9.57179	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.645
),:17.8397	prefix accepted:)
 =:13.4772
)::13.2126	prefix accepted:)
 ==:13.1915
::13.1156
);:12.7583	prefix accepted:)
).:12.3406	rejected
,:12.1971
 ):11.5167
)=:11.508	prefix accepted:)
=:11.423
_:11.3543	rejected
.:11.1375	rejected
 |:11.0286	rejected
)\:10.9054	prefix accepted:)
)?:10.7407	prefix accepted:)
)(:10.5698	prefix accepted:)
:::10.2811
)|:10.214	prefix accepted:)
 ::10.1909

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.1411
 :17.0428
 ==:14.9188
 of:14.0467	rejected
  :13.7561
 #:13.2	rejected
 =:13.1869
      :12.6597
    :12.4907
 with:12.4832	rejected
 !=:12.417
 in:12.2424	rejected
 <:11.9946
 is:11.6404	rejected
 //:11.4846	prefix accepted: /
        :11.4479
 |:11.3695
 ===:11.0757	prefix accepted: ==
                :10.9849
 <>:10.9032	prefix accepted: <
   :10.8977

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :22.159
       :18.9101
      :17.969
    :16.1705
#:15.8961	rejected
        :15.7665
         :15.6969
	:15.2823	rejected

:15.1969
   :14.6161
          :14.3572
           :14.141
                :14.0106
 :13.9586
            :13.3826
  :13.356
|:13.2293
             :12.7275
               :12.4593
(*:11.89	prefix accepted:(
              :11.8023

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.5667
 #:18.9366	rejected
 (*:14.3734	prefix accepted: (
 if:13.0114	rejected
 when:12.8561	rejected
 (:14.3734
 ||:12.3511	prefix accepted: |
 List:11.9319	rejected
 <:11.9151
 *:11.8865
 \:11.855
 //:11.8505	prefix accepted: /
 !:11.5556
 {:11.5016	rejected
 ##:11.4746	rejected
 ~:11.3836	rejected
 /*:11.3163	prefix accepted: /
 [:11.1421	rejected
 ,:11.0943
 #{:10.8884	rejected
 ?:10.8769	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Play:18.0187
 P:17.1128
 No:15.5379
 _:12.296
 Some:12.1896	rejected
 None:12.0804	rejected
 :11.3311
Play:11.1453
 (:10.2801
 Current:10.0522	rejected
 Song:9.99966	rejected
 playing:9.90652
P:9.80241
 Player:9.70182	rejected
 #:9.52528	rejected
 Remove:9.4341
 N:9.25866
 no:9.21601
 x:9.21212
 Not:9.19103	rejected
 Id:8.93412	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song" | "ing"
root ::= completions

Top 20 Logits:
ing:23.3958
S:16.5487
List:12.9929	rejected
ling:11.9531	rejected
Sing:11.8224	rejected
i:11.4305
(:11.2303	rejected
On:11.1135	rejected
list:11.0203	rejected
ed:11.0188	rejected
ings:10.7419	rejected
sing:10.2635	rejected
State:10.1528	rejected
 ->:10.0835	rejected
ING:10.0741	rejected
in:10.057
L:9.895	rejected
P:9.8538	rejected
able:9.77595	rejected
eing:9.61314	rejected
 =>:9.44783	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(_:17.3084	rejected
(:17.3002
 song:12.1414	rejected
 _:11.5892	rejected
():11.4456	prefix accepted:(
 id:10.8891	rejected
 current:10.8297	rejected
 (:10.753
 p:10.0066	rejected
 s:9.81167	rejected
 =>:9.76426
((:9.71903	prefix accepted:(
 :9.66175
 |:9.63301	rejected
 (_:9.52294	rejected
(*):9.48562	prefix accepted:(
 ->:9.40252	rejected
 x:9.11082	rejected
(?:8.99629	prefix accepted:(
 old:8.88466	rejected
|:8.71637	rejected
Rejected the highest logit candidate (_ with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
current:17.2091
song:16.4492
id:16.1434
play:15.6249
p:14.9545
curr:14.2473
selected:14.1383
now:14.1333
old:14.0693
x:14.0571
cur:13.475
last:12.713
active:12.4319
s:12.2472
a:11.7555
prev:11.4992
i:11.4792
state:11.3389
first:11.3255
ps:11.3212
next:11.3198

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):18.9529
ly:18.1267
_:18.0654
),:14.0759
S:13.4233
)->:12.3926	prefix accepted:)
Id:12.2711
)=:12.0299	prefix accepted:)
Play:11.9659
_):11.6959	prefix accepted:_
)|:11.5693	prefix accepted:)
y:11.5326
 ):11.2898
)\:10.533	prefix accepted:)
 song:10.4379	rejected
ID:10.3226
);:10.3027	prefix accepted:)
l:10.254
id:10.2013
)):9.98429
 ->:9.91571	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: currently
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: currently
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
_:19.2801
Play:16.3557
):15.8831
 playing:14.2394	rejected
play:12.4181
-:12.25	rejected
Selected:11.7118
_):11.4018	prefix accepted:_
Pl:10.918
P:10.8478
),:9.95489
 selected:9.80903	rejected
selected:9.6141
p:9.60377
 played:9.38052	rejected
)=:9.33667	prefix accepted:)
PL:9.32696
 _:9.29547	rejected
)_:9.29349	rejected
 ->:9.2661	rejected
 ):9.23332

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: currently_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: currently_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
play:20.8885
selected:18.5254
pal:16.1262
p:15.9076
pl:15.3832
id:15.2963
pla:15.0168
on:14.8295
be:14.8095
active:14.6583
song:14.64
running:14.6089
plays:14.3651
Play:13.9461
player:13.6371
list:13.5919
sing:13.4407
select:13.3548
in:13.1624
added:12.8391
s:12.7297

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently_play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_play: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: currently_play
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: currently_play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
ing:22.0949
ed:19.309
):16.7684
in:15.515
ng:15.4296
ings:14.3149
ling:14.1217
_:14.0396
i:13.3287
eing:13.3235
ning:13.2279
ig:12.8229
ign:12.8146
able:12.7534
ting:12.7398
nig:12.6777
sing:12.5291
ring:12.4526
id:12.2487
int:12.1533
ong:12.0836

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently_playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: currently_playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: currently_playing
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.3888
_:17.0348
),:15.3096
)=:14.8326	prefix accepted:)
 as:14.4942	rejected
)->:14.1737	prefix accepted:)
 ):13.8722
)::13.1706	prefix accepted:)
_):12.7607	prefix accepted:_
)|:12.7149	prefix accepted:)
)\:12.0891	prefix accepted:)
)?:11.9607	prefix accepted:)
 =>:11.669	rejected
?):11.4832	rejected
 ->:11.4463	rejected
)):11.2654
::11.1314	rejected
:::10.8946	rejected
__:10.8575
 song:10.8542	rejected
);:10.7287	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.6054
 ->:15.9043	rejected
 when:14.4231	rejected
 :14.0278

:13.1083
 as:12.1065	rejected
 if:11.6877	rejected
 |:11.3002	rejected
 \:11.1462	rejected
 =:10.5255
 ||:10.1119	rejected
  :10.0793
 ==:9.9646	prefix accepted: =
 :::9.5655	rejected
=>:9.35616
 :=:9.3074	rejected
 ?:9.17794	rejected
 &&:8.98939	rejected
 or:8.92079	rejected
 ==>:8.78412	prefix accepted: =
 //:8.70132	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :17.8266

:17.6824
 if:16.9979
 (:16.4322
 [:14.5087
 ((:14.477	prefix accepted: (
 songs:13.8856
 List:13.842	rejected
  :13.5615
 ([:13.302	prefix accepted: (
 new:12.7858
 play:12.635
 add:12.6147	rejected
 [(:12.6009	prefix accepted: [
 (*:12.5182	prefix accepted: (
 #:12.2567	rejected
    :11.2827
 ():11.2598
 \:11.2125	rejected
      :11.0231
 Play:10.9928

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :21.7142
         :18.7881
        :18.3954
      :16.1245
          :15.3355
           :15.1381
	:14.8163	rejected
     :14.5054
            :13.3599
             :13.1244
                :12.7695

:12.5686
#:12.5364	rejected
               :12.0679
              :11.8678
    :11.5375
 :11.3969
   :10.8142
  :10.5572
(:9.44711
 #:9.43201	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:21.2886
 (:18.2063
 #:17.411	rejected
 List:17.3092	rejected
 let:17.3059
 [:16.1159
 ((:16.0574	prefix accepted: (
 (*:15.887	prefix accepted: (
 case:15.5732
 ([:15.5575	prefix accepted: (
 songs:15.3194
 new:14.7463
 add:14.5138	rejected
 play:14.269
 [(:14.1461	prefix accepted: [
 remove:13.6675	rejected
 get:13.5797
 Play:13.5382
 begin:13.4504	rejected
 song:13.3509
 match:13.2928	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 new:16.6748
 currently:16.0056
 List:14.8963	rejected
 current:13.689
 not:13.2268	rejected
 songs:12.8162
 id:12.6407	rejected
 (:11.9662
 get:11.5143
 :11.362
 !:11.2138
 state:11.1775
 contains:10.9827	rejected
 Songs:10.8845	rejected
 song:10.7393
 Id:10.6231	rejected
 newly:10.0708	rejected
 is:10.0689
 [:9.88282
 find:9.87246	rejected
 Currently:9.83309	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "currently"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  currently
Nature of error: Variable currently is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: currently
LSP: Generating Completions for prefix: currently
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_playing"
root ::= completions

Top 20 Logits:
_:22.27
 ==:12.8521	rejected
 playing:12.0582	rejected
Play:12.0159	rejected
 =:11.7225	rejected
 ===:11.3982	rejected
 !=:10.4314	rejected
-:10.3225	rejected
.:9.81638	rejected
\_:9.46222	rejected
 >:9.13307	rejected
play:8.85581	rejected
 :=:8.8341	rejected
=:8.81994	rejected
(:8.70579	rejected
 ~:8.61042	rejected
 <>:8.59632	rejected

:8.59487	rejected
 !==:8.4676	rejected
 _:8.43724	rejected
 <:8.41806	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "currently_"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  currently_
Nature of error: Variable currently_ is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: currently_
LSP: Generating Completions for prefix: currently_
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "playing"
root ::= completions

Top 20 Logits:
play:26.5155
player:16.4718	rejected
pay:14.6546	rejected
Play:14.2884	rejected
plays:14.1516	rejected
 playing:13.8753	rejected
pla:13.6409
ply:13.3944	rejected
 play:12.955	rejected
pack:12.2618	rejected
lay:12.2467	rejected
party:12.2245	rejected
pl:12.1688
print:12.1352	rejected
pick:12.0687	rejected
running:12.0462	rejected
pal:11.8907	rejected
working:11.8902	rejected
pow:11.7716	rejected
plot:11.7649	rejected
show:11.7099	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently_play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "currently_play"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  currently_play
Nature of error: Variable currently_play is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: currently_play
LSP: Generating Completions for prefix: currently_play
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
ing:26.9201
ING:13.9997	rejected
ting:12.2374	rejected
ning:12.0481	rejected
ging:11.9467	rejected
ling:11.9361	rejected
1:11.8645	rejected
ng:11.7069	rejected
in:11.6599
ings:11.4191	rejected
ingt:11.2618	rejected
ating:10.8825	rejected
ed:10.8749	rejected
 ==:10.5402	rejected
ding:10.4524	rejected
_:10.3867	rejected
ining:10.3013	rejected
uing:10.2117	rejected
 =:10.205	rejected
aging:9.82568	rejected
 playing:9.8216	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <currently_playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  currently_playing
Nature of error: Expecting type Bool but got inconsistent type Id  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: currently_playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: currently_playing
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 ==:18.92
 ===:17.5623	prefix accepted: ==
 =:16.0441
 !=:14.7889
 <:14.1684
 !==:13.7601	prefix accepted: !=
 <>:13.5476	prefix accepted: <
 \:12.8319
 :12.7808
 >:12.7238
 @:12.7178
 &&:11.9819
 +:11.5938
 is:11.4033	rejected
 ?:11.382	rejected
 /:11.2565
 !:11.2502
 <=:11.2453
 >=:11.0868
==:11.0663
 ||:10.7913	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 new:18.3276
 id:13.3358	rejected
?:12.2802	rejected
 :11.6379
::11.2831	rejected
~:11.0768	rejected
#:10.7681	rejected
 get:10.7011
 song:10.6367
==:10.5843	rejected
 List:10.5093	rejected
 Int:10.5035	rejected
 -:10.3426
 Id:10.287	rejected
 current:10.0413
+:9.89085	rejected
@:9.8259	rejected
 songs:9.7192
!:9.70416
 (:9.67712
 [:9.66796

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new
Nature of error: Variable new is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_song"
root ::= completions

Top 20 Logits:
_:21.5621
 song:14.0255	rejected
-:12.5857	rejected
S:12.5362	rejected
 then:10.8544	rejected
Id:10.7931	rejected

:10.5449	rejected
song:10.5004	rejected
 Song:10.2135	rejected
 id:10.0697	rejected
 :9.99231	rejected
 _:9.91571	rejected
 new:9.8858	rejected
.:9.56131	rejected
est:9.14667	rejected
id:8.76028	rejected
 -:8.33003	rejected
 ||:8.2811	rejected
\_:8.20194	rejected
 +:7.9257	rejected
 int:7.91648	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_
Nature of error: Variable new_ is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "song"
root ::= completions

Top 20 Logits:
song:22.7005
sound:14.7747	rejected
son:13.9753
s:13.561
 song:12.6612	rejected
sing:12.2883	rejected
sun:12.0026	rejected
id:11.829	rejected
sent:11.8112	rejected
game:11.2249	rejected
story:10.9281	rejected
music:10.9277	rejected
album:10.8203	rejected
play:10.7591	rejected
spr:10.6255	rejected
som:10.6051	rejected
sleep:10.4374	rejected
S:10.3937	rejected
script:10.336	rejected
spl:10.2679	rejected
player:10.1977	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: new_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:19.7093
 :19.3086

:18.9494
 ||:16.413	rejected
 &&:15.5579
 #:15.4063	rejected
  :14.6452
 \:14.0206
 //:13.0694	prefix accepted: /
 (*:12.9802	prefix accepted: (
 or:12.8348	rejected
    :12.5344
                :12.2596
        :12.2533
      :12.0136
 (:12.9802
            :11.7463
 |:11.6477	rejected
   :11.3601
         :11.3594
 and:11.3022	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
       :21.1637
         :18.4946
        :16.8224
          :16.549
           :16.3758
            :15.1538
	:14.5463	rejected
      :14.2566
             :14.2199
                :13.9788
     :13.1679
              :13.1097
               :13.0277
#:12.9769	rejected

:12.9661
  :12.2966
    :12.0633
 :11.9306
   :11.6829
(*:11.3092	prefix accepted:(
then:9.7973

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:23.1891
 #:17.5747	rejected
 ||:17.1129	rejected
 (*:15.7327	prefix accepted: (
 &&:15.6458
 (:15.7327
 List:14.394	rejected
 else:13.8452	rejected
 or:13.3199	rejected
 //:13.2689	prefix accepted: /
 ?:13.2334	rejected
 the:12.8327
 (\:12.5366	prefix accepted: (
 filter:12.4662	rejected
 {:12.3756	rejected
 ((:12.3146	prefix accepted: (
 \:12.221
 |:12.0027	rejected
 [:11.9612	rejected
 if:11.8599	rejected
 let:11.8168	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:17.6466
 play:16.8169
 :13.359

:12.5874
 ([:12.5828	prefix accepted: (
 songs:12.4346
 ((:12.3075	prefix accepted: (
 [:11.8251
 List:11.5916	rejected
 ?:11.0012	rejected
 add:10.8909	rejected
 song:10.6503
 (*:10.4402	prefix accepted: (
 let:10.3941
 [(:10.062	prefix accepted: [
 []:10.0497
 {:9.93605	rejected
 Songs:9.89239	rejected
 new:9.87057
 list:9.59155	rejected
 if:9.44334

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.9983
ist:13.3426	rejected
List:13.2213	rejected
lists:12.97	rejected
_:12.3016	rejected
lit:12.1262	rejected
lis:11.9475
lst:11.8466	rejected
l:11.6655
 list:11.4836	rejected
ls:11.3678	rejected
(:10.8612	rejected
ilst:10.0917	rejected

:10.0422	rejected
play:9.45788	rejected
li:9.34769
state:9.31942	rejected
ll:9.16215	rejected
let:9.1603	rejected
st:9.14129	rejected
listen:9.1106	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:19.4457
 :18.4052
 #:16.1656	rejected
 else:15.7023
  :15.2902
 @:14.4086
 (*:14.2168	prefix accepted: (
                :13.5432
    :13.4213
        :13.3914
      :13.2689
            :12.5545
,:12.5371
   :12.4922
          :12.1394
         :11.9812
 \:11.7554
              :11.7162
           :11.683
       :11.6221
;:11.5648	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :21.5768
     :15.784
        :15.5609
	:14.9208	rejected
      :14.9135
         :14.8808
#:14.2842	rejected
          :13.7396

:13.7153
    :13.4915
           :13.1897
            :12.9681
   :12.9378
  :12.4963
 :12.3256
else:12.2697
             :12.1959
(*:12.0099	prefix accepted:(
                :11.8009
              :11.5785
               :11.1044

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:23.0424
 #:17.7585	rejected
 elif:17.6108	rejected
 (*:15.3648	prefix accepted: (
 els:15.1542
 (:15.3648
 if:13.997	rejected
 |:13.9406	rejected
 let:13.1967	rejected
 List:12.9054	rejected
 end:12.7773	rejected
 ((:12.2116	prefix accepted: (
 [:12.0418	rejected
 _:11.5645	rejected
 song:11.484	rejected
 Else:11.3925	rejected
 (\:11.3039	prefix accepted: (
 songs:11.2677	rejected
 el:11.2496
 case:11.1402	rejected
 {:11.0822	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:17.5984
 :14.7478

:14.4922
 List:14.4074	rejected
 ([:13.9156	prefix accepted: (
 songs:13.7951
 ((:13.7539	prefix accepted: (
 if:13.7297
 add:13.3364	rejected
 [:13.2163
 play:11.8963
 let:11.7151
 get:11.5959
 new:11.4843
 [(:10.8824	prefix accepted: [
 (*:10.726	prefix accepted: (
 begin:10.6436	rejected
 {:10.4672	rejected
 update:10.3646
 match:10.2783	rejected
 Add:10.2651

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
new:15.5559
song:15.0333
List:14.8539	rejected
get:13.2139

:13.1287
if:11.8304
play:11.4573
remove:11.3074	rejected
current:11.0334
add:10.8783	rejected
filter:10.4649	rejected
sing:9.98342	rejected
[]:9.9658
 songs:9.93456
 List:9.85804	rejected
 new:9.84472
([:9.41875	prefix accepted:(
set:9.41266	rejected
Play:9.28479
 [:9.23319
state:8.97338

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new
Nature of error: Variable new is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_song"
root ::= completions

Top 20 Logits:
_:20.8342
 song:12.4748	rejected
:::12.2703	rejected
S:12.1618	rejected
List:11.5913	rejected
song:11.441	rejected
-:11.407	rejected
 [:11.2119	rejected
 :::11.1178	rejected
 Song:10.3248	rejected
(:10.1003	rejected
[:9.84007	rejected
 List:9.43153	rejected
 songs:9.31392	rejected
 _:9.06865	rejected
Id:8.91018	rejected
\_:8.797	rejected
 new:8.79485	rejected
 @:8.76876	rejected
 list:8.73535	rejected
 Songs:8.67571	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_
Nature of error: Variable new_ is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "song"
root ::= completions

Top 20 Logits:
song:23.281
id:15.4712	rejected
s:14.2275
son:13.648
sound:13.0038	rejected
 song:12.8369	rejected
sing:12.786	rejected
list:12.508	rejected
add:12.4174	rejected
S:12.3508	rejected
album:12.1347	rejected
play:12.0964	rejected
story:11.6477	rejected
element:11.6422	rejected
SON:11.6137	rejected
item:11.5126	rejected
st:11.4903	rejected
p:11.2941	rejected
array:11.2604	rejected
set:11.0253	rejected
sent:10.9506	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song
Nature of error: Expecting type PlayList but got inconsistent type Id  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: new_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
:::19.1117
 :::18.2558
 @:13.5911
,:13.3986
 +:13.3908
@:11.3705
s:11.2575	rejected
 ::11.007
::10.6829
):10.4773
 *:10.3677
+:10.2944
 :10.1098
 -:9.8573
 <:9.51787
 ,:9.43122
 <>:9.23139	prefix accepted: <
 ++:9.19154
*:9.09589
 ~:9.06423	rejected
 ^:9.03259	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
song:16.2044
List:14.3682	rejected
get:14.1144
(:13.1799
[:11.8529
 songs:10.9736
filter:10.7039	rejected
 List:10.6062	rejected
play:9.8704
remove:9.70771	rejected
@:9.50523	rejected
((:9.35386	prefix accepted:(
 (:9.2501
sing:9.01346	rejected
 get:8.91284
lists:8.91052	rejected
Filter:8.86507	rejected
Get:8.48284	rejected

:8.35247
new:8.34271
set:8.33805	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  new_song :: song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:24.0128
,:13.9909	rejected
:::12.7682	rejected
 @:12.1463	rejected
@:11.7249	rejected
 :::11.039	rejected
.:10.8309	rejected
_:10.2726	rejected
 ,:9.92493	rejected
es:9.88265	rejected
[:9.78116	rejected
List:9.72669	rejected
sl:9.68006	rejected
):9.62694	rejected
sp:9.11443	rejected
::8.98088	rejected
 -:8.94202	rejected
list:8.82516	rejected
\:8.77835	rejected
 //:8.49635	rejected
ss:8.48891	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:18.1009
 @:17.1242
 ,:13.4425
 -:12.788
 \:12.6239
@:12.4772
):12.1832
),:12.134	prefix accepted:)
 |:11.6755	rejected
.:11.2973	rejected
 :10.6679
 +:10.1707

:9.84078
 \\:9.50954	prefix accepted: \
,\:9.40159	prefix accepted:,
,[:9.30009	prefix accepted:,
 ::9.08515
[@:9.05076	rejected
\:9.042
,(:8.95401	prefix accepted:,
:::8.95383

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "currently_playing" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 No:17.3823
 P:15.5409
 state:15.3719
 Play:14.6276
 get:12.6277
 :11.5598
 if:11.1456
 play:11.0316
 current:10.9597
 (:10.831
No:10.8088
Play:10.3916

:10.183
 no:9.95629	rejected
 Player:9.73813	rejected
state:9.59613
P:9.38876
 State:9.36755	rejected
 Get:9.23226	rejected
 playing:9.18184	rejected
 List:9.14938	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:22.1687
Play:12.952	rejected
State:12.5939	rejected
Selected:11.9305	rejected
P:11.6649	rejected
Sound:11.248	rejected
SON:11.0795	rejected
Selection:10.9384	rejected
Current:10.846	rejected
Sing:10.7236	rejected
_:10.6477	rejected
 song:10.2993	rejected
 Song:10.2933	rejected
Sh:10.1901	rejected
So:10.174
Se:9.7883	rejected
C:9.78061	rejected
New:9.48196	rejected
Show:9.47361	rejected
Action:9.36372	rejected
List:9.3301	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:24.5524
ongs:14.109	rejected
on:13.4068
ung:12.6961	rejected
oon:11.6029	rejected
ongo:11.5675	rejected
ng:11.5582	rejected
song:11.4473	rejected
Play:11.3847	rejected
uch:10.6001	rejected
 song:10.5326	rejected
om:10.445	rejected
og:10.4257	rejected
ony:10.2941	rejected
Action:10.242	rejected
ond:10.1254	rejected
ug:9.92024	rejected
ang:9.87642	rejected
ing:9.10407	rejected
ion:9.06154	rejected
one:9.05002	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:24.2486
Select:15.5923
selected:15.3363	rejected
Se:13.346
Selection:12.9637	rejected
Current:12.7306	rejected
Selector:12.5577	rejected
Available:12.5203	rejected
S:12.2519
):12.0704	rejected
Play:11.9844	rejected
Exists:11.7367	rejected
SELECT:11.5933	rejected
State:11.5513	rejected
Is:11.449	rejected
P:11.4366	rejected
Not:11.3609	rejected
 Selected:11.2814	rejected
Start:11.2166	rejected
On:11.1584	rejected
In:10.8949	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: currently_playing state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):20.2545
 ):15.483
);:13.439	prefix accepted:)
 end:13.18	rejected
 :12.3253
),:12.2475	prefix accepted:)
(*:11.9633	prefix accepted:(
)):11.8882
()):11.8749	prefix accepted:(
(:11.9633
,:11.4753

:11.3215
)(:11.1851	prefix accepted:)
 @:10.8925
)\:10.3368	prefix accepted:)
)::10.1433	prefix accepted:)
(@:9.74231	prefix accepted:(
 (*:9.71638	prefix accepted: (
)]:9.68885	prefix accepted:)
).:9.65105	rejected
():9.45365	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.4448
 :17.95
 end:17.5241
  :15.6541
   :14.2367
        :14.0694
      :14.0367
    :13.9027
 #:13.8532	rejected
 (*:13.4556	prefix accepted: (
 in:13.0404	rejected
                :12.4502
            :12.2367
          :12.2307
         :12.0654
     :11.9098
       :11.5993
end:11.2607
           :11.1013
	:10.8709	rejected
              :10.8559

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.3248
   :15.9181
      :15.9076
       :15.3151
    :14.7785
        :14.5107

:14.4715
#:13.6905	rejected
         :13.453
 :13.2082
          :12.8427
end:12.5889
  :12.5542
	:12.5373	rejected
           :12.0592
            :11.7735
                :11.7471
(*:11.7239	prefix accepted:(
|:11.696
             :10.3439
 #:10.2875	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {currently_playing: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.3897
 #:17.4809	rejected
 end:16.2908
 (*:14.8959	prefix accepted: (
 if:13.7696	rejected
 case:13.724	rejected
 else:13.3548	rejected
 _:13.2341	rejected
 <:12.4056
 (:14.8959
 (_:11.9103	rejected
 state:11.7977	rejected
 ,:11.7975
 //:11.6713	prefix accepted: /
 let:11.1418	rejected
 elif:11.1413	rejected
 ((:11.1285	prefix accepted: (
 *:10.9801
 [:10.9681	rejected
 ##:10.8542	rejected
 in:10.834	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:18.7044
 P:18.6052
 No:15.5117
 :12.3705
_:11.3365
 other:11.1933
 otherwise:10.949
P:10.6034
 Play:10.5361
 paused:10.3955
 Not:10.2424	rejected
 Other:9.72618	rejected
 others:9.69617
 x:9.67735
 None:9.65307	rejected
 p:9.5925
 current:9.42351
 N:9.32562
No:9.24796
 no:9.18204
 _,:8.98987	prefix accepted: _

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
aused:24.3969
ause:17.5817
aus:13.9443
au:13.6823
ased:13.2564	rejected
ushed:12.5793	rejected
osed:12.5327	rejected
used:11.8563	rejected
oused:10.5704	rejected
 paused:10.5685	rejected
ued:10.1621	rejected
ared:10.0321	rejected
auss:9.84266	rejected
apsed:9.59435	rejected
ending:9.56214	rejected
leased:9.36342	rejected
lapsed:9.35363	rejected
added:9.26333	rejected
anned:9.13267	rejected
uted:9.02124	rejected
usted:8.91894	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | Paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | Paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:20.8766
(:13.402	rejected
on:12.2033	rejected
 on:11.1394	rejected
O:10.922
 =>:10.7644	rejected
(_:10.7573	rejected
 On:10.7297	rejected
One:10.6401	rejected
Current:10.2072	rejected
ON:10.1892	rejected
():10.1043	rejected
 ->:10.0891	rejected
 _:9.99085	rejected
In:9.8003	rejected
Of:9.5792	rejected

:9.45587	rejected
S:9.45539	rejected
 song:9.40692	rejected
_:9.37226	rejected
 current:9.35492	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.5547
(_:17.3365	rejected
 _:13.3428	rejected
():12.7559	prefix accepted:(
 paused:11.5457	rejected
 song:11.4124	rejected
 p:11.3893	rejected
 (:11.0112
 current:10.6156	rejected
 ->:10.5962	rejected
((:10.1803	prefix accepted:(
 :9.81949
 =>:9.73142
 currently:9.29568	rejected
 (_:9.25231	rejected
(*):9.05145	prefix accepted:(
 id:9.03741	rejected
 playing:8.99866	rejected

:8.9615
 pause:8.85131	rejected
([:8.84934	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
p:18.8783
current:16.7002
song:14.0544
id:14.0371
last:13.5941
old:12.7299
play:12.4055
new:12.1873
previous:12.08
x:11.8735
sto:11.8487
prev:11.7838
al:11.657
P:11.6132
was:11.4858
curr:11.2866
now:11.2672
pre:11.2253
on:11.2154
next:11.1273
_):10.9865	prefix accepted:_

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(p

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(p
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
aused:19.7611
ause:16.1425
aus:14.5351
au:12.52
):12.3289
ending:11.6758
ast:10.5709
ased:10.4137
asted:10.3854
ul:10.1261
_:10.0761
oused:9.53393
icked:9.5168
uzz:9.34497
used:9.10409
 paused:8.96928	rejected
ained:8.95683
ac:8.8638
urs:8.62671
aux:8.57761
ref:8.45974

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: paused
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: paused
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.0567
_:18.6666
On:14.9009
)->:14.3994	prefix accepted:)
)=:14.2617	prefix accepted:)
S:13.79
 ):13.3888
on:13.2892
_):13.2468	prefix accepted:_
 =>:12.2838	rejected
Id:12.0572
)):11.8354
 =:11.6795	rejected
 ->:11.4383	rejected
__:11.4093
),:11.0663
1:10.952
)|:10.9492	prefix accepted:)
song:10.9067
,:10.8356
id:10.6964

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: paused_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: paused_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
on:21.3155
song:18.669
id:17.68
at:16.2159
one:15.8808
play:15.0467
for:14.7364
now:13.7133
in:13.5444
son:13.4897
current:13.4619
track:13.3946
up:13.352
over:13.2653
by:13.2546
music:13.0701
state:13.0604
and:13.0085
when:12.7635
from:12.422
to:12.4079

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: paused_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: paused_song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.4613
_:15.5195
)->:15.1901	prefix accepted:)
)=:15.0876	prefix accepted:)
s:15.0624
 ):14.2024
),:12.8985
)|:12.4807	prefix accepted:)
id:12.2917
 =:12.2103	rejected
 ->:12.0954	rejected
_):12.0879	prefix accepted:_
 =>:12.0807	rejected
)):11.8689
)::11.3467	prefix accepted:)
 as:11.2909	rejected
)\:11.0576	prefix accepted:)
,:10.8766
 :10.4574
->:10.4339	rejected
Id:10.2093

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.4948
 ->:18.9808	rejected
 :15.0794

:13.0704
 when:12.988	rejected
 =:12.1683
 ||:11.7364	rejected
 |:11.4654	rejected
 if:11.2521	rejected
  :11.1602
=>:10.7829
 &&:10.73	rejected
 as:10.701	rejected
 ==:10.6283	prefix accepted: =
    :10.4135
 <-:10.3825	rejected
 ==>:10.2705	prefix accepted: =
 :::10.2149	rejected
 or:10.1441	rejected
   :10.1257
 \:9.95228	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.7748
 :19.1308
 if:16.0502
 (:15.5326
  :15.4045
   :13.1624
    :13.1487
 songs:13.0748
      :12.9042
 play:12.6194
        :12.3354
 ((:12.2028	prefix accepted: (
 (*:12.1054	prefix accepted: (
 #:12.1031	rejected
if:11.6256
 [:11.52
 List:11.4926	rejected
                :11.3769
 ?:11.2972	rejected
 \:11.281	rejected
	:11.2193	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.9711
 if:16.6828
 (:15.9148
 #:14.4238	rejected
 (*:14.1034	prefix accepted: (
	:13.7483	rejected
 play:13.6336
 songs:13.0282
 List:12.8687	rejected
 ((:12.7012	prefix accepted: (
 [:12.4636
0:12.3722
1:12.2547
 get:12.0407
 If:11.8908	rejected
 ?:11.8772	rejected
 //:11.8276	rejected
 ([:11.7218	prefix accepted: (
 ():11.5785
 new:11.1834
 let:11.042

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :21.4734
         :19.0641
        :19.0152
      :17.7004
     :15.9599
	:15.6166	rejected
           :15.4979
          :15.4401
            :13.6628
             :13.6062

:13.4644
                :13.4421
#:12.9631	rejected
   :12.9288
               :12.6941
    :12.6709
              :12.4642
  :11.5167
 :10.9998
if:10.854
(:10.424

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:21.7434
 (:18.7972
 let:18.79
 case:18.4218
 #:17.3751	rejected
 songs:16.0046
 List:15.9329	rejected
 (*:15.6985	prefix accepted: (
 ((:15.2956	prefix accepted: (
 get:15.1652
 begin:14.9552	rejected
 print:14.5937	rejected
 play:14.571
 [:14.4915
 ?:14.3017	rejected
 match:13.8437	rejected
 ([:13.6804	prefix accepted: (
 Songs:13.5192	rejected
 assert:13.4026	rejected
 add:13.3006	rejected
 [(:13.2498	prefix accepted: [

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 paused:18.6116
 new:15.5036
 currently:12.0139	rejected
 current:11.5916	rejected
 :11.439
 (:11.105
 pause:10.9516
 get:10.6991
 id:10.6987	rejected
 List:10.474	rejected
 songs:10.3101
 not:10.1414	rejected
 song:10.0412
 stopped:9.48027	rejected
 p:9.46165
 pending:9.36165	rejected
 !:9.31526
 newly:9.0966	rejected
 played:8.9105	rejected
(:8.82251
  :8.80298

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "paused"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  paused
Nature of error: Variable paused is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: paused
LSP: Generating Completions for prefix: paused
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_song"
root ::= completions

Top 20 Logits:
_:21.1145
 ==:14.8335	rejected
 =:14.4372	rejected
 ===:13.7927	rejected
 song:12.6015	rejected
S:12.0443	rejected
 !=:11.1363	rejected
-:10.859	rejected
==:10.6985	rejected
.:10.6543	rejected
 &&:10.5364	rejected
song:10.4288	rejected
 ~:9.99278	rejected
__:9.8821	rejected
___:9.74181	rejected
 @:9.51293	rejected
 _:9.42742	rejected
 <>:9.3411	rejected
\_:9.28545	rejected
 Song:9.11472	rejected
=:9.02505	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "paused_"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  paused_
Nature of error: Variable paused_ is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: paused_
LSP: Generating Completions for prefix: paused_
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "song"
root ::= completions

Top 20 Logits:
song:22.4415
son:15.178
s:14.1948
sound:12.8379	rejected
session:12.3077	rejected
 song:12.2562	rejected
SON:12.1505	rejected
som:12.0346	rejected
ong:11.9977	rejected
sing:11.8681	rejected
on:11.828	rejected
sun:11.3316	rejected
S:11.0155	rejected
state:10.9911	rejected
id:10.8609	rejected
play:10.7946	rejected
story:10.7358	rejected
p:10.6959	rejected
seen:10.6308	rejected
new:10.4119	rejected
 =:10.3511	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <paused_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  paused_song
Nature of error: Expecting type Bool but got inconsistent type Id  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: paused_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: paused_song
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 ==:18.9965
 ===:16.9991	prefix accepted: ==
 =:16.9515
 !=:13.9421
 :12.6274
 !==:12.5163	prefix accepted: !=
==:12.2534
 <>:12.1854	prefix accepted: <
 @:12.0002
 <:12.1854
 ~:11.3813	rejected
 \:11.1353
 &&:10.9399
 >:10.6994
 ?:10.5476	rejected
 is:10.3128	rejected
 ==>:10.155	prefix accepted: ==

:10.155
 +:10.1434
 ||:10.0334	rejected
 :=:10.0231	prefix accepted: :

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 new:18.3168
 current:12.8957	rejected
 id:12.8505	rejected
 song:12.651
 :11.2628
 paused:10.9405
 songs:10.8507
 currently:10.6536	rejected
?:10.4501	rejected
==:10.2462	rejected
~:10.1749	rejected
::10.1346	rejected
 get:9.81268
new:9.63917
!:9.47453
#:9.31544	rejected
 stopped:9.27144	rejected
+:9.16007	rejected
=:9.15254	rejected
 n:9.14919
^:9.13755	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new
Nature of error: Variable new is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_song"
root ::= completions

Top 20 Logits:
_:21.35
 song:13.9043	rejected
-:12.3189	rejected
S:11.3284	rejected
 _:10.8496	rejected

:10.4572	rejected
song:10.1542	rejected
 Song:9.5298	rejected
.:9.43044	rejected
__:9.14058	rejected
 :8.50675	rejected
 new:8.36525	rejected
 then:8.21543	rejected
\_:7.96064	rejected
 -:7.80347	rejected
 songs:7.57767	rejected
 ||:7.46572	rejected
 id:7.41722	rejected
P:7.36677	rejected
d:6.97216	rejected
est:6.88277	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_
Nature of error: Variable new_ is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "song"
root ::= completions

Top 20 Logits:
song:23.515
sound:16.8459	rejected
son:16.2145
s:16.0842
story:14.0392	rejected
sun:13.6526	rejected
id:13.1248	rejected
 song:13.0152	rejected
game:12.6177	rejected
movie:12.6132	rejected
som:12.491	rejected
symbol:12.4547	rejected
site:12.125	rejected
sent:12.1151	rejected
school:12.0633	rejected
session:12.057	rejected
screen:11.7848	rejected
something:11.7667	rejected
SON:11.6792	rejected
music:11.6313	rejected
article:11.5727	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: new_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:

:20.4516
 :18.8593
 then:17.2296
  :16.202
 ||:15.9651	rejected
 &&:15.2646
 #:14.5293	rejected
   :13.8242
        :13.8051
    :13.7556
      :13.6052
 \:13.4125
                :13.0254
            :13.0065
          :12.8028
         :12.7231
 (*:12.342	prefix accepted: (
 //:12.227	prefix accepted: /
     :11.9626
           :11.8882
 or:11.8126	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:

:23.3722
 #:16.7445	rejected
 then:16.7098
 ||:15.361	rejected
 &&:14.5136
 (*:14.2778	prefix accepted: (
 //:13.4146	prefix accepted: /
 \:13.3131
	:13.2519	rejected
1:12.335	rejected
0:12.3325	rejected
 *:12.1891
 ##:11.8083	rejected
 THEN:11.7627	rejected
 or:11.6117	rejected
 {:11.0955	rejected
2:10.84	rejected
 ?:10.758	rejected
then:10.5914
 --:10.5852	prefix accepted: -
 ==:10.5368

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
       :22.0553
         :18.6552
        :16.8045
          :16.5321
           :16.216
	:15.823	rejected
            :14.8629
      :14.7528
             :14.599
     :13.7668
              :13.171
                :13.0816
               :12.6518

:12.4549
#:12.3764	rejected
   :12.1223
  :11.846
    :11.5874
 :10.6679
(*:10.4067	prefix accepted:(
then:10.1165

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:21.9022
 ||:15.7641	rejected
 #:15.6017	rejected
 (*:14.4881	prefix accepted: (
 &&:13.9173
 the:13.5866
 (:14.4881
 ((:12.411	prefix accepted: (
 than:12.3694	rejected
 #(:11.9805	rejected
 {:11.8144	rejected
 |:11.4969	rejected
 else:11.3023	rejected
 let:11.22	rejected
 (\:11.0775	prefix accepted: (
 or:11.0625	rejected
 Then:11.0175	rejected
then:10.8978
 ?:10.8674	rejected
 return:10.7587	rejected
 //:10.717	prefix accepted: /

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:17.7274
 (:16.5623
 ((:13.2555	prefix accepted: (
 :12.4
 ([:12.3131	prefix accepted: (
 songs:12.0322

:11.5925
 [:11.5157
 List:11.0865	rejected
 add:10.6708	rejected
 [(:10.5243	prefix accepted: [
 if:10.4039
 (*:10.237	prefix accepted: (
 Play:10.1964
 let:10.0559
(:10.0119
 song:9.99366
 list:9.79239	rejected
play:9.72365
 get:9.62691
 new:9.42341

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.3245
ist:13.7869	rejected
l:13.4461
lists:13.2961	rejected
ls:12.5086	rejected
lis:12.3543
lit:12.0556	rejected
lst:11.9488	rejected
List:11.7978	rejected
li:11.2518
_:10.9816	rejected
 list:10.8274	rejected
ll:10.6784	rejected
(:10.1366	rejected
il:10.0003	rejected
ilst:9.94239	rejected
st:9.78299	rejected
lista:9.63445	rejected
lish:9.50809	rejected
state:9.3235	rejected

:9.26823	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:20.1601
 :19.1575
  :16.7529
 else:14.8897
 #:14.6212	rejected
   :14.4009
 @:13.9217
        :13.9035
    :13.8571
                :13.7065
      :13.63
 (*:13.0869	prefix accepted: (
            :13.0849
         :12.9837
          :12.8774
             :12.3393
           :12.3386
 \:12.3001
     :12.2588
       :12.2558
              :11.9088

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
       :22.1882
        :16.1134
      :15.4657
         :15.3035
     :15.07
	:15.0248	rejected
          :13.6987
   :13.5245
    :13.3822
           :13.365
#:13.2658	rejected

:12.9913
            :12.8972
                :12.3958
             :12.1749
  :12.0706
(*:11.5824	prefix accepted:(
               :11.5516
              :11.4005
else:11.248
 :11.1927

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:21.1854
 #:16.2762	rejected
 elif:16.1602	rejected
 if:13.9618	rejected
 els:13.6887
 (*:13.5123	prefix accepted: (
 (:13.5123
 let:12.7794	rejected
 end:11.8728	rejected
 case:11.7686	rejected
 |:11.4319	rejected
 ((:11.3922	prefix accepted: (
 otherwise:11.1354	rejected
 List:10.9213	rejected
 el:10.8404
 return:10.5141	rejected
 _:10.502	rejected
 [:10.4758	rejected
 p:10.4496	rejected
 Else:10.4342	rejected
 *:10.3847

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:17.8712
 songs:14.866
 :13.595
 ((:13.458	prefix accepted: (

:13.4131
 ([:13.1522	prefix accepted: (
 List:13.0244	rejected
 if:12.9969
 [:12.637
 let:12.3117
(:12.2913
 play:11.689
 add:11.6413	rejected
 get:11.4327
 [(:11.0677	prefix accepted: [
 new:10.7283
 case:10.4543
 Songs:10.4286	rejected
  :10.3256
 begin:10.1712	rejected
 Play:10.0603

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
new:18.7042
song:15.3801
p:14.4018
List:14.3971	rejected
get:12.9584

:12.6402
play:11.871
 new:11.7157
news:11.1718	rejected
 songs:11.0744
if:11.0637
current:10.8215	rejected
state:10.3869
Play:10.0802
((:9.8682	prefix accepted:(
[]:9.79795
let:9.54781
sing:9.53179	rejected
P:9.52559
add:9.47117	rejected
New:9.42285	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new
Nature of error: Variable new is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_song"
root ::= completions

Top 20 Logits:
_:19.6049
-:9.40345	rejected
 song:9.21556	rejected
 _:9.13144	rejected
 songs:8.65824	rejected
Play:8.16575	rejected
 play:7.98145	rejected
song:7.8139	rejected
 music:7.80187	rejected
__:7.67342	rejected
 Songs:7.65034	rejected
 Play:7.51975	rejected
S:7.37979	rejected
s:7.21996	rejected
 list:7.16996	rejected
.:7.04977	rejected
 [:6.86317	rejected
[:6.76952	rejected
List:6.70504	rejected
 s:6.67269	rejected
_,:6.63394	prefix accepted:_

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_
Nature of error: Variable new_ is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "song"
root ::= completions

Top 20 Logits:
song:22.6801
 song:13.3169	rejected
son:12.579
id:11.9931	rejected
S:11.7742	rejected
s:11.6472
sound:11.5161	rejected
SON:10.8908	rejected
sing:10.6261	rejected
p:10.5541	rejected
sg:10.3269	rejected
play:10.0189	rejected
st:9.8298	rejected
story:9.64181	rejected
so:9.54684
sun:9.41928	rejected
 Song:9.39725	rejected
album:9.29172	rejected
script:9.23751	rejected
n:9.18241	rejected
sr:9.1054	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song
Nature of error: Expecting type PlayList but got inconsistent type Id  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: new_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
:::19.9268
 :::18.4096
,:13.483
 @:13.4367
::13.41
@:13.2918
 ::12.2285
 +:11.5834
s:11.53	rejected
:@:10.7124	prefix accepted::
@@:9.92215	prefix accepted:@
 *:9.79896
:(:9.75098	prefix accepted::
):9.70527
 ,:9.38785
.:9.10232	rejected
*:9.05408
 ++:8.9547
_:8.92765	rejected
+:8.83023
 :8.82004

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
song:19.0731
 songs:13.5965
get:13.4766
play:12.8257
(:12.3174
List:12.1828	rejected
[:11.6757
p:11.0092
::10.7606	rejected
new:10.6492
sing:10.4048	rejected
remove:9.45474	rejected
 song:9.39948
Get:9.37484	rejected
Play:9.15266
s:9.13149
xs:9.00641	rejected
[]:8.99215
 get:8.84666
@:8.83619	rejected
current:8.63121	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:21.6015
,:13.2659	rejected
[:11.8493	rejected
es:11.7344	rejected
):10.3679	rejected
os:10.3489	rejected
S:9.989	rejected
song:9.70834	rejected
,[:9.47543	rejected
1:9.33961	rejected
 songs:9.23217	rejected
is:8.98221	rejected
),:8.9142	rejected
 [:8.90037	rejected
::8.88741	rejected
_:8.86848	rejected
(:8.79866	rejected
.:8.76081	rejected
ids:8.64656	rejected
ongs:8.61665	rejected
us:8.59606	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.0917
 @:15.5043
 ,:13.9479
@:13.2406
):12.3237
),:11.9551	prefix accepted:)
 \:10.6268
,,:10.6012	prefix accepted:,
.:10.552	rejected
 P:10.3598	rejected
[@:9.72776	rejected
 :9.71764

:9.65012
::9.48756
:::9.46883
 ::9.38547
 |:9.30545	rejected
 :::9.21034
[:9.17275	rejected
,\:9.16513	prefix accepted:,
;:9.07976	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "paused_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 No:17.6845
 state:16.0596
 P:15.3933
 Play:15.0467
 get:13.451
No:12.2737
 paused:11.8642
 :11.025
 no:10.8254	rejected
 current:10.7286	rejected
P:10.3772
 play:10.3448
 None:10.2999	rejected
 (:10.147
 N:10.0122
 Get:9.96989	rejected
 State:9.96186	rejected
state:9.90245
 pause:9.78489
 if:9.60874
 p:9.0931

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:20.4142
P:13.5536	rejected
Play:12.3396	rejected
State:11.5566	rejected
 Song:11.084	rejected
Sh:10.8717	rejected
_:10.7161	rejected
So:10.2279
Se:10.2057	rejected
SON:10.1845	rejected
Sound:10.1721	rejected
M:9.8307	rejected
Action:9.81694	rejected
Sing:9.73501	rejected
SS:9.40629	rejected
Show:9.39721	rejected
 song:9.30458	rejected
Sp:9.25956	rejected
Sim:9.1423	rejected
Sign:8.97282	rejected
Sl:8.93877	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:25.1342
on:17.5361
ongs:15.6755	rejected
om:15.371	rejected
ony:13.8343	rejected
ound:13.8023	rejected
onic:13.3871	rejected
ay:13.1845	rejected
og:13.0364	rejected
oon:12.9513	rejected
oup:12.3983	rejected
ond:12.3633	rejected
ock:12.2682	rejected
ung:12.1108	rejected
now:11.8688	rejected
n:11.7231	rejected
ng:11.672	rejected
ink:11.655	rejected
play:11.5254	rejected
uch:11.5239	rejected
ongo:11.3667	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:21.854
selected:14.5061	rejected
Select:14.3385
Se:12.9167
Available:12.5581	rejected
Pres:12.3395	rejected
Equal:12.3182	rejected
Selector:12.3167	rejected
SELECT:11.8753	rejected
S:11.6146
Pressed:11.5996	rejected
Selection:11.5541	rejected
P:11.4618	rejected
Current:11.4203	rejected
Enabled:11.4054	rejected
E:11.1949	rejected
ed:11.1291	rejected
Equals:10.9548	rejected
 Selected:10.603	rejected
Generated:10.5989	rejected
List:10.5234	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: paused_song state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):20.8897
 ):15.7189
 end:13.4039	rejected
);:13.1966	prefix accepted:)
)):12.7889
),:12.7376	prefix accepted:)

:11.7537
 :11.2913
 @:11.1905
,:10.9841
)(:10.9665	prefix accepted:)
)\:10.9269	prefix accepted:)
()):10.8113	prefix accepted:(
(*:10.6506	prefix accepted:(
)::10.181	prefix accepted:)
)]:9.86078	prefix accepted:)
(:10.8113
).:9.70513	rejected
)`:9.56414	prefix accepted:)
 (*:9.53229	prefix accepted: (
@:9.52462

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:20.8523
 :18.2071
 end:17.6301
  :17.0965
        :16.0769
   :15.7136
      :15.5
    :15.3918
         :14.1894
          :14.0592
            :13.6373
     :13.6271
                :13.4274
 #:13.3198	rejected
       :13.272
 in:13.1384	rejected
           :12.9843
             :12.4439
	:12.3661	rejected
end:12.2999
 (*:12.1572	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.3032
   :15.7451
      :15.4173
    :14.9638
       :14.6659
        :13.9776

:13.3849
end:13.1516
#:13.0462	rejected
         :12.6203
	:12.5622	rejected
  :12.4759
          :12.351
 :12.1667
                :11.5261
           :11.4644
(*:11.4465	prefix accepted:(
|:11.3117
            :10.8904
             :9.90862
 #:9.87441	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {paused_song: Id, state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.2891
 #:17.9173	rejected
 end:16.6063
 (*:14.6914	prefix accepted: (
 case:13.8342	rejected
 _:13.8151	rejected
 else:12.6791	rejected
 state:12.582	rejected
 (_:12.3615	rejected
 if:11.8228	rejected
 <:11.7141
 in:11.6573	rejected
 (:14.6914
 *:11.237
 !:11.004
 //:10.9863	prefix accepted: /
 ~:10.8906	rejected
 true:10.6448	rejected
 songs:10.6404	rejected
 ||:10.6305	prefix accepted: |
 [:10.6097	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:18.0159
 No:17.3448
 :11.7354
_:11.6664
No:11.5977
 otherwise:11.1115
 None:10.9067	rejected
 no:10.8997
 Play:10.4521
 Not:9.95	rejected
Â :9.79609	rejected
 N:9.51505
  :9.15284
 NO:9.10536	rejected
 other:9.03022
 Other:8.94678	rejected
 x:8.8986
 Otherwise:8.76812	rejected
 >:8.66884	rejected
 Nothing:8.6531	rejected
 []:8.51822

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Wildcard
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.5738
 ->:15.3033	rejected
=>:14.1443
 :12.9093
 if:11.9361	rejected
 :::11.931	rejected
 when:10.925	rejected
 :=:10.9029	rejected
:::10.622	rejected
  :10.3947
->:10.1965	rejected
                :10.1835
 =:10.0609

:9.78524
 else:9.60502	rejected
   :9.40363
 then:9.37371	rejected
 ::9.36851	rejected
 (*:9.33426	prefix accepted: (
 >:9.22742	rejected
 ==>:9.2086	prefix accepted: =

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:18.1603

:16.1192
 :16.0343
 songs:15.569
 play:14.898
 if:14.774
 [:14.0261
  :13.4656
 List:13.4211	rejected
 ([:13.4005	prefix accepted: (
 let:13.3955
 ((:13.0264	prefix accepted: (
 new:12.6789
(:12.6083
 get:12.2877
 add:12.2596	rejected
 case:12.2243
 ?:11.775	rejected
 (*:11.6293	prefix accepted: (
 song:11.4788
 match:11.4026	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
new:18.5493
song:16.0959
List:14.0734	rejected
get:13.7989
play:13.0213

:12.5167
if:12.4825
 new:11.3378
 songs:11.1942
news:11.1102	rejected
sing:10.8076	rejected
[]:10.4823
add:10.4161	rejected
current:10.3619	rejected
state:10.2866
Play:10.2028
let:10.0114
New:9.85557	rejected
p:9.78556
0:9.58793
([:9.52636	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new
Nature of error: Variable new is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_song"
root ::= completions

Top 20 Logits:
_:21.9039
 song:12.9941	rejected
song:11.8629	rejected
S:11.4887	rejected
-:11.2933	rejected
 Song:10.4408	rejected
:::9.8484	rejected
 :::9.21252	rejected
__:9.15651	rejected
,:9.10821	rejected
.:8.81343	rejected
 songs:8.71042	rejected
List:8.49764	rejected
 _:8.48246	rejected
\_:8.3602	rejected
 [:8.23225	rejected
):7.83899	rejected
(:7.78215	rejected
::7.72154	rejected
est:7.71596	rejected
 @:7.65588	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_
Nature of error: Variable new_ is not bound  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "song"
root ::= completions

Top 20 Logits:
song:23.3907
id:13.7548	rejected
son:13.4088
 song:13.1337	rejected
sound:12.7596	rejected
play:12.5422	rejected
S:12.4421	rejected
s:12.3461
sing:12.2859	rejected
SON:11.6773	rejected
album:11.1452	rejected
story:10.8941	rejected
sg:10.856	rejected
add:10.4895	rejected
st:10.3799	rejected
music:10.2326	rejected
sun:10.2152	rejected
list:10.188	rejected
script:10.1841	rejected
item:10.1754	rejected
sent:10.1386	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song
Nature of error: Expecting type PlayList but got inconsistent type Id  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: new_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
:::19.2932
 :::17.2626
,:14.2804
::12.5049
 @:12.1345
@:11.9731
s:11.8807	rejected
 ::11.276
 +:10.4475
):10.018
 ,:9.96036
:@:9.37545	prefix accepted::
:(:8.86657	prefix accepted::
 *:8.81733
.:8.76692	rejected
|:8.74596	rejected
@@:8.69249	prefix accepted:@
*:8.3117
[:8.22061	rejected
_:8.16769	rejected
 ->:8.10022	prefix accepted: -

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
song:19.5501
get:14.5845
 songs:13.9559
[:12.6022
play:12.5821
List:12.4242	rejected
(:11.9841
sing:10.3502	rejected
 get:10.1388
[]:10.0389
new:9.60209
::9.41341	rejected
 song:9.33379
Get:9.26549	rejected
set:9.14337	rejected
s:9.10672
,:9.05956	rejected
Play:9.03982
@:8.90834	rejected
 List:8.84376	rejected
lists:8.73299	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:22.4392
,:12.6453	rejected
es:11.2751	rejected
):11.153	rejected
(:10.6981	rejected
[:10.4616	rejected
S:10.1194	rejected
ss:9.77854	rejected
 =:9.69179	rejected
=:9.62026	rejected
.:8.93295	rejected
]:8.641	rejected
 in:8.55648	rejected
i:8.47589	rejected
is:8.35497	rejected
m:7.71946	rejected
;:7.66052	rejected
 +:7.63769	rejected
r:7.56052	rejected
ps:7.50821	rejected
n:7.48694	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  new_song :: songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.9195
 ,:14.4536
 @:14.2287
),:12.5051	prefix accepted:)
@:12.403
):12.5051
 No:10.7194	rejected
.:10.3232	rejected
[@:10.1669	rejected
,,:10.0956	prefix accepted:,
[:9.64034	rejected
 [],:9.56551	rejected
:::9.38411

:9.35156
 \:9.3259
 :9.29611
::9.28836
,[:9.25893	prefix accepted:,
No:9.09336	rejected
 |:9.08364	rejected
(),:8.97718	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_song" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "state" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 No:18.1862
 Play:15.9667
 state:14.2152
 P:13.4734
 get:13.1308
No:12.9553
 if:11.9362
 :11.6513
 no:11.48	rejected
 current:11.3372	rejected
 play:10.8713
 (:10.2299
 None:10.2137	rejected
 Get:9.94471	rejected
 N:9.75813
Play:9.67987
 List:9.528	rejected
 Not:9.31508	rejected
 State:9.25925	rejected
 _):9.22818	rejected

:9.15816

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:23.5938
State:12.7322	rejected
Id:12.4774	rejected
Sp:12.0402	rejected
Sh:11.6865	rejected
So:11.6426
M:11.4412	rejected
St:11.2074	rejected
SON:11.153	rejected
Sound:11.1026	rejected
Spe:10.8314	rejected
Play:10.6698	rejected
D:10.604	rejected
Sch:10.5525	rejected
P:10.4119	rejected
_:10.326	rejected
List:10.2831	rejected
Sort:10.2677	rejected
 Song:10.1727	rejected
Sam:10.109	rejected
s:10.0082	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:26.8294
on:19.5963
ongs:18.9427	rejected
ons:16.0568	rejected
oon:15.6893	rejected
ung:14.8782	rejected
ony:14.8385	rejected
ond:14.76	rejected
pon:13.9882	rejected
ont:13.5262	rejected
oup:13.3953	rejected
onic:13.1914	rejected
ink:13.1871	rejected
now:13.066	rejected
ou:13.0024	rejected
ohn:12.931	rejected
lang:12.6542	rejected
om:12.6419	rejected
song:12.5666	rejected
onn:12.4154	rejected
ng:12.2744	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:23.4947
selected:13.9192	rejected
SELECT:13.3574	rejected
Select:13.312
Play:13.2131	rejected
Not:13.0852	rejected
 Selected:12.446	rejected
P:12.3046	rejected
S:12.2829
 selected:12.2605	rejected
Updated:12.0651	rejected
Current:12.049	rejected
Pressed:11.963	rejected
List:11.8455	rejected
Selector:11.8234	rejected
Start:11.6148	rejected
Selection:11.6133	rejected
):11.5415	rejected
Equal:11.4906	rejected
Loaded:11.3685	rejected
Available:11.296	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: state songs new_song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):20.2867
 end:14.7758	rejected
 ):14.6265
)):14.4806
);:12.2936	prefix accepted:)
),:11.8553	prefix accepted:)
)::11.7776	prefix accepted:)

:11.5357
)}:11.4591	prefix accepted:)
)]:11.4565	prefix accepted:)
 :10.8708
)(:10.5775	prefix accepted:)
()):10.3227	prefix accepted:(
,:10.291
));:10.2513	prefix accepted:))
)":10.2337	prefix accepted:)
(:10.3227
)>:9.85309	prefix accepted:)
))):9.82913	prefix accepted:))
)),:9.74868	prefix accepted:))
)|:9.69781	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:18.9856

:14.9099
 :13.9097
 in:13.4825	rejected
end:13.3301
  :12.2042
   :10.706
      :10.5825
    :10.3027
                :9.89451
        :9.89306
 #:9.72388	rejected
 (*:9.40463	prefix accepted: (
     :9.04842
          :8.80242
            :8.76391
         :8.629
 done:8.51541	rejected
       :8.515
	:8.12418	rejected
              :7.61746

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 in:18.8771	rejected

:16.94
 :15.3614
  :14.6054
 end:13.4464
    :13.204
      :13.0802
   :12.683
;:12.1547	rejected
        :12.117
 #:12.0108	rejected
                :11.3597
         :10.9743
     :10.953
          :10.809
            :10.5255
	:10.3581	rejected
,:10.3525
       :10.3151
#:10.0601	rejected
 and:10.0075	rejected
Rejected the highest logit candidate  in with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {state: PlayListState, songs: [Id], new_song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
in:17.9711	rejected
   :16.0607
end:15.2718

:15.0508
    :14.0988
#:14.0865	rejected
  :14.0471
 in:13.7743	rejected
      :13.636
 :13.4351
     :12.5718
        :12.3439
done:11.4053	rejected
let:11.3086	rejected
                :11.0666
         :10.9875
       :10.9381
          :10.8595
and:10.7032	rejected
}:10.6038	rejected
```:10.5021	rejected
Rejected the highest logit candidate in with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end
end

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end
end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:16.4864

:15.413
 :13.017
;:12.684	rejected
  :11.913
 #:11.8587	rejected
.:10.8765	rejected
;;:10.7839	rejected
    :10.7006
 with:10.4479	rejected
 and:10.255	rejected
 ;;:10.2005	rejected
 end:10.1834	rejected
   :10.1672
 let:10.1643	rejected
 =:9.94715
      :9.81122
#:9.6757	rejected
 ;:9.60026	rejected
in:9.55822
 ::9.36493

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end
end in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end
end in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:16.6366
 #:13.1722	rejected
 :13.0328
  :12.2756
    :11.3296
   :10.8318
#:10.4864	rejected
      :10.4425
 Play:10.12
                :9.80884
        :9.53618
;:9.30421	rejected
 {:9.29208	rejected
	:9.06116	rejected
     :9.01348
 *:8.98522	rejected
 (*:8.84531	prefix accepted: (
`:8.67025	rejected
          :8.57611
       :8.53181
 P:8.49385

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end
end in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
    | PauseCurrentSong =>
      let songs, current_state = playlist in
      case current_state
      | Playing(song) => (songs, PausedOn(song))
      | _ => playlist end
    | RemoveSong(song) =>
      (
        let songs, state = playlist in
        if song == get_state(playlist)
        then (songs, NoSongSelected)
        else songs @ [song] 
      )
    | PlaySong(id) =>
      let songs, state = playlist in
      case state
      | PausedOn(paused) => if id == paused then (songs, Playing(id)) else (songs, NoSongSelected)
      | _ => (songs, NoSongSelected) end
    | AddSong(new_song) =>
      let songs, state = playlist in
      case get_state(playlist)
      | Playing(currently_playing) =>
        if currently_playing == new_song
        then playlist
        else (new_song::songs, NoSongSelected)
      | PausedOn(paused_song) => 
        if paused_song == new_song 
        then playlist
        else (new_song::songs, NoSongSelected)
      | _ => (new_song::songs, NoSongSelected) end
end in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs @ song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.4641
#:18.4306	rejected
let:15.6444
  :14.5554
    :14.334
```:13.3949	rejected
Play:13.3701
   :13.2973
type:13.2333
 :13.0793
(*:12.927	prefix accepted:(
      :12.8962
module:12.6558	rejected
}:12.5779	rejected
                :12.4648
play:12.2988	rejected
{:12.1848	rejected
##:12.084	rejected
        :12.0665
get:12.0345
update:12.0063
